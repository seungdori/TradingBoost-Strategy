# src/trading/monitoring/break_even_handler.py

"""
브레이크이븐 처리 모듈
"""

import asyncio
import json
import traceback
from datetime import datetime
from shared.logging import get_logger, log_order

from HYPERRSI.src.api.routes.order import update_stop_loss_order, close_position, ClosePositionRequest
from HYPERRSI.src.trading.dual_side_entry import get_user_dual_side_settings
from HYPERRSI.src.core.error_handler import log_error
from .telegram_service import get_identifier, send_telegram_message
from .utils import is_true_value, get_user_settings
from .trailing_stop_handler import activate_trailing_stop

logger = get_logger(__name__)

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error


# Module-level attribute for backward compatibility
def __getattr__(name):
    if name == "redis_client":
        return _get_redis_client()
    raise AttributeError(f"module has no attribute {name}")


async def move_sl_to_break_even(user_id: str, symbol: str, side: str, break_even_price: float, contracts_amount: float, tp_index: int = 0, is_hedge: bool = False):
    """
    거래소 API를 사용해 SL(Stop Loss) 가격을 break_even_price로 업데이트.
    
    Args:
        user_id: 사용자 ID (텔레그램 ID 또는 OKX UID)
    """
    try:
        # user_id를 OKX UID로 변환
        okx_uid = await get_identifier(str(user_id))
        
        # side가 long 또는 buy이면 order_side는 sell, side가 short 또는 sell이면 order_side는 buy
        order_side = "sell"
        if side == "long" or side == "buy":
            order_side = "sell"
        elif side == "short" or side == "sell":
            order_side = "buy"
            
        result = await update_stop_loss_order(
                        new_sl_price=break_even_price,
                        symbol=symbol,
                        side=side,
                        order_side=order_side,
                        contracts_amount=contracts_amount,
                        user_id=okx_uid,
                        is_hedge=is_hedge,
                        order_type="break_even"
                    ),
                
        if isinstance(result, dict) and not result.get('success', True):
            logger.info(f"SL 업데이트 건너뜀: {result.get('message')}")
            return None
        await asyncio.sleep(2)

        telegram_message = ""

        if tp_index > 0:
            # 브레이크이븐 이동 알림 중복 방지 체크
            from datetime import datetime
            now = datetime.now()
            breakeven_move_key = f"breakeven_move:notification:user:{okx_uid}:{symbol}:{side}:tp{tp_index}"
            last_notification_time = await _get_redis_client().get(breakeven_move_key)
            
            should_send_message = True
            if last_notification_time:
                # 마지막 알림 시간과 현재 시간의 차이 계산 (초 단위)
                time_diff = int(now.timestamp()) - int(last_notification_time)
                if time_diff < 300:  # 5분(300초) 이내의 알림은 스킵
                    logger.info(f"브레이크이븐 이동 알림 중복 방지: {okx_uid}, {symbol}, {side}, TP{tp_index}, 마지막 알림으로부터 {time_diff}초 경과")
                    should_send_message = False
            
            if should_send_message:
                telegram_message += f"🔒 TP{tp_index} 체결 후 SL을 브레이크이븐({break_even_price:.2f})으로 이동\n"
                
                try:
                    dual_side_settings = await get_user_dual_side_settings(okx_uid)
                    dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
                    dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
                    if dual_side_settings.get('use_dual_side', False):
                        if dual_side_sl_type == 'existing_position':

                            if int(dual_side_sl_value) > tp_index:
                                dual_side_key = f"user:{okx_uid}:{symbol}:dual_side_position"
                                await _get_redis_client().hset(dual_side_key, "stop_loss", break_even_price)
                                telegram_message += f"🔒 양방향 포지션 SL 업데이트: {break_even_price:.2f}$\n"
                                
                except Exception as e:
                    await send_telegram_message(f"[{okx_uid}]양방향 포지션 SL 업데이트 오류: {str(e)}", okx_uid, debug=True)
                    
                # 현재 시간 저장 (중복 알림 방지용)
                await _get_redis_client().set(breakeven_move_key, str(int(now.timestamp())))
                await _get_redis_client().expire(breakeven_move_key, 600)  # 10분 TTL 설정
                
                asyncio.create_task(send_telegram_message(
                    telegram_message,
                    okx_uid
                ))
        position_key = f"user:{okx_uid}:position:{symbol}:{side}"
        await _get_redis_client().hset(position_key, "sl_price", break_even_price)
        
        # 브레이크이븐 이동 로깅
        try:
            log_order(
                user_id=okx_uid,
                symbol=symbol,
                action_type='break_even_move',
                position_side=side,
                price=break_even_price,
                quantity=contracts_amount,
                tp_index=tp_index,
                is_hedge=is_hedge
            )
        except Exception as e:
            logger.error(f"브레이크이븐 이동 로깅 실패: {str(e)}")
            
        # dual_side_position이 있는지 확인
        dual_side_key = f"user:{okx_uid}:{symbol}:dual_side_position"
        dual_side_position_exists = await _get_redis_client().exists(dual_side_key)
        
        if dual_side_position_exists:
            # dual_side_entry_tp_trigger_type 설정 확인
            dual_settings = await get_user_dual_side_settings(okx_uid)
            dual_side_entry_tp_trigger_type = dual_settings.get('dual_side_entry_tp_trigger_type', 'percent')
            dual_side_tp_value = dual_settings.get('dual_side_entry_tp_value', 10)
            dual_side_sl_value = dual_settings.get('dual_side_entry_sl_value', 10)
            
            dual_side_sl_type = dual_settings.get('dual_side_entry_sl_trigger_type', 'percent')
            dual_sl_on_tp = dual_side_sl_type == 'existing_position'
            use_dual_side = is_true_value(dual_settings.get('use_dual_side', False))
            
            if dual_side_entry_tp_trigger_type == "existing_position":
                # 반대 방향 포지션 찾기
                opposite_side = "short" if side == "long" else "long"
                
                # 반대 방향 포지션 종료
                if int(dual_side_sl_value) == tp_index:
                    
                    close_request = ClosePositionRequest(
                        close_type="market",
                        close_percent=100
                    )
                    
                    try:
                        logger.info(f"dual_side_position 종료 시도: {symbol}, {opposite_side}")
                        response = await close_position(
                            symbol=symbol, 
                            close_request=close_request, 
                            user_id=okx_uid, 
                            side=opposite_side
                        )
                        
                        # 양방향 포지션 익절 시 메인 포지션도 종료 설정이 있는지 확인
                        close_main_on_hedge_tp = dual_settings.get('close_main_on_hedge_tp', False)
                        if close_main_on_hedge_tp:
                            # 메인 포지션 종료
                            try:
                                main_close_request = ClosePositionRequest(
                                    close_type="market",
                                    close_percent=100
                                )
                                await close_position(
                                    symbol=symbol,
                                    close_request=main_close_request,
                                    user_id=okx_uid,
                                    side=side  # 메인 포지션 방향
                                )
                                await send_telegram_message(f"✅양방향 포지션 익절로 메인 포지션도 종료\n" +f"━━━━━━━━━━━━━━━━\n" +f"메인 포지션의 TP{tp_index} 체결로 모든 포지션 종료\n" +f"• 메인 방향: {side}\n" +f"• 양방향 방향: {opposite_side}\n" +f"━━━━━━━━━━━━━━━━\n",okx_uid)
                            except Exception as e:
                                logger.error(f"메인 포지션 종료 실패: {str(e)}")
                                await send_telegram_message(f"메인 포지션 종료 실패: {str(e)}", okx_uid, debug=True)
                        else:
                            # 양방향 종료 로깅
                            await send_telegram_message(f"✅양방향 포지션 종료\n" +f"━━━━━━━━━━━━━━━━\n" +f"메인 포지션의 TP{tp_index} 체결로 양방향 포지션 종료\n" +f"• 방향: {opposite_side}\n" +f"━━━━━━━━━━━━━━━━\n",okx_uid)
                        
                        # dual_side_position 키 삭제
                        await _get_redis_client().delete(dual_side_key)
                        
                    except Exception as e:
                        logger.error(f"dual_side_position 종료 실패: {str(e)}")
                        await send_telegram_message(f"양방향 포지션 종료 실패: {str(e)}", okx_uid, debug=True)

        return result
    except Exception as e:
        error_msg = f"move_sl_to_break_even 오류: {str(e)}"
        await send_telegram_message(error_msg, okx_uid, debug=True)
        log_error(
            error=e,
            user_id=okx_uid,
            additional_info={
                "function": "move_sl_to_break_even",
                "timestamp": datetime.now().isoformat()
            }
        )
        return None


async def process_break_even_settings(user_id: str, symbol: str, order_type: str, position_data: dict):
    """
    TP 주문 체결 시 사용자 설정에 따라 브레이크이븐 처리를 수행합니다.
    
    Args:
        user_id: 사용자 ID (텔레그램 ID 또는 OKX UID)
    """
    try:
        # user_id를 OKX UID로 변환
        okx_uid = await get_identifier(str(user_id))
        
        if not (order_type.startswith('tp') or order_type.startswith('take_profit')):
            return False
            
        # TP 레벨 확인 (tp1, tp2, tp3)
        tp_level = int(order_type[2]) if len(order_type) > 2 and order_type[2].isdigit() else 1
        
        # 사용자 설정 가져오기
        settings = await get_user_settings(okx_uid) 
        dual_side_settings = await get_user_dual_side_settings(okx_uid)

        
        # 안전하게 값 처리
        use_break_even_tp1 = is_true_value(settings.get('use_break_even', False))
        use_break_even_tp2 = is_true_value(settings.get('use_break_even_tp2', False))
        use_break_even_tp3 = is_true_value(settings.get('use_break_even_tp3', False))
        
        dual_side_tp_type = dual_side_settings.get('dual_side_entry_tp_trigger_type', 'percent')
        dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
        dual_side_tp_value = dual_side_settings.get('dual_side_entry_tp_value', 10)
        dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
        tp1_close_percent = float(settings.get('tp1_ratio', 30))
        tp2_close_percent = float(settings.get('tp2_ratio', 30))
        tp3_close_percent = float(settings.get('tp3_ratio', 40))
        
        total_tp_close_ratio = tp1_close_percent + tp2_close_percent + tp3_close_percent
        dual_sl_on_tp = dual_side_sl_type == 'existing_position'
        use_dual_side = is_true_value(dual_side_settings.get('use_dual_side', False))
        
        
        # 포지션 정보 가져오기
        position_side = position_data.get('position_side', '')
        contracts_amount = float(position_data.get('contracts_amount', '0'))
        # position_data에서 진입가 확인 (avgPrice 키를 먼저 확인)
        entry_price_from_data = float(position_data.get('avgPrice', position_data.get('entry_price', '0')))
        
        dual_side_position_side = None
        if use_dual_side:
            if position_side == 'long' or position_side == 'buy':
                dual_side_position_side = 'short'
            else:
                dual_side_position_side = 'long'
                
        position_key = f"user:{okx_uid}:position:{symbol}:{position_side}"
        full_position_data = await _get_redis_client().hgetall(position_key)
        
        # 주문 가격 정보
        # Redis에서 진입가를 가져오되, 이미 position_data에서 진입가를 가져왔다면 그 값을 우선 사용
        entry_price = entry_price_from_data if entry_price_from_data > 0 else float(full_position_data.get("entry_price", 0))
        
        # contracts_amount를 이미 위에서 설정했으므로 중복 재설정하지 않음 (값이 유효하지 않은 경우에만 재설정)
        if contracts_amount <= 0:
            contracts_amount = float(full_position_data.get("contracts_amount", 0))
        
        # TP 데이터 가져오기
        tp_data_str = full_position_data.get("tp_data", "{}")
        try:
            tp_data = json.loads(tp_data_str)
        except json.JSONDecodeError:
            tp_data = []
        # TP 레벨에 따른 브레이크이븐 적용
        
        try:
            
            try:
                dual_side_key = f"user:{okx_uid}:{symbol}:dual_side_position"
                
                dual_side_key = f"user:{user_id}:{symbol}:dual_side_position"
            except Exception as e:
                logger.error(f"양방향 포지션 키 오류: {str(e)}")
                dual_side_key =f"user:{user_id}:{symbol}:dual_side_position"
            
            dual_side_position_exists = await _get_redis_client().exists(dual_side_key)

            if dual_side_position_exists:
                if dual_side_tp_type == 'existing_position':
                    if int(dual_side_tp_value) == tp_level:
                        close_request = ClosePositionRequest(
                            close_type="market",
                            close_percent=100
                        )
                        await close_position(
                            symbol=symbol,
                            close_request=close_request,
                            user_id=user_id,
                            side=dual_side_position_side
                        )
                        
                        # 양방향 포지션 익절 시 메인 포지션도 종료 설정이 있는지 확인
                        close_main_on_hedge_tp = dual_side_settings.get('close_main_on_hedge_tp', False)
                        if close_main_on_hedge_tp:
                            # 메인 포지션 종료
                            try:
                                main_close_request = ClosePositionRequest(
                                    close_type="market",
                                    close_percent=100
                                )
                                await close_position(
                                    symbol=symbol,
                                    close_request=main_close_request,
                                    user_id=user_id,
                                    side=position_side  # 메인 포지션 방향
                                )
                                await send_telegram_message(f"✅양방향 포지션 익절로 메인 포지션도 종료\n" +f"━━━━━━━━━━━━━━━━\n" +f"메인 포지션의 TP{tp_level} 체결로 모든 포지션 종료\n" +f"• 메인 방향: {position_side}\n" +f"• 양방향 방향: {dual_side_position_side}\n" +f"━━━━━━━━━━━━━━━━\n",user_id)
                            except Exception as e:
                                logger.error(f"메인 포지션 종료 실패: {str(e)}")
                                await send_telegram_message(f"메인 포지션 종료 실패: {str(e)}", user_id, debug=True)
                        else:
                            await send_telegram_message(f"✅양방향 포지션 종료\n" +f"━━━━━━━━━━━━━━━━\n" +f"메인 포지션의 TP{tp_level} 체결로 양방향 포지션 종료\n" +f"• 방향: {dual_side_position_side}\n" +f"━━━━━━━━━━━━━━━━\n",user_id)
                        
                if dual_side_sl_type == 'existing_position':
                    if int(dual_side_sl_value) == tp_level:
                        close_request = ClosePositionRequest(
                            close_type="market",
                            close_percent=100
                        )
                        await close_position(
                            symbol=symbol,
                            close_request=close_request,
                            user_id=user_id,
                            side=dual_side_position_side
                        )
                        await send_telegram_message(f"✅양방향 포지션 종료\n" +f"━━━━━━━━━━━━━━━━\n" +f"메인 포지션의 TP{tp_level} 체결로 양방향 포지션 종료\n" +f"• 방향: {dual_side_position_side}\n" +f"━━━━━━━━━━━━━━━━\n",user_id)
                        
        except Exception as e:
            logger.error(f"양방향 포지션 종료 실패!: {str(e)}")
            await send_telegram_message(f"양방향 포지션 종료 실패! {str(e)}", user_id, debug=True)
        
        try:
            if tp_level == 1 and use_break_even_tp1:
                #await send_telegram_message(f"TP1 브레이크이븐 확인. [DEBUG] TP1 체결: SL을 브레이크이븐({entry_price})으로 이동합니다.", user_id, debug = True)
                # TP1 체결 시 진입가(브레이크이븐)으로 SL 이동
                print(f"entry_price: {entry_price}, contracts_amount: {contracts_amount}")
                if entry_price > 0 and contracts_amount > 0:
                    logger.info(f"TP1 체결: SL을 브레이크이븐({entry_price})으로 이동합니다.")
                    asyncio.create_task(move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=position_side,
                        break_even_price=entry_price,
                        contracts_amount=contracts_amount,
                        tp_index=tp_level,
                    ))
                #else:
                #    await send_telegram_message(f"오류. {entry_price}, {contracts_amount}\n아마 포지션이 이미 없는 경우.", user_id, debug = True)
                    
            elif tp_level == 2 and use_break_even_tp2:
                # TP2 체결 시 TP1 가격으로 SL 이동
                if isinstance(tp_data, list):
                    tp1_price = next((float(tp.get('price', 0)) for tp in tp_data 
                                if tp.get('level') == 1), None)
                    if tp1_price and tp1_price > 0 and contracts_amount > 0:
                        logger.info(f"TP2 체결: SL을 TP1 가격({tp1_price})으로 이동합니다.")
                        asyncio.create_task(move_sl_to_break_even(
                            user_id=user_id,
                            symbol=symbol,
                            side=position_side,
                            break_even_price=tp1_price,
                            contracts_amount=contracts_amount,
                            tp_index=tp_level
                        ))
                
            elif tp_level == 3 and use_break_even_tp3:
                # TP3 체결 시 TP2 가격으로 SL 이동
                if isinstance(tp_data, list):
                    # TP1, TP2, TP3의 비율 합이 100%인지 확인
                    #total_tp_ratio = sum(float(tp.get('ratio', 0)) for tp in tp_data if tp.get('level') in [1, 2, 3])
                    if total_tp_close_ratio >= 99:
                        logger.info(f"TP1, TP2, TP3의 비율 합이 100% 이상이므로 브레이크이븐 로직을 실행하지 않습니다.")
                        return False
                        
                    tp2_price = next((float(tp.get('price', 0)) for tp in tp_data 
                                if tp.get('level') == 2), None)
                    if tp2_price and tp2_price > 0 and contracts_amount > 0:
                        logger.info(f"TP3 체결: SL을 TP2 가격({tp2_price})으로 이동합니다.")
                        asyncio.create_task(move_sl_to_break_even(
                            user_id=user_id,
                            symbol=symbol,
                            side=position_side,
                            break_even_price=tp2_price,
                            contracts_amount=contracts_amount,
                            tp_index=tp_level
                        ))
        except Exception as e:
            logger.error(f"브레이크이븐 처리 중 오류: {str(e)}")
            traceback.print_exc()
            
        
        # TP 체결 시 트레일링 스탑 활성화 여부 확인 (사용자 설정에 따라)
        # 문자열과 불리언 모두 처리
        trailing_stop_active = is_true_value(settings.get('trailing_stop_active', False))
        
        # 문자열 값 처리
        trailing_start_point = str(settings.get('trailing_start_point', 'tp3')).lower()
        current_tp = f"tp{tp_level}"
        print(f"TRAILING START POIN : {trailing_start_point}, CURRENT TP: {current_tp}")
        
        # 사용자 설정의 시작점에 도달했는지 확인
        if trailing_stop_active and current_tp.lower() == trailing_start_point:
            logger.info(f"{current_tp.upper()} 체결: 트레일링 스탑 활성화 조건 충족")
            asyncio.create_task(activate_trailing_stop(user_id, symbol, position_side, full_position_data, tp_data))
        
        return False
    except Exception as e:
        logger.error(f"브레이크이븐 처리 중 오류: {str(e)}")
        traceback.print_exc()
        return False

