# src/trading/monitoring/break_even_handler.py

"""
ë¸Œë ˆì´í¬ì´ë¸ ì²˜ë¦¬ ëª¨ë“ˆ
"""

import asyncio
import json
import traceback
from datetime import datetime
from shared.logging import get_logger, log_order

from HYPERRSI.src.api.routes.order import update_stop_loss_order, close_position, ClosePositionRequest
from HYPERRSI.src.trading.dual_side_entry import get_user_dual_side_settings
from HYPERRSI.src.core.error_handler import log_error
from .telegram_service import get_identifier, send_telegram_message
from .utils import is_true_value, get_user_settings
from .trailing_stop_handler import activate_trailing_stop

logger = get_logger(__name__)

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error


# Module-level attribute for backward compatibility
def __getattr__(name):
    if name == "redis_client":
        return _get_redis_client()
    raise AttributeError(f"module has no attribute {name}")


async def move_sl_to_break_even(user_id: str, symbol: str, side: str, break_even_price: float, contracts_amount: float, tp_index: int = 0, is_hedge: bool = False):
    """
    ê±°ë˜ì†Œ APIë¥¼ ì‚¬ìš©í•´ SL(Stop Loss) ê°€ê²©ì„ break_even_priceë¡œ ì—…ë°ì´íŠ¸.
    
    Args:
        user_id: ì‚¬ìš©ì ID (í…”ë ˆê·¸ë¨ ID ë˜ëŠ” OKX UID)
    """
    try:
        # user_idë¥¼ OKX UIDë¡œ ë³€í™˜
        okx_uid = await get_identifier(str(user_id))
        
        # sideê°€ long ë˜ëŠ” buyì´ë©´ order_sideëŠ” sell, sideê°€ short ë˜ëŠ” sellì´ë©´ order_sideëŠ” buy
        order_side = "sell"
        if side == "long" or side == "buy":
            order_side = "sell"
        elif side == "short" or side == "sell":
            order_side = "buy"
            
        result = await update_stop_loss_order(
                        new_sl_price=break_even_price,
                        symbol=symbol,
                        side=side,
                        order_side=order_side,
                        contracts_amount=contracts_amount,
                        user_id=okx_uid,
                        is_hedge=is_hedge,
                        order_type="break_even"
                    ),
                
        if isinstance(result, dict) and not result.get('success', True):
            logger.info(f"SL ì—…ë°ì´íŠ¸ ê±´ë„ˆëœ€: {result.get('message')}")
            return None
        await asyncio.sleep(2)

        telegram_message = ""

        if tp_index > 0:
            # ë¸Œë ˆì´í¬ì´ë¸ ì´ë™ ì•Œë¦¼ ì¤‘ë³µ ë°©ì§€ ì²´í¬
            from datetime import datetime
            now = datetime.now()
            breakeven_move_key = f"breakeven_move:notification:user:{okx_uid}:{symbol}:{side}:tp{tp_index}"
            last_notification_time = await _get_redis_client().get(breakeven_move_key)
            
            should_send_message = True
            if last_notification_time:
                # ë§ˆì§€ë§‰ ì•Œë¦¼ ì‹œê°„ê³¼ í˜„ì¬ ì‹œê°„ì˜ ì°¨ì´ ê³„ì‚° (ì´ˆ ë‹¨ìœ„)
                time_diff = int(now.timestamp()) - int(last_notification_time)
                if time_diff < 300:  # 5ë¶„(300ì´ˆ) ì´ë‚´ì˜ ì•Œë¦¼ì€ ìŠ¤í‚µ
                    logger.info(f"ë¸Œë ˆì´í¬ì´ë¸ ì´ë™ ì•Œë¦¼ ì¤‘ë³µ ë°©ì§€: {okx_uid}, {symbol}, {side}, TP{tp_index}, ë§ˆì§€ë§‰ ì•Œë¦¼ìœ¼ë¡œë¶€í„° {time_diff}ì´ˆ ê²½ê³¼")
                    should_send_message = False
            
            if should_send_message:
                telegram_message += f"ğŸ”’ TP{tp_index} ì²´ê²° í›„ SLì„ ë¸Œë ˆì´í¬ì´ë¸({break_even_price:.2f})ìœ¼ë¡œ ì´ë™\n"
                
                try:
                    dual_side_settings = await get_user_dual_side_settings(okx_uid)
                    dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
                    dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
                    if dual_side_settings.get('use_dual_side', False):
                        if dual_side_sl_type == 'existing_position':

                            if int(dual_side_sl_value) > tp_index:
                                dual_side_key = f"user:{okx_uid}:{symbol}:dual_side_position"
                                await _get_redis_client().hset(dual_side_key, "stop_loss", break_even_price)
                                telegram_message += f"ğŸ”’ ì–‘ë°©í–¥ í¬ì§€ì…˜ SL ì—…ë°ì´íŠ¸: {break_even_price:.2f}$\n"
                                
                except Exception as e:
                    await send_telegram_message(f"[{okx_uid}]ì–‘ë°©í–¥ í¬ì§€ì…˜ SL ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {str(e)}", okx_uid, debug=True)
                    
                # í˜„ì¬ ì‹œê°„ ì €ì¥ (ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€ìš©)
                await _get_redis_client().set(breakeven_move_key, str(int(now.timestamp())))
                await _get_redis_client().expire(breakeven_move_key, 600)  # 10ë¶„ TTL ì„¤ì •
                
                asyncio.create_task(send_telegram_message(
                    telegram_message,
                    okx_uid
                ))
        position_key = f"user:{okx_uid}:position:{symbol}:{side}"
        await _get_redis_client().hset(position_key, "sl_price", break_even_price)
        
        # ë¸Œë ˆì´í¬ì´ë¸ ì´ë™ ë¡œê¹…
        try:
            log_order(
                user_id=okx_uid,
                symbol=symbol,
                action_type='break_even_move',
                position_side=side,
                price=break_even_price,
                quantity=contracts_amount,
                tp_index=tp_index,
                is_hedge=is_hedge
            )
        except Exception as e:
            logger.error(f"ë¸Œë ˆì´í¬ì´ë¸ ì´ë™ ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
            
        # dual_side_positionì´ ìˆëŠ”ì§€ í™•ì¸
        dual_side_key = f"user:{okx_uid}:{symbol}:dual_side_position"
        dual_side_position_exists = await _get_redis_client().exists(dual_side_key)
        
        if dual_side_position_exists:
            # dual_side_entry_tp_trigger_type ì„¤ì • í™•ì¸
            dual_settings = await get_user_dual_side_settings(okx_uid)
            dual_side_entry_tp_trigger_type = dual_settings.get('dual_side_entry_tp_trigger_type', 'percent')
            dual_side_tp_value = dual_settings.get('dual_side_entry_tp_value', 10)
            dual_side_sl_value = dual_settings.get('dual_side_entry_sl_value', 10)
            
            dual_side_sl_type = dual_settings.get('dual_side_entry_sl_trigger_type', 'percent')
            dual_sl_on_tp = dual_side_sl_type == 'existing_position'
            use_dual_side = is_true_value(dual_settings.get('use_dual_side', False))
            
            if dual_side_entry_tp_trigger_type == "existing_position":
                # ë°˜ëŒ€ ë°©í–¥ í¬ì§€ì…˜ ì°¾ê¸°
                opposite_side = "short" if side == "long" else "long"
                
                # ë°˜ëŒ€ ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ
                if int(dual_side_sl_value) == tp_index:
                    
                    close_request = ClosePositionRequest(
                        close_type="market",
                        close_percent=100
                    )
                    
                    try:
                        logger.info(f"dual_side_position ì¢…ë£Œ ì‹œë„: {symbol}, {opposite_side}")
                        response = await close_position(
                            symbol=symbol, 
                            close_request=close_request, 
                            user_id=okx_uid, 
                            side=opposite_side
                        )
                        
                        # ì–‘ë°©í–¥ í¬ì§€ì…˜ ìµì ˆ ì‹œ ë©”ì¸ í¬ì§€ì…˜ë„ ì¢…ë£Œ ì„¤ì •ì´ ìˆëŠ”ì§€ í™•ì¸
                        close_main_on_hedge_tp = dual_settings.get('close_main_on_hedge_tp', False)
                        if close_main_on_hedge_tp:
                            # ë©”ì¸ í¬ì§€ì…˜ ì¢…ë£Œ
                            try:
                                main_close_request = ClosePositionRequest(
                                    close_type="market",
                                    close_percent=100
                                )
                                await close_position(
                                    symbol=symbol,
                                    close_request=main_close_request,
                                    user_id=okx_uid,
                                    side=side  # ë©”ì¸ í¬ì§€ì…˜ ë°©í–¥
                                )
                                await send_telegram_message(f"âœ…ì–‘ë°©í–¥ í¬ì§€ì…˜ ìµì ˆë¡œ ë©”ì¸ í¬ì§€ì…˜ë„ ì¢…ë£Œ\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" +f"ë©”ì¸ í¬ì§€ì…˜ì˜ TP{tp_index} ì²´ê²°ë¡œ ëª¨ë“  í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â€¢ ë©”ì¸ ë°©í–¥: {side}\n" +f"â€¢ ì–‘ë°©í–¥ ë°©í–¥: {opposite_side}\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",okx_uid)
                            except Exception as e:
                                logger.error(f"ë©”ì¸ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}")
                                await send_telegram_message(f"ë©”ì¸ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}", okx_uid, debug=True)
                        else:
                            # ì–‘ë°©í–¥ ì¢…ë£Œ ë¡œê¹…
                            await send_telegram_message(f"âœ…ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" +f"ë©”ì¸ í¬ì§€ì…˜ì˜ TP{tp_index} ì²´ê²°ë¡œ ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â€¢ ë°©í–¥: {opposite_side}\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",okx_uid)
                        
                        # dual_side_position í‚¤ ì‚­ì œ
                        await _get_redis_client().delete(dual_side_key)
                        
                    except Exception as e:
                        logger.error(f"dual_side_position ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}")
                        await send_telegram_message(f"ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}", okx_uid, debug=True)

        return result
    except Exception as e:
        error_msg = f"move_sl_to_break_even ì˜¤ë¥˜: {str(e)}"
        await send_telegram_message(error_msg, okx_uid, debug=True)
        log_error(
            error=e,
            user_id=okx_uid,
            additional_info={
                "function": "move_sl_to_break_even",
                "timestamp": datetime.now().isoformat()
            }
        )
        return None


async def process_break_even_settings(user_id: str, symbol: str, order_type: str, position_data: dict):
    """
    TP ì£¼ë¬¸ ì²´ê²° ì‹œ ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¼ ë¸Œë ˆì´í¬ì´ë¸ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    
    Args:
        user_id: ì‚¬ìš©ì ID (í…”ë ˆê·¸ë¨ ID ë˜ëŠ” OKX UID)
    """
    try:
        # user_idë¥¼ OKX UIDë¡œ ë³€í™˜
        okx_uid = await get_identifier(str(user_id))
        
        if not (order_type.startswith('tp') or order_type.startswith('take_profit')):
            return False
            
        # TP ë ˆë²¨ í™•ì¸ (tp1, tp2, tp3)
        tp_level = int(order_type[2]) if len(order_type) > 2 and order_type[2].isdigit() else 1
        
        # ì‚¬ìš©ì ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        settings = await get_user_settings(okx_uid) 
        dual_side_settings = await get_user_dual_side_settings(okx_uid)

        
        # ì•ˆì „í•˜ê²Œ ê°’ ì²˜ë¦¬
        use_break_even_tp1 = is_true_value(settings.get('use_break_even', False))
        use_break_even_tp2 = is_true_value(settings.get('use_break_even_tp2', False))
        use_break_even_tp3 = is_true_value(settings.get('use_break_even_tp3', False))
        
        dual_side_tp_type = dual_side_settings.get('dual_side_entry_tp_trigger_type', 'percent')
        dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
        dual_side_tp_value = dual_side_settings.get('dual_side_entry_tp_value', 10)
        dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
        tp1_close_percent = float(settings.get('tp1_ratio', 30))
        tp2_close_percent = float(settings.get('tp2_ratio', 30))
        tp3_close_percent = float(settings.get('tp3_ratio', 40))
        
        total_tp_close_ratio = tp1_close_percent + tp2_close_percent + tp3_close_percent
        dual_sl_on_tp = dual_side_sl_type == 'existing_position'
        use_dual_side = is_true_value(dual_side_settings.get('use_dual_side', False))
        
        
        # í¬ì§€ì…˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        position_side = position_data.get('position_side', '')
        contracts_amount = float(position_data.get('contracts_amount', '0'))
        # position_dataì—ì„œ ì§„ì…ê°€ í™•ì¸ (avgPrice í‚¤ë¥¼ ë¨¼ì € í™•ì¸)
        entry_price_from_data = float(position_data.get('avgPrice', position_data.get('entry_price', '0')))
        
        dual_side_position_side = None
        if use_dual_side:
            if position_side == 'long' or position_side == 'buy':
                dual_side_position_side = 'short'
            else:
                dual_side_position_side = 'long'
                
        position_key = f"user:{okx_uid}:position:{symbol}:{position_side}"
        full_position_data = await _get_redis_client().hgetall(position_key)
        
        # ì£¼ë¬¸ ê°€ê²© ì •ë³´
        # Redisì—ì„œ ì§„ì…ê°€ë¥¼ ê°€ì ¸ì˜¤ë˜, ì´ë¯¸ position_dataì—ì„œ ì§„ì…ê°€ë¥¼ ê°€ì ¸ì™”ë‹¤ë©´ ê·¸ ê°’ì„ ìš°ì„  ì‚¬ìš©
        entry_price = entry_price_from_data if entry_price_from_data > 0 else float(full_position_data.get("entry_price", 0))
        
        # contracts_amountë¥¼ ì´ë¯¸ ìœ„ì—ì„œ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ì¤‘ë³µ ì¬ì„¤ì •í•˜ì§€ ì•ŠìŒ (ê°’ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ì¬ì„¤ì •)
        if contracts_amount <= 0:
            contracts_amount = float(full_position_data.get("contracts_amount", 0))
        
        # TP ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        tp_data_str = full_position_data.get("tp_data", "{}")
        try:
            tp_data = json.loads(tp_data_str)
        except json.JSONDecodeError:
            tp_data = []
        # TP ë ˆë²¨ì— ë”°ë¥¸ ë¸Œë ˆì´í¬ì´ë¸ ì ìš©
        
        try:
            
            try:
                dual_side_key = f"user:{okx_uid}:{symbol}:dual_side_position"
                
                dual_side_key = f"user:{user_id}:{symbol}:dual_side_position"
            except Exception as e:
                logger.error(f"ì–‘ë°©í–¥ í¬ì§€ì…˜ í‚¤ ì˜¤ë¥˜: {str(e)}")
                dual_side_key =f"user:{user_id}:{symbol}:dual_side_position"
            
            dual_side_position_exists = await _get_redis_client().exists(dual_side_key)

            if dual_side_position_exists:
                if dual_side_tp_type == 'existing_position':
                    if int(dual_side_tp_value) == tp_level:
                        close_request = ClosePositionRequest(
                            close_type="market",
                            close_percent=100
                        )
                        await close_position(
                            symbol=symbol,
                            close_request=close_request,
                            user_id=user_id,
                            side=dual_side_position_side
                        )
                        
                        # ì–‘ë°©í–¥ í¬ì§€ì…˜ ìµì ˆ ì‹œ ë©”ì¸ í¬ì§€ì…˜ë„ ì¢…ë£Œ ì„¤ì •ì´ ìˆëŠ”ì§€ í™•ì¸
                        close_main_on_hedge_tp = dual_side_settings.get('close_main_on_hedge_tp', False)
                        if close_main_on_hedge_tp:
                            # ë©”ì¸ í¬ì§€ì…˜ ì¢…ë£Œ
                            try:
                                main_close_request = ClosePositionRequest(
                                    close_type="market",
                                    close_percent=100
                                )
                                await close_position(
                                    symbol=symbol,
                                    close_request=main_close_request,
                                    user_id=user_id,
                                    side=position_side  # ë©”ì¸ í¬ì§€ì…˜ ë°©í–¥
                                )
                                await send_telegram_message(f"âœ…ì–‘ë°©í–¥ í¬ì§€ì…˜ ìµì ˆë¡œ ë©”ì¸ í¬ì§€ì…˜ë„ ì¢…ë£Œ\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" +f"ë©”ì¸ í¬ì§€ì…˜ì˜ TP{tp_level} ì²´ê²°ë¡œ ëª¨ë“  í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â€¢ ë©”ì¸ ë°©í–¥: {position_side}\n" +f"â€¢ ì–‘ë°©í–¥ ë°©í–¥: {dual_side_position_side}\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",user_id)
                            except Exception as e:
                                logger.error(f"ë©”ì¸ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}")
                                await send_telegram_message(f"ë©”ì¸ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}", user_id, debug=True)
                        else:
                            await send_telegram_message(f"âœ…ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" +f"ë©”ì¸ í¬ì§€ì…˜ì˜ TP{tp_level} ì²´ê²°ë¡œ ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â€¢ ë°©í–¥: {dual_side_position_side}\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",user_id)
                        
                if dual_side_sl_type == 'existing_position':
                    if int(dual_side_sl_value) == tp_level:
                        close_request = ClosePositionRequest(
                            close_type="market",
                            close_percent=100
                        )
                        await close_position(
                            symbol=symbol,
                            close_request=close_request,
                            user_id=user_id,
                            side=dual_side_position_side
                        )
                        await send_telegram_message(f"âœ…ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" +f"ë©”ì¸ í¬ì§€ì…˜ì˜ TP{tp_level} ì²´ê²°ë¡œ ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +f"â€¢ ë°©í–¥: {dual_side_position_side}\n" +f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",user_id)
                        
        except Exception as e:
            logger.error(f"ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨!: {str(e)}")
            await send_telegram_message(f"ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨! {str(e)}", user_id, debug=True)
        
        try:
            if tp_level == 1 and use_break_even_tp1:
                #await send_telegram_message(f"TP1 ë¸Œë ˆì´í¬ì´ë¸ í™•ì¸. [DEBUG] TP1 ì²´ê²°: SLì„ ë¸Œë ˆì´í¬ì´ë¸({entry_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.", user_id, debug = True)
                # TP1 ì²´ê²° ì‹œ ì§„ì…ê°€(ë¸Œë ˆì´í¬ì´ë¸)ìœ¼ë¡œ SL ì´ë™
                print(f"entry_price: {entry_price}, contracts_amount: {contracts_amount}")
                if entry_price > 0 and contracts_amount > 0:
                    logger.info(f"TP1 ì²´ê²°: SLì„ ë¸Œë ˆì´í¬ì´ë¸({entry_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                    asyncio.create_task(move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=position_side,
                        break_even_price=entry_price,
                        contracts_amount=contracts_amount,
                        tp_index=tp_level,
                    ))
                #else:
                #    await send_telegram_message(f"ì˜¤ë¥˜. {entry_price}, {contracts_amount}\nì•„ë§ˆ í¬ì§€ì…˜ì´ ì´ë¯¸ ì—†ëŠ” ê²½ìš°.", user_id, debug = True)
                    
            elif tp_level == 2 and use_break_even_tp2:
                # TP2 ì²´ê²° ì‹œ TP1 ê°€ê²©ìœ¼ë¡œ SL ì´ë™
                if isinstance(tp_data, list):
                    tp1_price = next((float(tp.get('price', 0)) for tp in tp_data 
                                if tp.get('level') == 1), None)
                    if tp1_price and tp1_price > 0 and contracts_amount > 0:
                        logger.info(f"TP2 ì²´ê²°: SLì„ TP1 ê°€ê²©({tp1_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                        asyncio.create_task(move_sl_to_break_even(
                            user_id=user_id,
                            symbol=symbol,
                            side=position_side,
                            break_even_price=tp1_price,
                            contracts_amount=contracts_amount,
                            tp_index=tp_level
                        ))
                
            elif tp_level == 3 and use_break_even_tp3:
                # TP3 ì²´ê²° ì‹œ TP2 ê°€ê²©ìœ¼ë¡œ SL ì´ë™
                if isinstance(tp_data, list):
                    # TP1, TP2, TP3ì˜ ë¹„ìœ¨ í•©ì´ 100%ì¸ì§€ í™•ì¸
                    #total_tp_ratio = sum(float(tp.get('ratio', 0)) for tp in tp_data if tp.get('level') in [1, 2, 3])
                    if total_tp_close_ratio >= 99:
                        logger.info(f"TP1, TP2, TP3ì˜ ë¹„ìœ¨ í•©ì´ 100% ì´ìƒì´ë¯€ë¡œ ë¸Œë ˆì´í¬ì´ë¸ ë¡œì§ì„ ì‹¤í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
                        return False
                        
                    tp2_price = next((float(tp.get('price', 0)) for tp in tp_data 
                                if tp.get('level') == 2), None)
                    if tp2_price and tp2_price > 0 and contracts_amount > 0:
                        logger.info(f"TP3 ì²´ê²°: SLì„ TP2 ê°€ê²©({tp2_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                        asyncio.create_task(move_sl_to_break_even(
                            user_id=user_id,
                            symbol=symbol,
                            side=position_side,
                            break_even_price=tp2_price,
                            contracts_amount=contracts_amount,
                            tp_index=tp_level
                        ))
        except Exception as e:
            logger.error(f"ë¸Œë ˆì´í¬ì´ë¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            traceback.print_exc()
            
        
        # TP ì²´ê²° ì‹œ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì—¬ë¶€ í™•ì¸ (ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¼)
        # ë¬¸ìì—´ê³¼ ë¶ˆë¦¬ì–¸ ëª¨ë‘ ì²˜ë¦¬
        trailing_stop_active = is_true_value(settings.get('trailing_stop_active', False))
        
        # ë¬¸ìì—´ ê°’ ì²˜ë¦¬
        trailing_start_point = str(settings.get('trailing_start_point', 'tp3')).lower()
        current_tp = f"tp{tp_level}"
        print(f"TRAILING START POIN : {trailing_start_point}, CURRENT TP: {current_tp}")
        
        # ì‚¬ìš©ì ì„¤ì •ì˜ ì‹œì‘ì ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸
        if trailing_stop_active and current_tp.lower() == trailing_start_point:
            logger.info(f"{current_tp.upper()} ì²´ê²°: íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì¡°ê±´ ì¶©ì¡±")
            asyncio.create_task(activate_trailing_stop(user_id, symbol, position_side, full_position_data, tp_data))
        
        return False
    except Exception as e:
        logger.error(f"ë¸Œë ˆì´í¬ì´ë¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()
        return False

