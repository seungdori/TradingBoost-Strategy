# src/trading/monitoring.py

import asyncio
import json
from datetime import datetime, timedelta
import traceback
from typing import Dict, List, Optional, Set, Tuple
import time
import gc
import sys
import os
import aiohttp

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../../")))
from src.helpers.order_helper import contracts_to_qty
import signal
import atexit
import psutil
from src.core.logger import get_logger, log_order
from src.core.database import redis_client
from src.trading.services.get_current_price import get_current_price
from src.api.dependencies import  get_exchange_context
from src.bot.telegram_message import send_telegram_message
from src.core.error_handler import log_error
from src.api.routes.order import close_position, get_order_detail, update_stop_loss_order, get_algo_order_info, ClosePositionRequest
from src.trading.dual_side_entry import get_user_dual_side_settings

# ì§€ì›í•˜ëŠ” ê±°ë˜ ì‹¬ë³¼ ëª©ë¡ (ì¶”í›„ í™•ì¥ ê°€ëŠ¥)
SUPPORTED_SYMBOLS = ["BTC-USDT-SWAP", "ETH-USDT-SWAP", "SOL-USDT-SWAP"]

# ë¶ˆë¦¬ì–¸ ê°’ ë˜ëŠ” ë¬¸ìì—´ì„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
def is_true_value(value):
    if isinstance(value, bool):
        return value
    elif isinstance(value, str):
        return value.lower() == 'true'
    return False
# ì‹œìŠ¤í…œ íŠ¹ì • ëª¨ë“ˆ (ì¡°ê±´ë¶€ ì„í¬íŠ¸)
try:
    import resource  # Unix ì „ìš©
except ImportError:
    resource = None




MONITOR_INTERVAL = 5
ORDER_CHECK_INTERVAL = 10  # ì£¼ë¬¸ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ê°„ê²©(ì´ˆ)

# ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì„¤ì •
MAX_RESTART_ATTEMPTS = 5  # ìµœëŒ€ ì¬ì‹œì‘ íšŸìˆ˜ 
MAX_MEMORY_MB = 2048     # ìµœëŒ€ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (MB)
MEMORY_CLEANUP_INTERVAL = 600  # ë©”ëª¨ë¦¬ ì •ë¦¬ ê°„ê²© (10ë¶„)
CONNECTION_TIMEOUT = 30  # API ì—°ê²° íƒ€ì„ì•„ì›ƒ (ì´ˆ)
API_RATE_LIMIT = 5       # ì´ˆë‹¹ ìµœëŒ€ API í˜¸ì¶œ ìˆ˜

# ìƒíƒœ ìºì‹œ ì¶”ê°€ (ìµœê·¼ ì²´í¬í•œ ì£¼ë¬¸ ìƒíƒœë¥¼ ë‹¨ì‹œê°„ ìºì‹±)
order_status_cache = {}
ORDER_STATUS_CACHE_TTL = 5  # 5ì´ˆ ìºì‹œ ìœ ì§€

async def get_user_settings(user_id: int) -> dict:
    """
    ì‚¬ìš©ìì˜ ì„¤ì • ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    
    Args:
        user_id (int): ì‚¬ìš©ì ID
        
    Returns:
        dict: ì‚¬ìš©ì ì„¤ì • ì •ë³´
    """
    try:
        settings_key = f"user:{user_id}:settings"
        settings_data = await redis_client.get(settings_key)
        
        if settings_data:
            return json.loads(settings_data)
        else:
            # ê¸°ë³¸ ì„¤ì •ê°’
            return {
                'use_sl': True,
                'use_break_even': False,
                'use_break_even_tp2': False,
                'use_break_even_tp3': False
            }
    except Exception as e:
        logger.error(f"Error getting settings for user {user_id}: {str(e)}")
        return {
            'use_sl': True,
            'use_break_even': False,
            'use_break_even_tp2': False,
            'use_break_even_tp3': False
        }


logger = get_logger(__name__)

async def get_all_running_users() -> List[int]:
    """
    í˜„ì¬ 'running' ìƒíƒœì¸ ëª¨ë“  user_idë¥¼ ì¡°íšŒ
    """
    try:
        status_keys = await redis_client.keys("user:*:trading:status")
        running_users = []
        
        for key in status_keys:
            status = await redis_client.get(key)
            if status == "running":
                # key êµ¬ì¡°: user:{user_id}:trading:status
                parts = key.split(":")
                user_id = int(parts[1])
                running_users.append(user_id)
        
        return running_users
    except Exception as e:
        logger.error(f"running_users ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
        return []

async def get_user_monitor_orders(user_id: int) -> Dict[str, Dict]:
    """
    ì‚¬ìš©ìì˜ ëª¨ë“  ëª¨ë‹ˆí„°ë§ ì¤‘ì¸ ì£¼ë¬¸ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
    
    Args:
        user_id: ì‚¬ìš©ì ID
        
    Returns:
        Dict: {order_id: order_data, ...}
    """
    try:
        # ì‚¬ìš©ì ì£¼ë¬¸ ëª¨ë‹ˆí„°ë§ í‚¤ íŒ¨í„´
        pattern = f"monitor:user:{user_id}:*:order:*"
        order_keys = await redis_client.keys(pattern)
        
        orders = {}
        for key in order_keys:
            try:
                # í‚¤ íƒ€ì… í™•ì¸
                key_type = await redis_client.type(key)
                
                # í•´ì‹œ íƒ€ì…ì¸ì§€ í™•ì¸ - ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¹„êµ
                if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                    # ì •ìƒì ì¸ í•´ì‹œ íƒ€ì…ì¸ ê²½ìš°
                    order_data = await redis_client.hgetall(key)
                    if order_data and "status" in order_data and order_data["status"] == "open":
                        # key í˜•ì‹: monitor:user:{user_id}:{symbol}:order:{order_id}
                        parts = key.split(":")
                        symbol = parts[3]
                        order_id = parts[5]
                        
                        # order_dataì— symbolê³¼ order_id ì¶”ê°€
                        order_data["symbol"] = symbol
                        order_data["order_id"] = order_id
                        orders[order_id] = order_data
                else:
                    # ë‹¤ë¥¸ íƒ€ì…ì´ë©´ ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ìŠ¤í‚µ
                    logger.warning(f"ì£¼ë¬¸ ë°ì´í„°ê°€ í•´ì‹œ íƒ€ì…ì´ ì•„ë‹™ë‹ˆë‹¤. (key: {key}, íƒ€ì…: {key_type})")
            except Exception as redis_error:
                logger.error(f"Redis ì£¼ë¬¸ ë°ì´í„° ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ (key: {key}): {str(redis_error)}")
                continue
                
        return orders
    except Exception as e:
        logger.error(f"ì‚¬ìš©ì {user_id}ì˜ ëª¨ë‹ˆí„°ë§ ì£¼ë¬¸ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
        return {}

async def check_order_status(user_id: int, symbol: str, order_id: str, order_type: str = None) -> Dict:
    """
    ê±°ë˜ì†Œ APIë¥¼ í†µí•´ ì£¼ë¬¸ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
    
    Args:
        user_id: ì‚¬ìš©ì ID
        symbol: ê±°ë˜ ì‹¬ë³¼
        order_id: ì£¼ë¬¸ ID
        order_type: ì£¼ë¬¸ ìœ í˜• ('tp1', 'tp2', 'tp3', 'sl' ë“±)
        
    Returns:
        Dict: ì£¼ë¬¸ ìƒíƒœ ì •ë³´, ì˜¤ë¥˜ ë°œìƒ ì‹œ ì£¼ë¬¸ ì·¨ì†Œ ìƒíƒœ ë°˜í™˜
    """
    try:
        # ìºì‹œ í‚¤ ìƒì„±
        cache_key = f"{user_id}:{symbol}:{order_id}"
        current_time = time.time()
        
        # ìºì‹œëœ ê²°ê³¼ê°€ ìˆìœ¼ë©´ ë°˜í™˜
        if cache_key in order_status_cache:
            cached_time, cached_result = order_status_cache[cache_key]
            if current_time - cached_time < ORDER_STATUS_CACHE_TTL:
                logger.debug(f"ìºì‹œëœ ì£¼ë¬¸ ìƒíƒœ ì‚¬ìš©: {order_id} (ìºì‹œ ìœ íš¨ ì‹œê°„: {ORDER_STATUS_CACHE_TTL - (current_time - cached_time):.1f}ì´ˆ)")
                return cached_result
            
        # TP ì£¼ë¬¸(tp1, tp2, tp3)ì€ ì¼ë°˜ ë¦¬ë°‹ ì£¼ë¬¸ìœ¼ë¡œ ì²˜ë¦¬
        is_algo = True
        
        # ì£¼ë¬¸ ìœ í˜•ì— ë”°ë¼ API í˜¸ì¶œ ë°©ì‹ ê²°ì •
        if order_type and order_type.startswith('tp'):
            is_algo = False  # TP ì£¼ë¬¸ì€ ì¼ë°˜ ì£¼ë¬¸(limit)
            logger.debug(f"TP ì£¼ë¬¸({order_type}) ì¡°íšŒ: {order_id}, ì¼ë°˜ ì£¼ë¬¸ API ì‚¬ìš©")
        else:
            # SL ì£¼ë¬¸ ë“±ì€ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸
            is_algo = True
            logger.debug(f"SL ì£¼ë¬¸ ì¡°íšŒ: {order_id}, ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ API ì‚¬ìš©")
        
        try:
            # src/api/routes/order.pyì˜ get_order_detail í•¨ìˆ˜ ì‚¬ìš©
            if is_algo:
                response = await get_algo_order_info(
                    user_id=str(user_id),
                    symbol=symbol,
                    order_id=order_id,
                    algo_type="trigger"
                )
            else:
                response = await get_order_detail(
                    order_id=order_id,
                    user_id=str(user_id),
                    symbol=symbol,
                    is_algo=is_algo,
                    algo_type= None
                )
            
            if response:
                # OrderResponse ëª¨ë¸ì„ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
                if hasattr(response, "model_dump"):
                    result = response.model_dump()
                elif hasattr(response, "dict"):  # í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€
                    result = response.dict()
                else:
                    result = dict(response)
                
                # ê²°ê³¼ ìºì‹±
                order_status_cache[cache_key] = (current_time, result)
                return result
                
        except Exception as detail_error:
            # 404 ì˜¤ë¥˜ì´ê±°ë‚˜ 'ì°¾ì„ ìˆ˜ ì—†ìŒ' ì˜¤ë¥˜ì¸ ê²½ìš°
            error_str = str(detail_error).lower()
            if "404" in error_str or "ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" in error_str or "not found" in error_str:
                logger.info(f"ì£¼ë¬¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ (ì·¨ì†Œë¨/ë§Œë£Œë¨): {order_id}, ì˜¤ë¥˜: {str(detail_error)}")
                # ì·¨ì†Œëœ ì£¼ë¬¸ìœ¼ë¡œ ì²˜ë¦¬
                result = {
                    "status": "canceled",
                    "order_id": order_id,
                    "symbol": symbol,
                    "filled_amount": "0",
                    "canceled_reason": "not_found_in_exchange"
                }
                # ê²°ê³¼ ìºì‹±
                order_status_cache[cache_key] = (current_time, result)
                return result
            else:
                logger.warning(f"get_order_detail í˜¸ì¶œ ì‹¤íŒ¨: {str(detail_error)}")
            
            # ì§ì ‘ ê±°ë˜ì†Œ API í˜¸ì¶œë¡œ í´ë°±
            try:
                async with get_exchange_context(str(user_id)) as exchange:
                    try:
                        if is_algo:
                            # ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì¡°íšŒ - ëª…ì‹œì ìœ¼ë¡œ state íŒŒë¼ë¯¸í„° ì¶”ê°€
                            params = {
                                'ordType': 'conditional', 
                                'algoId': order_id,
                                'instId': symbol,
                                'state': 'live,effective,canceled,order_failed,filled'  # ëª¨ë“  ê°€ëŠ¥í•œ ìƒíƒœ
                            }
                            
                            # API í˜¸ì¶œ ì „ í•„ìš”í•œ íŒŒë¼ë¯¸í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
                            if not order_id or not symbol:
                                logger.warning(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì¡°íšŒ í•„ìˆ˜ íŒŒë¼ë¯¸í„° ëˆ„ë½: order_id={order_id}, symbol={symbol}")
                                result = {
                                    "status": "canceled",
                                    "order_id": order_id,
                                    "symbol": symbol,
                                    "filled_amount": "0",
                                    "canceled_reason": "missing_parameters"
                                }
                                # ê²°ê³¼ ìºì‹±
                                order_status_cache[cache_key] = (current_time, result)
                                return result
                            
                            # íŒŒë¼ë¯¸í„°ë¥¼ ë¡œê¹…í•˜ì—¬ ë””ë²„ê¹…ì— ë„ì›€ì„ ì¤Œ
                            logger.debug(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì¡°íšŒ íŒŒë¼ë¯¸í„°: {params}")
                            
                            algo_orders = await exchange.privateGetTradeOrdersAlgoHistory(params)
                            
                            if algo_orders and 'data' in algo_orders and len(algo_orders['data']) > 0:
                                result = algo_orders['data'][0]
                                # ê²°ê³¼ ìºì‹±
                                order_status_cache[cache_key] = (current_time, result)
                                return result
                            else:
                                # ì£¼ë¬¸ì´ ì—†ëŠ” ê²½ìš° ì·¨ì†Œëœ ê²ƒìœ¼ë¡œ ì²˜ë¦¬
                                logger.info(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ (ì·¨ì†Œë¨): {order_id}")
                                result = {
                                    "status": "canceled",
                                    "order_id": order_id,
                                    "symbol": symbol,
                                    "filled_amount": "0",
                                    "canceled_reason": "not_found_in_exchange"
                                }
                                # ê²°ê³¼ ìºì‹±
                                order_status_cache[cache_key] = (current_time, result)
                                return result
                        else:
                            # ì¼ë°˜ ì£¼ë¬¸ ì¡°íšŒ
                            try:
                                order_info = await exchange.fetch_order(order_id, symbol)
                                # ê²°ê³¼ ìºì‹±
                                order_status_cache[cache_key] = (current_time, order_info)
                                return order_info
                            except Exception as fetch_error:
                                error_str = str(fetch_error).lower()
                                # ì£¼ë¬¸ì´ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° ì·¨ì†Œëœ ê²ƒìœ¼ë¡œ ì²˜ë¦¬
                                if "not found" in error_str or "ì¡´ì¬í•˜ì§€ ì•Š" in error_str or "ì°¾ì„ ìˆ˜ ì—†" in error_str:
                                    logger.info(f"ì¼ë°˜ ì£¼ë¬¸ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ (ì·¨ì†Œë¨): {order_id}")
                                    result = {
                                        "status": "canceled",
                                        "order_id": order_id,
                                        "symbol": symbol,
                                        "filled_amount": "0",
                                        "canceled_reason": "not_found_in_exchange"
                                    }
                                    # ê²°ê³¼ ìºì‹±
                                    order_status_cache[cache_key] = (current_time, result)
                                    return result
                                raise
                    except Exception as api_error:
                        # API í˜¸ì¶œ ì˜¤ë¥˜ì¸ ê²½ìš°
                        error_str = str(api_error).lower()
                        if "50015" in error_str and "algoId or state is required" in error_str:
                            logger.info(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì¡°íšŒ íŒŒë¼ë¯¸í„° ì˜¤ë¥˜ - ì£¼ë¬¸ì´ ì´ë¯¸ ì·¨ì†Œë¨: {order_id}")
                            result = {
                                "status": "canceled",
                                "order_id": order_id,
                                "symbol": symbol,
                                "filled_amount": "0",
                                "canceled_reason": "api_parameter_error"
                            }
                            # ê²°ê³¼ ìºì‹±
                            order_status_cache[cache_key] = (current_time, result)
                            return result
                        else:
                            logger.error(f"ê±°ë˜ì†Œ API ì§ì ‘ í˜¸ì¶œ ì‹¤íŒ¨: {str(api_error)}")
                            raise
            except Exception as exchange_error:
                logger.error(f"ê±°ë˜ì†Œ ì»¨í…ìŠ¤íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜: {str(exchange_error)}")
                # ì¥ì•  ë°œìƒ ì‹œì—ë„ ì•ˆì „í•˜ê²Œ ì·¨ì†Œëœ ê²ƒìœ¼ë¡œ ì²˜ë¦¬
                result = {
                    "status": "canceled",
                    "order_id": order_id,
                    "symbol": symbol,
                    "filled_amount": "0", 
                    "canceled_reason": "exchange_error"
                }
                # ê²°ê³¼ ìºì‹±
                order_status_cache[cache_key] = (current_time, result)
                return result
            
        # ëª¨ë“  ë°©ë²•ì„ ì‹œë„í–ˆëŠ”ë°ë„ ì£¼ë¬¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í•œ ê²½ìš°
        result = {
            "status": "canceled",
            "order_id": order_id,
            "symbol": symbol,
            "filled_amount": "0",
            "canceled_reason": "all_retrieval_methods_failed"
        }
        # ê²°ê³¼ ìºì‹±
        order_status_cache[cache_key] = (current_time, result)
        return result
    except Exception as e:
        logger.error(f"ì£¼ë¬¸ ìƒíƒœ í™•ì¸ ì¤‘ ì˜ˆì™¸ ë°œìƒ (user_id:{user_id}, symbol:{symbol}, order_id:{order_id}, order_type:{order_type}): {str(e)}")
        traceback.print_exc()
        # ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì·¨ì†Œ ìƒíƒœ ë°˜í™˜ (ì•ˆì „í•œ ë°©ì‹)
        result = {
            "status": "canceled", 
            "error": str(e),
            "order_id": order_id,
            "symbol": symbol,
            "filled_amount": "0",
            "canceled_reason": "exception"
        }
        # ê²°ê³¼ ìºì‹±
        order_status_cache[cache_key] = (current_time, result)
        return result

async def update_order_status(user_id: int, symbol: str, order_id: str, status: str, filled_amount: str = "0") -> None:
    """
    ì£¼ë¬¸ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    
    Args:
        user_id: ì‚¬ìš©ì ID
        symbol: ê±°ë˜ ì‹¬ë³¼
        order_id: ì£¼ë¬¸ ID
        status: ìƒˆ ìƒíƒœ
        filled_amount: ì²´ê²°ëœ ìˆ˜ëŸ‰
    """
    try:
        monitor_key = f"monitor:user:{user_id}:{symbol}:order:{order_id}"
        order_data = await redis_client.hgetall(monitor_key)
        
        if not order_data:
            logger.warning(f"ì£¼ë¬¸ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {monitor_key}")
            await redis_client.delete(monitor_key)
            return
        
        # ì´ë¯¸ ê°™ì€ ìƒíƒœë©´ ì—…ë°ì´íŠ¸ ë° ì•Œë¦¼ ê±´ë„ˆë›°ê¸°
        current_status = order_data.get("status", "")
        if current_status == status:
            #logger.info(f"ì£¼ë¬¸ ìƒíƒœê°€ ì´ë¯¸ '{status}'ì…ë‹ˆë‹¤. ì—…ë°ì´íŠ¸ ë° ì•Œë¦¼ ê±´ë„ˆë›°ê¸°: {order_id}")
            return
            
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        now = datetime.now()
        kr_time = now + timedelta(hours=9)
        
        contracts_amount = float(order_data.get("contracts_amount", "0"))
        filled_contracts = float(filled_amount or "0")
        remain_contracts = max(0, contracts_amount - filled_contracts)
        
        update_data = {
            "status": status,
            "filled_contracts_amount": str(filled_contracts),
            "remain_contracts_amount": str(remain_contracts),
            "last_updated_time": str(int(now.timestamp())),
            "last_updated_time_kr": kr_time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        # ì™„ë£Œëœ ì£¼ë¬¸ ì²˜ë¦¬ (ì²´ê²°, ì·¨ì†Œ, ì‹¤íŒ¨ ë“±)
        final_statuses = ["filled", "canceled", "failed"]
        if status in final_statuses:
            # ì™„ë£Œëœ ì£¼ë¬¸ì€ completed í‚¤ë¡œ ì´ë™
            completed_key = f"completed:user:{user_id}:{symbol}:order:{order_id}"
            
            # í˜„ì¬ ëª¨ë‹ˆí„°ë§ ë°ì´í„°ì— ì—…ë°ì´íŠ¸ ë°ì´í„° ì ìš©
            updated_order_data = {**order_data, **update_data}
            
            # í¬ì§€ì…˜ ì •ë³´(ì§„ì…ê°€ê²© ë“±)ê°€ ìˆë‹¤ë©´ í¬í•¨ì‹œí‚¤ê¸°
            position_side = order_data.get("position_side", "")
            if position_side:
                try:
                    position_key = f"user:{user_id}:position:{symbol}:{position_side}"
                    position_data = await redis_client.hgetall(position_key)
                    
                    # í¬ì§€ì…˜ ì •ë³´ê°€ ìˆìœ¼ë©´ ì£¼ìš” ë°ì´í„° ì¶”ê°€
                    if position_data:
                        entry_price = position_data.get("entry_price", "0")
                        leverage = position_data.get("leverage", "1")
                        is_hedge = position_data.get("is_hedge", "false")
                        
                        # completed ì£¼ë¬¸ ë°ì´í„°ì— í¬ì§€ì…˜ ì •ë³´ ì¶”ê°€
                        updated_order_data["entry_price"] = entry_price
                        updated_order_data["leverage"] = leverage
                        updated_order_data["is_hedge"] = is_hedge
                except Exception as e:
                    logger.warning(f"í¬ì§€ì…˜ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
            
            # completed í‚¤ì— ë°ì´í„° ì €ì¥
            await redis_client.hset(completed_key, mapping=updated_order_data)
            
            # 2ì£¼ì¼(14ì¼) TTL ì„¤ì •
            await redis_client.expire(completed_key, 60 * 60 * 24 * 14)  # 14ì¼ = 1,209,600ì´ˆ
            
            # ê¸°ì¡´ ëª¨ë‹ˆí„°ë§ í‚¤ ì‚­ì œ
            await redis_client.delete(monitor_key)
            
            logger.info(f"ì£¼ë¬¸ {order_id}ë¥¼ ëª¨ë‹ˆí„°ë§ì—ì„œ ì œê±°í•˜ê³  ì™„ë£Œ ì €ì¥ì†Œë¡œ ì´ë™ (TTL: 14ì¼)")
        else:
            # ì§„í–‰ ì¤‘ì¸ ì£¼ë¬¸ì€ ëª¨ë‹ˆí„°ë§ í‚¤ ì—…ë°ì´íŠ¸
            await redis_client.hset(monitor_key, mapping=update_data)
            
        logger.info(f"ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ: {order_id}, ìƒíƒœ: {status}")
        
        # ì™„ì „ ì²´ê²° ë˜ëŠ” ì·¨ì†Œëœ ê²½ìš° ì•Œë¦¼ ë°œì†¡
        if status in ["filled"]:
            order_type = order_data.get("order_type", "unknown")
            price = float(order_data.get("price", "0"))
            position_side = order_data.get("position_side", "unknown")
            
            # PnL ê³„ì‚°ì„ ìœ„í•œ ì¶”ê°€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            position_key = f"user:{user_id}:position:{symbol}:{position_side}"
            position_data = await redis_client.hgetall(position_key)
            position_qty = f"{float(position_data.get('position_qty', '0')):.3f}"
            is_hedge = position_data.get("is_hedge", "false")
            
            filled_qty = await contracts_to_qty(symbol = symbol, contracts = filled_contracts)
            
            # ë©”ì‹œì§€ êµ¬ì„± (ì£¼ë¬¸ ìœ í˜•ë³„ ë§ì¶¤í˜• ë©”ì‹œì§€)
            status_emoji = "âœ…" if status == "filled" else "âŒ"
            status_text = "ì²´ê²° ì™„ë£Œ"
            
            # ì£¼ë¬¸ ìœ í˜•ì— ë”°ë¥¸ ë©”ì‹œì§€ ì œëª© ì„¤ì •
            if status == "filled":
                if order_type == "break_even":
                    title = f"ğŸŸ¡ ë¸Œë ˆì´í¬ì´ë¸ {status_text}"
                elif order_type == "sl":
                    if is_hedge:
                        title = f"ğŸ”´ ë°˜ëŒ€í¬ì§€ì…˜ ì†ì ˆ {status_text}"
                    else:
                        title = f"ğŸ”´ ì†ì ˆ(SL) {status_text}"
                elif order_type.startswith("tp"):
                    tp_level = order_type[2:] if len(order_type) > 2 else "1"
                    title = f"ğŸŸ¢ ìµì ˆ(TP{tp_level}) {status_text}"
                else:
                    title = f"{status_emoji} ì£¼ë¬¸ {status_text}"
            else:
                if order_type == "sl":
                    title = f"âš ï¸ ì†ì ˆ(SL) ì£¼ë¬¸ {status_text}"
                elif order_type.startswith("tp"):
                    tp_level = order_type[2:] if len(order_type) > 2 else "1"
                    title = f"âš ï¸ ìµì ˆ(TP{tp_level}) ì£¼ë¬¸ {status_text}"
                else:
                    title = f"{status_emoji} ì£¼ë¬¸ {status_text}"
            
            # PnL ê³„ì‚° (ì²´ê²°ëœ ê²½ìš°ë§Œ)
            pnl_text = ""
            if status == "filled" and position_data:
                try:
                    # ì§„ì… ê°€ê²© (í‰ê·  ì§„ì…ê°€)
                    entry_price = float(position_data.get("entry_price", 0))
                    
                    # PnL ê³„ì‚°
                    if entry_price > 0:
                        if position_side == "long":
                            pnl_percent = ((price / entry_price) - 1) * 100
                        else:  # short
                            pnl_percent = ((entry_price / price) - 1) * 100
                        
                        # PnL ì•„ì´ì½˜ ì„¤ì •
                        pnl_icon = "ğŸ“ˆ" if pnl_percent > 0 else "ğŸ“‰"
                        
                        # PnL í…ìŠ¤íŠ¸ êµ¬ì„±
                        pnl_text = f"\n{pnl_icon} ìˆ˜ìµë¥ : {pnl_percent:.2f}%"
                        
                        # ë ˆë²„ë¦¬ì§€ê°€ ìˆëŠ” ê²½ìš° ë ˆë²„ë¦¬ì§€ ì ìš© ìˆ˜ìµë¥ ë„ í‘œì‹œ
                        leverage = float(position_data.get("leverage", 1))
                        if leverage > 1:
                            leveraged_pnl = pnl_percent * leverage
                            pnl_text += f" (ë ˆë²„ë¦¬ì§€ x{leverage} ì ìš©: {leveraged_pnl:.2f}%)"
                except Exception as pnl_error:
                    logger.error(f"PnL ê³„ì‚° ì¤‘ ì˜¤ë¥˜: {str(pnl_error)}")
                    pnl_text = "\nğŸ’¡ PnL ê³„ì‚° ë¶ˆê°€"
                
            message = (
                f"{title}\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ì‹¬ë³¼: {symbol}\n"
                f"ë°©í–¥: {position_side.upper()}\n"
                f"ì²´ê²°ê°€ê²©: {price}\n"
            )
            
            # ì²´ê²°ìˆ˜ëŸ‰ì´ 0ë³´ë‹¤ í´ ë•Œë§Œ ë©”ì‹œì§€ì— ì¶”ê°€
            if float(filled_qty) > 0:
                message += f"ì²´ê²°ìˆ˜ëŸ‰: {round(float(filled_qty), 3)}{pnl_text}"
                await send_telegram_message(message, user_id=user_id)
            
            
            
            if order_type == "break_even":
                # ë¸Œë ˆì´í¬ì´ë¸ ì„¤ì • í›„ í¬ì§€ì…˜ì´ ì•„ì§ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                position_exists = await check_position_exists(user_id, symbol, position_side)

                # í¬ì§€ì…˜ì´ ì¡´ì¬í•œë‹¤ë©´ ì§ì ‘ ì¢…ë£Œ
                if position_exists:
                    logger.info(f"ë¸Œë ˆì´í¬ì´ë¸ ì„¤ì • í›„ {symbol} {position_side} í¬ì§€ì…˜ì´ ì—¬ì „íˆ ì¡´ì¬í•¨. ì§ì ‘ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                    close_request = ClosePositionRequest(
                        close_type="market",
                        price=price,
                        close_percent=100
                    )
                    try:
                        close_result = asyncio.create_task(close_position(
                            symbol=symbol,
                            close_request=close_request,
                            user_id=user_id,
                            side=position_side
                        ))


                        await send_telegram_message(
                            f"ğŸ”’ ë¸Œë ˆì´í¬ì´ë¸ ì„¤ì • í›„ {symbol} {position_side} í¬ì§€ì…˜ì„ ì§ì ‘ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤.",
                            user_id, debug = True
                        )

                        # í¬ì§€ì…˜ ì¢…ë£Œ í›„ ê´€ë ¨ ë°ì´í„° ì •ë¦¬
                        await check_and_cleanup_orders(user_id, symbol, position_side)

                    except Exception as e:
                        await send_telegram_message(f"ë¸Œë ˆì´í¬ì´ë¸ ì¢…ë£Œ ì˜¤ë¥˜!!!: {str(e)}", user_id, debug = True)

            
    
    except Exception as e:
        logger.error(f"ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")
        traceback.print_exc()

async def move_sl_to_break_even(user_id: int, symbol: str, side: str, break_even_price: float, contracts_amount: float, tp_index: int = 0, is_hedge: bool = False):
    """
    ê±°ë˜ì†Œ APIë¥¼ ì‚¬ìš©í•´ SL(Stop Loss) ê°€ê²©ì„ break_even_priceë¡œ ì—…ë°ì´íŠ¸.
    """
    try:
        # sideê°€ long ë˜ëŠ” buyì´ë©´ order_sideëŠ” sell, sideê°€ short ë˜ëŠ” sellì´ë©´ order_sideëŠ” buy
        order_side = "sell"
        if side == "long" or side == "buy":
            order_side = "sell"
        elif side == "short" or side == "sell":
            order_side = "buy"
            
        result = await update_stop_loss_order(
                        new_sl_price=break_even_price,
                        symbol=symbol,
                        side=side,
                        order_side=order_side,
                        contracts_amount=contracts_amount,
                        user_id=user_id,
                        is_hedge=is_hedge,
                        order_type="break_even"
                    ),
                
        if isinstance(result, dict) and not result.get('success', True):
            logger.info(f"SL ì—…ë°ì´íŠ¸ ê±´ë„ˆëœ€: {result.get('message')}")
            return None
        await asyncio.sleep(3)

        
        telegram_message = ""


        if tp_index > 0:
            telegram_message += f"ğŸ”’ TP{tp_index} ì²´ê²° í›„ SLì„ ë¸Œë ˆì´í¬ì´ë¸({break_even_price:.2f})ìœ¼ë¡œ ì´ë™\n"
            
            try:
                dual_side_settings = await get_user_dual_side_settings(user_id)
                dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
                dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
                if dual_side_settings.get('use_dual_side', False):
                    if dual_side_sl_type == 'existing_position':

                        if int(dual_side_sl_value) > tp_index:
                            dual_side_key = f"user:{user_id}:{symbol}:dual_side_position"
                            await redis_client.hset(dual_side_key, "stop_loss", break_even_price)
                            telegram_message += f"ğŸ”’ ì–‘ë°©í–¥ í¬ì§€ì…˜ SL ì—…ë°ì´íŠ¸: {break_even_price:.2f}$\n"
            except Exception as e:
                await send_telegram_message(f"[{user_id}]ì–‘ë°©í–¥ í¬ì§€ì…˜ SL ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {str(e)}", user_id, debug=True)
                
            
            asyncio.create_task(send_telegram_message(
                telegram_message,
                user_id
            ))
        position_key = f"user:{user_id}:position:{symbol}:{side}"
        await redis_client.hset(position_key, "sl_price", break_even_price)
        
        # ë¸Œë ˆì´í¬ì´ë¸ ì´ë™ ë¡œê¹…
        try:
            log_order(
                user_id=user_id,
                symbol=symbol,
            action_type='break_even_move',
            position_side=side,
            price=break_even_price,
            quantity=contracts_amount,
                tp_index=tp_index,
                is_hedge=is_hedge
            )
        except Exception as e:
            logger.error(f"ë¸Œë ˆì´í¬ì´ë¸ ì´ë™ ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
            
        # dual_side_positionì´ ìˆëŠ”ì§€ í™•ì¸
        dual_side_key = f"user:{user_id}:{symbol}:dual_side_position"
        dual_side_position_exists = await redis_client.exists(dual_side_key)
        
        if dual_side_position_exists:
            # dual_side_entry_tp_trigger_type ì„¤ì • í™•ì¸

            dual_settings = await get_user_dual_side_settings(user_id)
            dual_side_entry_tp_trigger_type = dual_settings.get('dual_side_entry_tp_trigger_type', 'percent')
            dual_side_tp_value = dual_settings.get('dual_side_entry_tp_value', 10)
            dual_side_sl_value = dual_settings.get('dual_side_entry_sl_value', 10)
            
            if dual_side_entry_tp_trigger_type == "existing_position":
                # ë°˜ëŒ€ ë°©í–¥ í¬ì§€ì…˜ ì°¾ê¸°
                opposite_side = "short" if side == "long" else "long"
                
                # ë°˜ëŒ€ ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ
                if int(dual_side_sl_value) == tp_index:
                    
                    close_request = ClosePositionRequest(
                        close_type="market",
                        close_percent=100
                    )
                    
                    try:
                        logger.info(f"dual_side_position ì¢…ë£Œ ì‹œë„: {symbol}, {opposite_side}")
                        response = await close_position(
                            symbol=symbol, 
                            close_request=close_request, 
                            user_id=user_id, 
                            side=opposite_side
                        )
                        
                        # ì–‘ë°©í–¥ ì¢…ë£Œ ë¡œê¹…
                        await send_telegram_message(
                            f"âœ…ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" +
                            f"ë©”ì¸ í¬ì§€ì…˜ì˜ TP{tp_index} ì²´ê²°ë¡œ ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +
                            f"â€¢ ë°©í–¥: {opposite_side}\n" +
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
                            user_id
                        )
                        
                        # dual_side_position í‚¤ ì‚­ì œ
                        await redis_client.delete(dual_side_key)
                        
                    except Exception as e:
                        logger.error(f"dual_side_position ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}")
                        await send_telegram_message(f"ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨: {str(e)}", user_id, debug=True)

        return result
    except Exception as e:
        error_msg = f"move_sl_to_break_even ì˜¤ë¥˜: {str(e)}"
        await send_telegram_message(error_msg, user_id, debug=True)
        log_error(
            error=e,
            user_id=user_id,
            additional_info={
                "function": "move_sl_to_break_even",
                "timestamp": datetime.now().isoformat()
            }
        )
        return None 

async def process_break_even_settings(user_id: int, symbol: str, order_type: str, position_data: dict):
    """
    TP ì£¼ë¬¸ ì²´ê²° ì‹œ ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¼ ë¸Œë ˆì´í¬ì´ë¸ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    """
    try:
        if not order_type.startswith('tp'):
            return False
            
        # TP ë ˆë²¨ í™•ì¸ (tp1, tp2, tp3)
        tp_level = int(order_type[2]) if len(order_type) > 2 and order_type[2].isdigit() else 1
        
        # ì‚¬ìš©ì ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        settings = await get_user_settings(user_id) 
        dual_side_settings = await get_user_dual_side_settings(user_id)

        
        # ì•ˆì „í•˜ê²Œ ê°’ ì²˜ë¦¬
        use_break_even_tp1 = is_true_value(settings.get('use_break_even', False))
        use_break_even_tp2 = is_true_value(settings.get('use_break_even_tp2', False))
        use_break_even_tp3 = is_true_value(settings.get('use_break_even_tp3', False))
        
        dual_side_tp_type = dual_side_settings.get('dual_side_entry_tp_trigger_type', 'percent')
        dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
        dual_side_tp_value = dual_side_settings.get('dual_side_entry_tp_value', 10)
        dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
        dual_sl_on_tp = dual_side_sl_type == 'existing_position'
        use_dual_side = is_true_value(dual_side_settings.get('use_dual_side', False))
        
        
        # í¬ì§€ì…˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        position_side = position_data.get('position_side', '')
        contracts_amount = float(position_data.get('contracts_amount', '0'))
        dual_side_position_side = None
        if use_dual_side:
            if position_side == 'long':
                dual_side_position_side = 'short'
            else:
                dual_side_position_side = 'long'
                
        position_key = f"user:{user_id}:position:{symbol}:{position_side}"
        full_position_data = await redis_client.hgetall(position_key)
        
        # ì£¼ë¬¸ ê°€ê²© ì •ë³´
        entry_price = float(full_position_data.get("entry_price", 0))
        contracts_amount = float(full_position_data.get("contracts_amount", 0))
        # TP ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        tp_data_str = full_position_data.get("tp_data", "{}")
        try:
            tp_data = json.loads(tp_data_str)
        except json.JSONDecodeError:
            tp_data = []
        # TP ë ˆë²¨ì— ë”°ë¥¸ ë¸Œë ˆì´í¬ì´ë¸ ì ìš©
        
        try:
            if dual_side_tp_type == 'existing_position':
                if int(dual_side_tp_value) == tp_level:
                    close_request = ClosePositionRequest(
                        close_type="market",
                        close_percent=100
                    )
                    await close_position(
                        symbol=symbol,
                        close_request=close_request,
                        user_id=user_id,
                        side=dual_side_position_side
                    )
                    await send_telegram_message(
                        f"âœ…ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +
                        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" +
                        f"ë©”ì¸ í¬ì§€ì…˜ì˜ TP{tp_level} ì²´ê²°ë¡œ ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ\n" +
                        f"â€¢ ë°©í–¥: {dual_side_position_side}\n" +
                        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n",
                        user_id)
        except Exception as e:
            logger.error(f"ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨!: {str(e)}")
            await send_telegram_message(f"ì–‘ë°©í–¥ í¬ì§€ì…˜ ì¢…ë£Œ ì‹¤íŒ¨! {str(e)}", user_id, debug=True)
        
        
        if tp_level == 1 and use_break_even_tp1:
            #await send_telegram_message(f"TP1 ë¸Œë ˆì´í¬ì´ë¸ í™•ì¸. [DEBUG] TP1 ì²´ê²°: SLì„ ë¸Œë ˆì´í¬ì´ë¸({entry_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.", user_id, debug = True)
            # TP1 ì²´ê²° ì‹œ ì§„ì…ê°€(ë¸Œë ˆì´í¬ì´ë¸)ìœ¼ë¡œ SL ì´ë™
            print(f"entry_price: {entry_price}, contracts_amount: {contracts_amount}")
            if entry_price > 0 and contracts_amount > 0:
                logger.info(f"TP1 ì²´ê²°: SLì„ ë¸Œë ˆì´í¬ì´ë¸({entry_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                return await move_sl_to_break_even(
                    user_id=user_id,
                    symbol=symbol,
                    side=position_side,
                    break_even_price=entry_price,
                    contracts_amount=contracts_amount,
                    tp_index=tp_level,
                )
            else:
                await send_telegram_message(f"ì˜¤ë¥˜. {entry_price}, {contracts_amount}\nì•„ë§ˆ í¬ì§€ì…˜ì´ ì´ë¯¸ ì—†ëŠ” ê²½ìš°.", user_id, debug = True)
                
        elif tp_level == 2 and use_break_even_tp2:
            # TP2 ì²´ê²° ì‹œ TP1 ê°€ê²©ìœ¼ë¡œ SL ì´ë™
            if isinstance(tp_data, list):
                tp1_price = next((float(tp.get('price', 0)) for tp in tp_data 
                            if tp.get('level') == 1), None)
                if tp1_price and tp1_price > 0 and contracts_amount > 0:
                    logger.info(f"TP2 ì²´ê²°: SLì„ TP1 ê°€ê²©({tp1_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                    return await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=position_side,
                        break_even_price=tp1_price,
                        contracts_amount=contracts_amount,
                        tp_index=tp_level
                    )
            
        elif tp_level == 3 and use_break_even_tp3:
            # TP3 ì²´ê²° ì‹œ TP2 ê°€ê²©ìœ¼ë¡œ SL ì´ë™
            if isinstance(tp_data, list):
                tp2_price = next((float(tp.get('price', 0)) for tp in tp_data 
                            if tp.get('level') == 2), None)
                if tp2_price and tp2_price > 0 and contracts_amount > 0:
                    logger.info(f"TP3 ì²´ê²°: SLì„ TP2 ê°€ê²©({tp2_price})ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                    return await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=position_side,
                        break_even_price=tp2_price,
                        contracts_amount=contracts_amount,
                        tp_index=tp_level
                    )
                
        # TP ì²´ê²° ì‹œ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì—¬ë¶€ í™•ì¸ (ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¼)
        # ë¬¸ìì—´ê³¼ ë¶ˆë¦¬ì–¸ ëª¨ë‘ ì²˜ë¦¬
        trailing_stop_active = is_true_value(settings.get('trailing_stop_active', False))
        
        # ë¬¸ìì—´ ê°’ ì²˜ë¦¬
        trailing_start_point = str(settings.get('trailing_start_point', 'tp3')).lower()
        current_tp = f"tp{tp_level}"
        
        # ì‚¬ìš©ì ì„¤ì •ì˜ ì‹œì‘ì ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸
        if trailing_stop_active and current_tp.lower() == trailing_start_point:
            logger.info(f"{current_tp.upper()} ì²´ê²°: íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì¡°ê±´ ì¶©ì¡±")
            await activate_trailing_stop(user_id, symbol, position_side, full_position_data, tp_data)
        
        return False
    except Exception as e:
        logger.error(f"ë¸Œë ˆì´í¬ì´ë¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()
        return False

async def activate_trailing_stop(user_id: int, symbol: str, direction: str, position_data: dict, tp_data: list = None):
    """
    TP3 ë„ë‹¬ ì‹œ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™”
    """
    try:
        # ì‚¬ìš©ì ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        settings = await get_user_settings(user_id) 
        use_trailing_stop = is_true_value(settings.get('trailing_stop_active', False))
        logger.info(f"[{user_id}] íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì—¬ë¶€: {use_trailing_stop}")
        if not use_trailing_stop:
            logger.info(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. (user_id: {user_id})")
            return
        
        
            
        # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì˜¤í”„ì…‹ ê°’ ê³„ì‚°
        use_tp2_tp3_diff = is_true_value(settings.get('use_trailing_stop_value_with_tp2_tp3_difference', False))
        trailing_offset = float(settings.get('trailing_stop_offset_value', '0.5'))
        logger.info(f"[{user_id}] íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì˜¤í”„ì…‹ ê°’: {trailing_offset}")
        if use_tp2_tp3_diff and tp_data:
            # TP2ì™€ TP3 ê°€ê²© ì°¨ì´ë¡œ ì˜¤í”„ì…‹ ê³„ì‚°
            if isinstance(tp_data, list):
                tp2_price = next((float(tp.get('price', 0)) for tp in tp_data 
                             if tp.get('level') == 2), None)
                tp3_price = next((float(tp.get('price', 0)) for tp in tp_data 
                             if tp.get('level') == 3), None)
                
                if tp2_price and tp3_price:
                    if direction == "long":
                        trailing_offset = abs(tp3_price - tp2_price)
                    else:  # short
                        trailing_offset = abs(tp2_price - tp3_price)
                    logger.info(f"[{user_id}] TP2-TP3 ê°€ê²© ì°¨ì´ë¥¼ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì˜¤í”„ì…‹ìœ¼ë¡œ ì‚¬ìš©: {trailing_offset}")
        
        # í˜„ì¬ ê°€ê²© ì¡°íšŒ
        async with get_exchange_context(str(user_id)) as exchange:
            try:
                current_price = await get_current_price(symbol, "1m", exchange)
                
                if current_price <= 0:
                    logger.warning(f"í˜„ì¬ê°€ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {symbol}")
                    return
                    
                # ì§„ì…ê°€ ì •ë³´
                entry_price = float(position_data.get("avgPrice", 0))
                contracts_amount = float(position_data.get("contracts_amount", 0))
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì´ˆê¸°ê°’ ì„¤ì •
                if direction == "long":
                    # ë¡± í¬ì§€ì…˜ì—ì„œëŠ” ìµœê³ ê°€ ê¸°ì¤€ìœ¼ë¡œ ì¶”ì 
                    highest_price = current_price
                    trailing_stop_price = highest_price - trailing_offset
                else:  # short
                    # ìˆ í¬ì§€ì…˜ì—ì„œëŠ” ìµœì €ê°€ ê¸°ì¤€ìœ¼ë¡œ ì¶”ì 
                    lowest_price = current_price
                    trailing_stop_price = lowest_price + trailing_offset
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì „ìš© í‚¤ ìƒì„±
                trailing_key = f"trailing:user:{user_id}:{symbol}:{direction}"
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° êµ¬ì„±
                ts_data = {
                    "active": "true",
                    "user_id": str(user_id),
                    "symbol": symbol,
                    "direction": direction,
                    "entry_price": str(entry_price),
                    "contracts_amount": str(contracts_amount),
                    "trailing_offset": str(trailing_offset),
                    "highest_price": str(highest_price) if direction == "long" else "",
                    "lowest_price": str(lowest_price) if direction == "short" else "",
                    "trailing_stop_price": str(trailing_stop_price),
                    "start_time": str(int(datetime.now().timestamp())),
                    "leverage": position_data.get("leverage", "1"),
                    "sl_order_id": position_data.get("sl_order_id", "")
                }
                
                # íŠ¸ë ˆì¼ë§ í‚¤ì— ë°ì´í„° ì €ì¥
                await redis_client.hset(trailing_key, mapping=ts_data)
                
                # íŠ¸ë ˆì¼ë§ í‚¤ ë§Œë£Œ ì‹œê°„ ì„¤ì • (7ì¼ - ì•ˆì „ì¥ì¹˜)
                await redis_client.expire(trailing_key, 60 * 60 * 24 * 7)
                
                # ê¸°ì¡´ í¬ì§€ì…˜ í‚¤ì—ë„ íŠ¸ë ˆì¼ë§ í™œì„±í™” ì •ë³´ ì €ì¥ (í¬ì§€ì…˜ì´ ë‚¨ì•„ìˆëŠ” ê²½ìš°ë§Œ)
                position_key = f"user:{user_id}:position:{symbol}:{direction}"
                position_exists = await redis_client.exists(position_key)
                
                if position_exists:
                    # SL ê°€ê²© ì—…ë°ì´íŠ¸
                    await redis_client.hset(position_key, "sl_price", trailing_stop_price)
                    await redis_client.hset(position_key, "trailing_stop_active", "true")
                    await redis_client.hset(position_key, "trailing_stop_key", trailing_key)
                
                # SL ì£¼ë¬¸ ì—…ë°ì´íŠ¸ ì‹œë„
                try:
                    await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=direction,
                        break_even_price=trailing_stop_price,
                        contracts_amount=contracts_amount,
                        tp_index=0  # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ì€ TP ì¸ë±ìŠ¤ 0ìœ¼ë¡œ í‘œì‹œ
                    )
                except Exception as e:
                    logger.error(f"SL ì£¼ë¬¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")
                
                try:
                    log_order(
                        user_id=user_id,
                        symbol=symbol,
                        action_type='trailing_stop_activation',
                        position_side=direction,
                        price=current_price,
                    trailing_offset=trailing_offset,
                    trailing_stop_price=trailing_stop_price,
                    highest_price=highest_price if direction == "long" else None,
                    lowest_price=lowest_price if direction == "short" else None,
                    entry_price=entry_price,
                    contracts_amount=contracts_amount
                )
                except Exception as e:
                    logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
                
                
                # ì•Œë¦¼ ì „ì†¡
                message = (
                    f"ğŸ”¹ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™”\n"
                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    f"ì‹¬ë³¼: {symbol}\n"
                    f"ë°©í–¥: {'ğŸŸ¢ ë¡±' if direction == 'long' else 'ğŸ”´ ìˆ'}\n"
                    f"í˜„ì¬ê°€: {current_price:.2f}\n"
                    f"íŠ¸ë ˆì¼ë§ ì˜¤í”„ì…‹: {trailing_offset:.2f}\n"
                    f"ì´ˆê¸° ìŠ¤íƒ‘ ê°€ê²©: {trailing_stop_price:.2f}\n"
                )
                await send_telegram_message(message, user_id)
                
                logger.info(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì™„ë£Œ - ì‚¬ìš©ì:{user_id}, ì‹¬ë³¼:{symbol}, ë°©í–¥:{direction}, í‚¤:{trailing_key}")
                
                return trailing_key
            except Exception as e:
                logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì¤‘ ì˜¤ë¥˜: {str(e)}")
                return None
    except Exception as e:
        logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()
        return None

async def check_trailing_stop(user_id: int, symbol: str, direction: str, current_price: float):
    """
    íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì—…ë°ì´íŠ¸ ë° ì²´í¬
    """
    try:
        # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì „ìš© í‚¤ í™•ì¸
        trailing_key = f"trailing:user:{user_id}:{symbol}:{direction}"
        
        # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í‚¤ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        if not await redis_client.exists(trailing_key):
            # í¬ì§€ì…˜ í‚¤ì—ì„œ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™” ì •ë³´ í™•ì¸ (ë ˆê±°ì‹œ ì§€ì›)
            position_key = f"user:{user_id}:position:{symbol}:{direction}"
            
            try:
                # í‚¤ íƒ€ì… í™•ì¸
                key_type = await redis_client.type(position_key)
                
                # í•´ì‹œ íƒ€ì…ì¸ì§€ í™•ì¸ - ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¹„êµ
                if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                    # ì •ìƒì ì¸ í•´ì‹œ íƒ€ì…ì¸ ê²½ìš°
                    position_data = await redis_client.hgetall(position_key)
                else:
                    # ë‹¤ë¥¸ íƒ€ì…ì´ê±°ë‚˜ í‚¤ê°€ ì—†ëŠ” ê²½ìš°
                    logger.warning(f"í¬ì§€ì…˜ ë°ì´í„°ê°€ í•´ì‹œ íƒ€ì…ì´ ì•„ë‹™ë‹ˆë‹¤. (key: {position_key}, íƒ€ì…: {key_type})")
                    position_data = {}
            except Exception as redis_error:
                logger.error(f"Redis í¬ì§€ì…˜ ë°ì´í„° ì¡°íšŒ ì¤‘ ì˜¤ë¥˜: {str(redis_error)}")
                position_data = {}
            
            trailing_stop_active = is_true_value(position_data.get("trailing_stop_active", False))
            
            if not position_data or not trailing_stop_active:
                return False
        
        # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì¡°íšŒ
        try:
            # í‚¤ íƒ€ì… í™•ì¸
            key_type = await redis_client.type(trailing_key)
            
            # í•´ì‹œ íƒ€ì…ì¸ì§€ í™•ì¸ - ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¹„êµ
            if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                # ì •ìƒì ì¸ í•´ì‹œ íƒ€ì…ì¸ ê²½ìš°
                ts_data = await redis_client.hgetall(trailing_key)
            else:
                # ë‹¤ë¥¸ íƒ€ì…ì´ê±°ë‚˜ í‚¤ê°€ ì—†ëŠ” ê²½ìš°
                logger.warning(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„°ê°€ í•´ì‹œ íƒ€ì…ì´ ì•„ë‹™ë‹ˆë‹¤. (key: {trailing_key}, íƒ€ì…: {key_type})")
                return False
        except Exception as redis_error:
            logger.error(f"Redis íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì¡°íšŒ ì¤‘ ì˜¤ë¥˜: {str(redis_error)}")
            return False
        
        if not ts_data or not ts_data.get("active", False):
            # ë¹„í™œì„±í™”ëœ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ì€ ì‚­ì œ
            await redis_client.delete(trailing_key)
            return False
            
        # ê¸°ë³¸ ì •ë³´
        trailing_offset = float(ts_data.get("trailing_offset", 0))
        contracts_amount = float(ts_data.get("contracts_amount", 0))
        
        # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì—…ë°ì´íŠ¸ ì—¬ë¶€
        updated = False
        
        if direction == "long":
            highest_price = float(ts_data.get("highest_price", 0))
            
            # ìƒˆë¡œìš´ ìµœê³ ê°€ ê°±ì‹  ì‹œ
            if current_price > highest_price:
                highest_price = current_price
                trailing_stop_price = highest_price - trailing_offset
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í‚¤ ì—…ë°ì´íŠ¸
                await redis_client.hset(trailing_key, "highest_price", str(highest_price))
                await redis_client.hset(trailing_key, "trailing_stop_price", str(trailing_stop_price))
                await redis_client.hset(trailing_key, "last_updated", str(int(datetime.now().timestamp())))
                
                # í¬ì§€ì…˜ í‚¤ê°€ ì¡´ì¬í•˜ë©´ í•¨ê»˜ ì—…ë°ì´íŠ¸
                position_key = f"user:{user_id}:position:{symbol}:{direction}"
                if await redis_client.exists(position_key):
                    try:
                        # í‚¤ íƒ€ì… í™•ì¸
                        key_type = await redis_client.type(position_key)
                        # í•´ì‹œ íƒ€ì…ì¸ì§€ í™•ì¸ - ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¹„êµ
                        if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                            await redis_client.hset(position_key, "sl_price", str(trailing_stop_price))
                        else:
                            logger.warning(f"í¬ì§€ì…˜ ë°ì´í„°ê°€ í•´ì‹œ íƒ€ì…ì´ ì•„ë‹ˆë¼ SL ê°€ê²© ì—…ë°ì´íŠ¸ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤. (key: {position_key})")
                    except Exception as redis_error:
                        logger.error(f"í¬ì§€ì…˜ SL ê°€ê²© ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜: {str(redis_error)}")
                
                updated = True
                
                # 1ì‹œê°„ì— í•œ ë²ˆ ì •ë„ë§Œ SL ì£¼ë¬¸ ì—…ë°ì´íŠ¸ (ë„ˆë¬´ ì¦ì€ ì—…ë°ì´íŠ¸ ë°©ì§€)
                # ë§ˆì§€ë§‰ SL ì—…ë°ì´íŠ¸ ì‹œê°„ í™•ì¸
                last_sl_update = float(ts_data.get("last_sl_update", "0"))
                current_time = datetime.now().timestamp()
                
                if current_time - last_sl_update > 3600:  # 1ì‹œê°„(3600ì´ˆ) ê°„ê²©
                    # SL ì£¼ë¬¸ API ì—…ë°ì´íŠ¸ 
                    await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=direction,
                        break_even_price=trailing_stop_price,
                        contracts_amount=contracts_amount,
                        tp_index=0
                    )
                    
                    # ë§ˆì§€ë§‰ SL ì—…ë°ì´íŠ¸ ì‹œê°„ ê¸°ë¡
                    await redis_client.hset(trailing_key, "last_sl_update", str(current_time))
                
                logger.info(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì—…ë°ì´íŠ¸ (ë¡±) - ì‚¬ìš©ì:{user_id}, ì‹¬ë³¼:{symbol}, "
                           f"ìƒˆ ìµœê³ ê°€:{highest_price:.2f}, ìƒˆ ìŠ¤íƒ‘:{trailing_stop_price:.2f}")
            
            # í˜„ì¬ê°€ê°€ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê°€ê²© ì•„ë˜ë¡œ ë–¨ì–´ì¡ŒëŠ”ì§€ ì²´í¬ (ì¢…ë£Œ ì¡°ê±´)
            trailing_stop_price = float(ts_data.get("trailing_stop_price", 0))
            if current_price <= trailing_stop_price:
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì•Œë¦¼
                # í¬ì§€ì…˜ ì¢…ë£Œ

                
                await send_telegram_message(
                    f"âš ï¸ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê°€ê²©({trailing_stop_price:.2f}) ë„ë‹¬\n"
                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    f"í˜„ì¬ê°€: {current_price:.2f}\n"
                    f"í¬ì§€ì…˜: {symbol} {direction.upper()}\n",
                    user_id
                )
                
                close_request = ClosePositionRequest('market', current_price, 100)
                
                
                await close_position(symbol = symbol, close_request = close_request, user_id = user_id, side = direction)
                await clear_trailing_stop(user_id, symbol, direction)
                
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í‚¤ì— ì¡°ê±´ ì¶©ì¡± ìƒíƒœ ê¸°ë¡
                await redis_client.hset(trailing_key, "status", "triggered")
                await redis_client.hset(trailing_key, "trigger_price", str(current_price))
                await redis_client.hset(trailing_key, "trigger_time", str(int(datetime.now().timestamp())))
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì‹¤í–‰ ë¡œê¹…
                try:
                    position_key = f"user:{user_id}:position:{symbol}:{direction}"
                    position_data = await redis_client.hgetall(position_key)
                    position_size = float(position_data.get("size", "0")) if position_data else 0
                    
                    log_order(
                        user_id=user_id,
                        symbol=symbol,
                        action_type='trailing_stop_execution',
                        position_side=direction,
                        price=current_price,
                        quantity=position_size,
                        trailing_stop_price=trailing_stop_price,
                        highest_price=float(ts_data.get("highest_price", "0")) if direction == "short" else None,
                        lowest_price=float(ts_data.get("lowest_price", "0")) if direction == "long" else None,
                        trailing_offset=trailing_offset
                    )
                except Exception as e:
                    logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
                
                return True  # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì¡°ê±´ ì¶©ì¡±
        
        else:  # short
            lowest_price = float(ts_data.get("lowest_price", float('inf')))
            
            # ìƒˆë¡œìš´ ìµœì €ê°€ ê°±ì‹  ì‹œ
            if current_price < lowest_price:
                lowest_price = current_price
                trailing_stop_price = lowest_price + trailing_offset
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í‚¤ ì—…ë°ì´íŠ¸
                await redis_client.hset(trailing_key, "lowest_price", str(lowest_price))
                await redis_client.hset(trailing_key, "trailing_stop_price", str(trailing_stop_price))
                await redis_client.hset(trailing_key, "last_updated", str(int(datetime.now().timestamp())))
                
                # í¬ì§€ì…˜ í‚¤ê°€ ì¡´ì¬í•˜ë©´ í•¨ê»˜ ì—…ë°ì´íŠ¸
                position_key = f"user:{user_id}:position:{symbol}:{direction}"
                if await redis_client.exists(position_key):
                    try:
                        # í‚¤ íƒ€ì… í™•ì¸
                        key_type = await redis_client.type(position_key)
                        # í•´ì‹œ íƒ€ì…ì¸ì§€ í™•ì¸ - ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¹„êµ
                        if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                            await redis_client.hset(position_key, "sl_price", str(trailing_stop_price))
                        else:
                            logger.warning(f"í¬ì§€ì…˜ ë°ì´í„°ê°€ í•´ì‹œ íƒ€ì…ì´ ì•„ë‹ˆë¼ SL ê°€ê²© ì—…ë°ì´íŠ¸ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤. (key: {position_key})")
                    except Exception as redis_error:
                        logger.error(f"í¬ì§€ì…˜ SL ê°€ê²© ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜: {str(redis_error)}")
                
                updated = True
                
                # 1ì‹œê°„ì— í•œ ë²ˆ ì •ë„ë§Œ SL ì£¼ë¬¸ ì—…ë°ì´íŠ¸ (ë„ˆë¬´ ì¦ì€ ì—…ë°ì´íŠ¸ ë°©ì§€)
                # ë§ˆì§€ë§‰ SL ì—…ë°ì´íŠ¸ ì‹œê°„ í™•ì¸
                last_sl_update = float(ts_data.get("last_sl_update", "0"))
                current_time = datetime.now().timestamp()
                
                if current_time - last_sl_update > 3600:  # 1ì‹œê°„(3600ì´ˆ) ê°„ê²©
                    # SL ì£¼ë¬¸ API ì—…ë°ì´íŠ¸
                    await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=direction,
                        break_even_price=trailing_stop_price,
                        contracts_amount=contracts_amount,
                        tp_index=0
                    )
                    
                    # ë§ˆì§€ë§‰ SL ì—…ë°ì´íŠ¸ ì‹œê°„ ê¸°ë¡
                    await redis_client.hset(trailing_key, "last_sl_update", str(current_time))
                
                logger.info(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì—…ë°ì´íŠ¸ (ìˆ) - ì‚¬ìš©ì:{user_id}, ì‹¬ë³¼:{symbol}, "
                           f"ìƒˆ ìµœì €ê°€:{lowest_price:.2f}, ìƒˆ ìŠ¤íƒ‘:{trailing_stop_price:.2f}")
            
            # í˜„ì¬ê°€ê°€ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê°€ê²© ìœ„ë¡œ ì˜¬ë¼ê°”ëŠ”ì§€ ì²´í¬ (ì¢…ë£Œ ì¡°ê±´)
            trailing_stop_price = float(ts_data.get("trailing_stop_price", float('inf')))
            if current_price >= trailing_stop_price:
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì•Œë¦¼
                await send_telegram_message(
                    f"âš ï¸ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê°€ê²©({trailing_stop_price:.2f}) ë„ë‹¬\n"
                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    f"í˜„ì¬ê°€: {current_price:.2f}\n"
                    f"í¬ì§€ì…˜: {symbol} {direction.upper()}\n"
                    f"íŠ¸ë ˆì¼ë§ ì˜¤í”„ì…‹: {trailing_offset:.2f}",
                    user_id
                )
                
                close_request = ClosePositionRequest('market', current_price, 100)
                
                await close_position(symbol = symbol, close_request = close_request, user_id = user_id, side = direction)
                await clear_trailing_stop(user_id, symbol, direction)
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í‚¤ì— ì¡°ê±´ ì¶©ì¡± ìƒíƒœ ê¸°ë¡
                await redis_client.hset(trailing_key, "status", "triggered")
                await redis_client.hset(trailing_key, "trigger_price", str(current_price))
                await redis_client.hset(trailing_key, "trigger_time", str(int(datetime.now().timestamp())))
                
                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì‹¤í–‰ ë¡œê¹…
                try:
                    position_key = f"user:{user_id}:position:{symbol}:{direction}"
                    position_data = await redis_client.hgetall(position_key)
                    position_size = float(position_data.get("size", "0")) if position_data else 0
                    
                    log_order(
                        user_id=user_id,
                        symbol=symbol,
                        action_type='trailing_stop_execution',
                        position_side=direction,
                        price=current_price,
                        quantity=position_size,
                        trailing_stop_price=trailing_stop_price,
                        highest_price=float(ts_data.get("highest_price", "0")) if direction == "short" else None,
                        lowest_price=float(ts_data.get("lowest_price", "0")) if direction == "long" else None,
                        trailing_offset=trailing_offset
                    )
                except Exception as e:
                    logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
                
                return True  # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì¡°ê±´ ì¶©ì¡±
        
        return False  # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì¡°ê±´ ë¯¸ì¶©ì¡±
        
    except Exception as e:
        logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì²´í¬ ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()
        return False

async def clear_trailing_stop(user_id: int, symbol: str, direction: str):

    try:
        # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í‚¤ ì‚­ì œ
        trailing_key = f"trailing:user:{user_id}:{symbol}:{direction}"
        await redis_client.delete(trailing_key)
        
        # í¬ì§€ì…˜ í‚¤ê°€ ìˆìœ¼ë©´ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê´€ë ¨ í•„ë“œë„ ë¦¬ì…‹
        position_key = f"user:{user_id}:position:{symbol}:{direction}"
        if await redis_client.exists(position_key):
            await redis_client.hset(position_key, "trailing_stop_active", "false")
            await redis_client.hdel(position_key, "trailing_stop_key")
            
        logger.info(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì‚­ì œ ì™„ë£Œ: {trailing_key}")
        return True
    except Exception as e:
        logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì‚­ì œ ì˜¤ë¥˜: {str(e)}")
        return False

async def get_active_trailing_stops() -> List[Dict]:

    try:
        trailing_keys = await redis_client.keys("trailing:user:*")
        trailing_stops = []
        for key in trailing_keys:
            data = await redis_client.hgetall(key)
            if data and data.get("active", "false").lower() == "true":
                # key êµ¬ì¡°: trailing:user:{user_id}:{symbol}:{direction}
                parts = key.split(":")
                if len(parts) >= 5:
                    data["user_id"] = parts[2]
                    data["symbol"] = parts[3]
                    data["direction"] = parts[4]
                    trailing_stops.append(data)
        
        return trailing_stops
    except Exception as e:
        logger.error(f"í™œì„± íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
        return []

async def check_position_exists(user_id: int, symbol: str, direction: str) -> bool:
    """
    íŠ¹ì • ë°©í–¥ì˜ í¬ì§€ì…˜ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    
    Args:
        user_id: ì‚¬ìš©ì ID
        symbol: ì‹¬ë³¼
        direction: í¬ì§€ì…˜ ë°©í–¥ ('long' ë˜ëŠ” 'short')
        
    Returns:
        bool: í¬ì§€ì…˜ì´ ì¡´ì¬í•˜ë©´ True, ì•„ë‹ˆë©´ False
    """
    try:
        from src.trading.trading_service import TradingService
        trading_service = TradingService()
        
        # í¬ì§€ì…˜ ì¡°íšŒ
        positions = await trading_service.fetch_okx_position(str(user_id), symbol)
        
        # í¬ì§€ì…˜ ë°ì´í„° í™•ì¸
        if not positions:
            logger.info(f"ì‚¬ìš©ì {user_id}ì˜ {symbol} í¬ì§€ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.")
            return False
            
        # íŠ¹ì • ë°©í–¥ì˜ í¬ì§€ì…˜ì´ ìˆëŠ”ì§€ í™•ì¸
        for pos in positions.values() if isinstance(positions, dict) else [positions]:
            pos_side = pos.get('pos_side', '').lower()
            if pos_side == '':
                pos_side = pos.get('side', '').lower()
                
            if pos_side == direction:
                contracts = float(pos.get('contracts_amount', pos.get('size', '0')))
                if contracts > 0:
                    logger.info(f"ì‚¬ìš©ì {user_id}ì˜ {symbol} {direction} í¬ì§€ì…˜ ìˆìŒ: {contracts} ê³„ì•½")
                    return True
                    
        # í•´ë‹¹ ë°©í–¥ì˜ í¬ì§€ì…˜ì´ ì—†ìŒ
        logger.info(f"ì‚¬ìš©ì {user_id}ì˜ {symbol} {direction} í¬ì§€ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.")
        return False
    except Exception as e:
        logger.error(f"í¬ì§€ì…˜ í™•ì¸ ì¤‘ ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()
        # ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ í¬ì§€ì…˜ ìˆìŒ ë°˜í™˜ (ì•ˆì „í•˜ê²Œ)
        return True

async def check_and_cleanup_orders(user_id: int, symbol: str, direction: str):
    """
    í¬ì§€ì…˜ì´ ì—†ì„ ë•Œ í•´ë‹¹ ë°©í–¥ì˜ ëª¨ë“  ì£¼ë¬¸ì„ í™•ì¸í•˜ê³  ëª¨ë‹ˆí„°ë§ ë°ì´í„°ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤.
    
    Args:
        user_id: ì‚¬ìš©ì ID
        symbol: ì‹¬ë³¼
        direction: í¬ì§€ì…˜ ë°©í–¥ ('long' ë˜ëŠ” 'short')
    """
    try:
        # í¬ì§€ì…˜ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        position_exists = await check_position_exists(user_id, symbol, direction)
        
        if position_exists:
            # í¬ì§€ì…˜ì´ ìˆìœ¼ë©´ ì•„ë¬´ ì‘ì—…ë„ í•˜ì§€ ì•ŠìŒ
            return
            
        # í¬ì§€ì…˜ì´ ì—†ìœ¼ë©´ í•´ë‹¹ ë°©í–¥ì˜ ëª¨ë“  ì£¼ë¬¸ í™•ì¸
        logger.info(f"ì‚¬ìš©ì {user_id}ì˜ {symbol} {direction} í¬ì§€ì…˜ì´ ì—†ì–´ ëª¨ë‹ˆí„°ë§ ë°ì´í„° ì •ë¦¬ ì‹œì‘")
        position_key = f"user:{user_id}:position:{symbol}:{direction}"

        # 1. í•´ë‹¹ ë°©í–¥ì˜ ëª¨ë‹ˆí„°ë§ ì¤‘ì¸ ëª¨ë“  ì£¼ë¬¸ ê°€ì ¸ì˜¤ê¸°
        pattern = f"monitor:user:{user_id}:{symbol}:order:*"
        order_keys = await redis_client.keys(pattern)
        orders_to_check = []
        
        for key in order_keys:
            order_data = await redis_client.hgetall(key)
            if not order_data:
                continue
                
            # í•´ë‹¹ ë°©í–¥ì˜ ì£¼ë¬¸ë§Œ í•„í„°ë§
            if order_data.get("position_side", "").lower() == direction.lower():
                # keyì—ì„œ order_id ì¶”ì¶œ - monitor:user:{user_id}:{symbol}:order:{order_id}
                parts = key.split(":")
                if len(parts) >= 6:
                    order_id = parts[5]
                    order_data["order_id"] = order_id
                    order_data["symbol"] = symbol
                    orders_to_check.append(order_data)
        
        # ì£¼ë¬¸ì´ ì—†ìœ¼ë©´ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ë§Œ ì •ë¦¬
        if not orders_to_check:
            logger.info(f"ì‚¬ìš©ì {user_id}ì˜ {symbol} {direction} ë°©í–¥ì˜ ëª¨ë‹ˆí„°ë§ ì£¼ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.")
            # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì •ë¦¬
            await clear_trailing_stop(user_id, symbol, direction)
            return
            
        # 2. ê° ì£¼ë¬¸ì˜ ìƒíƒœ í™•ì¸
        logger.info(f"ì‚¬ìš©ì {user_id}ì˜ {symbol} {direction} ë°©í–¥ì˜ {len(orders_to_check)}ê°œ ì£¼ë¬¸ ìƒíƒœ í™•ì¸")
        
        for order_data in orders_to_check:
            order_id = order_data.get("order_id")
            order_type = order_data.get("order_type", "")
            
            # ì£¼ë¬¸ì´ ì´ë¯¸ ì™„ë£Œ ìƒíƒœë©´ ê±´ë„ˆëœ€
            if order_data.get("status", "") != "open":
                continue
                
            # ì£¼ë¬¸ ìƒíƒœ í™•ì¸
            order_status = await check_order_status(
                user_id=user_id,
                symbol=symbol,
                order_id=order_id,
                order_type=order_type
            )
            
            # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
            if isinstance(order_status, dict):
                status = "canceled"  # ê¸°ë³¸ê°’ì€ ì·¨ì†Œë¨
                filled_sz = "0"
                
                # OrderResponse í˜•ì‹ (get_order_detail ê²°ê³¼)
                if 'status' in order_status:
                    if order_status['status'] in ['FILLED', 'CLOSED', 'filled', 'closed']:
                        status = 'filled'
                        filled_sz = order_status.get('filled_amount', order_status.get('amount', '0'))
                    elif order_status['status'] in ['CANCELED', 'canceled']:
                        status = 'canceled'
                        filled_sz = order_status.get('filled_amount', '0')
                    else:
                        status = 'canceled'  # í¬ì§€ì…˜ì´ ì—†ìœ¼ë¯€ë¡œ ë‚¨ì€ ì£¼ë¬¸ì€ ì·¨ì†Œë¡œ ì²˜ë¦¬
                        filled_sz = order_status.get('filled_amount', '0')
                # OKX API ì‘ë‹µ (ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸)
                elif 'state' in order_status:
                    state = order_status.get('state')
                    filled_sz = order_status.get('accFillSz', '0')
                    
                    # ìƒíƒœ ë§¤í•‘
                    status_mapping = {
                        'filled': 'filled',
                        'effective': 'canceled',  # í¬ì§€ì…˜ì´ ì—†ìœ¼ë¯€ë¡œ í™œì„± ì£¼ë¬¸ë„ ì·¨ì†Œë¡œ ì²˜ë¦¬
                        'canceled': 'canceled',
                        'order_failed': 'failed'
                    }
                    status = status_mapping.get(state, 'canceled')
                
                # TP ì£¼ë¬¸ì´ ì²´ê²°ëœ ê²½ìš° ë¸Œë ˆì´í¬ì´ë¸/íŠ¸ë ˆì¼ë§ìŠ¤íƒ‘ ì²˜ë¦¬
                if status == 'filled' and order_type.startswith('tp'):
                    logger.info(f"[{user_id}] TP ì£¼ë¬¸ ì²´ê²°ë¨: {order_id}({order_type})")
                    try:
                       
                        # ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¥¸ ë¸Œë ˆì´í¬ì´ë¸/íŠ¸ë ˆì¼ë§ìŠ¤íƒ‘ ì²˜ë¦¬
                        await process_break_even_settings(
                            user_id=user_id,
                            symbol=symbol,
                            order_type=order_type,
                            position_data=order_data
                        )
                    except Exception as be_error:
                        logger.error(f"ë¸Œë ˆì´í¬ì´ë¸/íŠ¸ë ˆì¼ë§ìŠ¤íƒ‘ ì²˜ë¦¬ ì‹¤íŒ¨: {str(be_error)}")
                
                # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                await update_order_status(
                    user_id=user_id,
                    symbol=symbol,
                    order_id=order_id,
                    status=status,
                    filled_amount=str(filled_sz)
                )
                
                
                
                # SL ì£¼ë¬¸ì´ ì²´ê²°ëœ ê²½ìš°, ê´€ë ¨ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì •ë¦¬
                if status == 'filled' and order_type == 'sl':
                    logger.info(f"[{user_id}] SL ì£¼ë¬¸ ì²´ê²°ë¨: {order_id}({order_type})")
                    await clear_trailing_stop(user_id, symbol, direction)
                    
                    # SL ì£¼ë¬¸ ì²´ê²° ë¡œê¹…
                    price = float(order_data.get("price", "0"))
                    filled_amount = float(filled_sz) if filled_sz else 0
                    
                    # SL ì£¼ë¬¸ ì²´ê²° ë¡œê¹…
                    try:
                        log_order(
                            user_id=user_id,
                            symbol=symbol,
                            action_type='sl_execution',
                            position_side=direction,
                            price=price,
                        quantity=filled_amount,
                            order_id=order_id,
                            current_price=price
                        )
                    except Exception as e:
                        logger.error(f"SL ì£¼ë¬¸ ì²´ê²° ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
                
                # ì²´ê²°ëìœ¼ë©´ ì•Œë¦¼ ë°œì†¡
                if status == 'filled':
                    logger.info(f"í¬ì§€ì…˜ì´ ì—†ì§€ë§Œ ì£¼ë¬¸ {order_id}({order_type})ì´ ì²´ê²°ë¨ì„ ë°œê²¬")
            else:
                # ìƒíƒœë¥¼ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš° ì·¨ì†Œë¡œ ì²˜ë¦¬
                status = 'canceled'
                filled_sz = '0'
                
                # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                await update_order_status(
                    user_id=user_id,
                    symbol=symbol,
                    order_id=order_id,
                    status=status,
                    filled_amount=str(filled_sz)
                )
        
        # 3. íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì •ë¦¬
        await clear_trailing_stop(user_id, symbol, direction)
        
        # 4. í¬ì§€ì…˜ ë°ì´í„° ì •ë¦¬
        position_key = f"user:{user_id}:position:{symbol}:{direction}"
        if await redis_client.exists(position_key):
            logger.info(f"í¬ì§€ì…˜ì´ ì—†ì–´ Redisì—ì„œ í¬ì§€ì…˜ ë°ì´í„° ì‚­ì œ: {position_key}")
            await redis_client.delete(position_key)
            
        logger.info(f"ì‚¬ìš©ì {user_id}ì˜ {symbol} {direction} ëª¨ë‹ˆí„°ë§ ë°ì´í„° ì •ë¦¬ ì™„ë£Œ")
    except Exception as e:
        logger.error(f"ì£¼ë¬¸ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()

async def should_check_tp_order(order_data: Dict, current_price: float) -> bool:
    """
    TP ì£¼ë¬¸ì„ í™•ì¸í•´ì•¼ í•˜ëŠ”ì§€ ê²°ì •í•©ë‹ˆë‹¤.
    
    Args:
        order_data: ì£¼ë¬¸ ë°ì´í„°
        current_price: í˜„ì¬ ê°€ê²©
        
    Returns:
        bool: ì£¼ë¬¸ì„ í™•ì¸í•´ì•¼ í•˜ëŠ” ê²½ìš° True
    """
    order_type = order_data.get("order_type", "")
    position_side = order_data.get("position_side", "")
    tp_price = float(order_data.get("price", "0"))
    
    if not order_type.startswith("tp") or tp_price <= 0:
        return False
        
    # Long í¬ì§€ì…˜: í˜„ì¬ê°€ê°€ TPë³´ë‹¤ ë†’ìœ¼ë©´ í™•ì¸
    if position_side == "long" and current_price >= tp_price:
        return True
    # Short í¬ì§€ì…˜: í˜„ì¬ê°€ê°€ TPë³´ë‹¤ ë‚®ìœ¼ë©´ í™•ì¸
    elif position_side == "short" and current_price <= tp_price:
        return True
        
    return False

async def should_check_sl_order(order_data: Dict, current_price: float) -> bool:
    """
    SL ì£¼ë¬¸ì„ í™•ì¸í•´ì•¼ í•˜ëŠ”ì§€ ê²°ì •í•©ë‹ˆë‹¤.
    
    Args:
        order_data: ì£¼ë¬¸ ë°ì´í„°
        current_price: í˜„ì¬ ê°€ê²©
        
    Returns:
        bool: ì£¼ë¬¸ì„ í™•ì¸í•´ì•¼ í•˜ëŠ” ê²½ìš° True
    """
    order_type = order_data.get("order_type", "")
    position_side = order_data.get("position_side", "")
    sl_price = float(order_data.get("price", "0"))
    
    if order_type != "sl" or sl_price <= 0:
        return False
        
    # Long í¬ì§€ì…˜: í˜„ì¬ê°€ê°€ SLë³´ë‹¤ ë‚®ìœ¼ë©´ í™•ì¸
    if position_side == "long" and current_price <= sl_price:
        
        symbol = order_data.get("symbol", "")
        user_id = order_data.get("user_id", "")
        direction = order_data.get("position_side", "")
        
        
        close_request = ClosePositionRequest(
            close_type="market",
            price=current_price,
            close_percent=100
        )

        await close_position(
            symbol=symbol,
            close_request=close_request,
            user_id=user_id,
            side=direction
        )
        
        return True
    # Short í¬ì§€ì…˜: í˜„ì¬ê°€ê°€ SLë³´ë‹¤ ë†’ìœ¼ë©´ í™•ì¸
    elif position_side == "short" and current_price >= sl_price:
        symbol = order_data.get("symbol", "")
        user_id = order_data.get("user_id", "")
        direction = order_data.get("position_side", "")
        
        
        close_request = ClosePositionRequest(
            close_type="market",
            price=current_price,
            close_percent=100
        )

        await close_position(
            symbol=symbol,
            close_request=close_request,
            user_id=user_id,
            side=direction
        )
        return True
        
    return False

async def monitor_orders_loop():
    """
    ì£¼ë¬¸ì„ ì§€ì†ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ë¬´í•œ ë£¨í”„ í•¨ìˆ˜
    """
    logger.info("ì£¼ë¬¸ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì‹œì‘")
    last_order_check_time = 0  # ë§ˆì§€ë§‰ ì£¼ë¬¸ ìƒíƒœ ì „ì²´ í™•ì¸ ì‹œê°„
    last_position_check_time = 0  # ë§ˆì§€ë§‰ í¬ì§€ì…˜ í™•ì¸ ì‹œê°„
    last_memory_cleanup_time = 0  # ë§ˆì§€ë§‰ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œê°„
    last_memory_check_time = 0    # ë§ˆì§€ë§‰ ë©”ëª¨ë¦¬ ì²´í¬ ì‹œê°„
    last_algo_cancel_time = 0     # ë§ˆì§€ë§‰ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ì‹œê°„
    POSITION_CHECK_INTERVAL = 60  # í¬ì§€ì…˜ í™•ì¸ ê°„ê²©(ì´ˆ)
    MEMORY_CHECK_INTERVAL = 60    # ë©”ëª¨ë¦¬ ì²´í¬ ê°„ê²©(ì´ˆ)
    ALGO_ORDER_CANCEL_INTERVAL = 300  # ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ê°„ê²©(ì´ˆ, 5ë¶„)
    consecutive_errors = 0  # ì—°ì† ì˜¤ë¥˜ ì¹´ìš´í„°
    
    # API ì†ë„ ì œí•œ ê´€ë¦¬
    api_call_timestamps = []
    
    while True:
        try:
            current_time = time.time()
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (1ë¶„ë§ˆë‹¤)
            if current_time - last_memory_check_time >= MEMORY_CHECK_INTERVAL:
                last_memory_check_time = current_time
                process = psutil.Process()
                memory_info = process.memory_info()
                memory_usage_mb = memory_info.rss / 1024 / 1024
                logger.info(f"í˜„ì¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {memory_usage_mb:.2f} MB")
                
                # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì„ê³„ì¹˜ë¥¼ ì´ˆê³¼í•˜ë©´ ê°•ì œ ì •ë¦¬
                if memory_usage_mb > MAX_MEMORY_MB:
                    logger.warning(f"ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰({memory_usage_mb:.2f} MB)ì´ ì œí•œ({MAX_MEMORY_MB} MB)ì„ ì´ˆê³¼í•˜ì—¬ ê°•ì œ ì •ë¦¬ ìˆ˜í–‰")
                    # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
                    gc.collect()
                    # Redis ì—°ê²° ì´ˆê¸°í™”
                    await redis_client.connection_pool.disconnect()
                    # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë‹¤ì‹œ ê³„ì‚°
                    memory_info = process.memory_info()
                    logger.info(f"ë©”ëª¨ë¦¬ ì •ë¦¬ í›„ ì‚¬ìš©ëŸ‰: {memory_info.rss / 1024 / 1024:.2f} MB")
            
            # í™œì„± ì‚¬ìš©ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            running_users = await get_all_running_users()
            last_active_users_num_logging = await redis_client.get(f"last_active_users_num_logging")
            if len(running_users) > 0 and last_active_users_num_logging is None:
                logger.info(f"[í™œì„± ì‚¬ìš©ì ìˆ˜: {len(running_users)}]")
                await redis_client.set(f"last_active_users_num_logging", current_time)
            elif len(running_users) > 0 and last_active_users_num_logging is not None and abs(current_time - float(last_active_users_num_logging)) >= 60:
                logger.info(f"[í™œì„± ì‚¬ìš©ì ìˆ˜: {len(running_users)}]")
                await redis_client.set(f"last_active_users_num_logging", current_time)
            
            # ì£¼ë¬¸ ê°•ì œ í™•ì¸ ì—¬ë¶€ (15ì´ˆë§ˆë‹¤)
            force_check_orders = current_time - last_order_check_time >= ORDER_CHECK_INTERVAL
            if force_check_orders:
                #logger.info(f"ì •ê¸° ì£¼ë¬¸ ìƒíƒœ í™•ì¸ ì‹œì‘ (ê°„ê²©: {ORDER_CHECK_INTERVAL}ì´ˆ)")
                last_order_check_time = current_time
            
            # í¬ì§€ì…˜ í™•ì¸ ì—¬ë¶€ (60ì´ˆë§ˆë‹¤)
            force_check_positions = current_time - last_position_check_time >= POSITION_CHECK_INTERVAL
            if force_check_positions:
                #logger.info(f"ì •ê¸° í¬ì§€ì…˜ í™•ì¸ ì‹œì‘ (ê°„ê²©: {POSITION_CHECK_INTERVAL}ì´ˆ)")
                last_position_check_time = current_time
            
            # ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ì—¬ë¶€ (5ë¶„ë§ˆë‹¤)
            force_cancel_algo_orders = current_time - last_algo_cancel_time >= ALGO_ORDER_CANCEL_INTERVAL
            if force_cancel_algo_orders:
                logger.info(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ í™•ì¸ ì‹œì‘ (ê°„ê²©: {ALGO_ORDER_CANCEL_INTERVAL}ì´ˆ)")
                last_algo_cancel_time = current_time
                
                # 5ë¶„ë§ˆë‹¤ ëª¨ë“  ì‚¬ìš©ìì— ëŒ€í•´ í¬ì§€ì…˜ ì—†ëŠ” ë°©í–¥ì˜ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ
                for user_id in running_users:
                    # ê° ì‚¬ìš©ìì— ëŒ€í•´ í¬ì§€ì…˜ì´ ì—†ëŠ” ë°©í–¥ì˜ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ í•¨ìˆ˜ í˜¸ì¶œ
                    asyncio.create_task(cancel_algo_orders_for_no_position_sides(user_id))
            
            # ë¨¼ì € ëª¨ë“  í™œì„± íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì²´í¬ (ë…ë¦½ì ì¸ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘)
            active_trailings = await get_active_trailing_stops()
            if len(active_trailings) > 0:
                logger.info(f"í™œì„± íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ìˆ˜: {len(active_trailings)}")
                for ts_data in active_trailings:
                    try:
                        user_id = int(ts_data.get("user_id", "0"))
                        symbol = ts_data.get("symbol", "")
                        direction = ts_data.get("direction", "")
                        
                        if not (user_id and symbol and direction) or user_id not in running_users:
                            continue
                        
                        # í˜„ì¬ê°€ ì¡°íšŒ
                        async with get_exchange_context(str(user_id)) as exchange:
                            try:
                                current_price = await get_current_price(symbol, "1m", exchange)
                                
                                if current_price <= 0:
                                    logger.warning(f"[íŠ¸ë ˆì¼ë§] ìœ íš¨í•˜ì§€ ì•Šì€ í˜„ì¬ê°€: {current_price}, ì‹¬ë³¼: {symbol}")
                                    continue
                                
                                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì¡°ê±´ ì²´í¬
                                ts_hit = await check_trailing_stop(user_id, symbol, direction, current_price)
                                
                                # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì¡°ê±´ ì¶©ì¡± ì‹œ
                                if ts_hit:
                                    # SL ì£¼ë¬¸ ID í™•ì¸
                                    
                                    
                                    close_request = ClosePositionRequest(
                                        close_type="market",
                                        price=current_price,
                                        close_percent=100
                                    )
                                    
                                    await close_position(
                                        symbol=symbol,
                                        close_request=close_request,
                                        user_id=user_id,
                                        side=direction
                                    )
                                    
                                    sl_order_id = ts_data.get("sl_order_id", "")
                                    
                                    
                                    
                                    if sl_order_id:
                                        # SL ì£¼ë¬¸ ìƒíƒœ í™•ì¸
                                        logger.info(f"[íŠ¸ë ˆì¼ë§] SL ì£¼ë¬¸ ìƒíƒœ í™•ì¸: {sl_order_id}")
                                        sl_status = await check_order_status(
                                            user_id=user_id,
                                            symbol=symbol,
                                            order_id=sl_order_id,
                                            order_type="sl"
                                        )
                                        
                                        # SL ì£¼ë¬¸ì´ ì²´ê²°ë˜ì—ˆëŠ”ì§€ í™•ì¸
                                        if isinstance(sl_status, dict) and sl_status.get('status') in ['FILLED', 'CLOSED', 'filled', 'closed']:
                                            logger.info(f"[íŠ¸ë ˆì¼ë§] SL ì£¼ë¬¸ ì²´ê²°ë¨: {sl_order_id}")
                                            # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì‚­ì œ
                                            await clear_trailing_stop(user_id, symbol, direction)
                                        elif isinstance(sl_status, dict) and sl_status.get('status') in ['CANCELED', 'canceled']:
                                            # SL ì£¼ë¬¸ì´ ì·¨ì†Œëœ ê²½ìš° íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì‚­ì œ
                                            logger.info(f"[íŠ¸ë ˆì¼ë§] SL ì£¼ë¬¸ ì·¨ì†Œë¨: {sl_order_id}")
                                            await clear_trailing_stop(user_id, symbol, direction)
                                    else:
                                        # SL ì£¼ë¬¸ IDê°€ ì—†ëŠ” ê²½ìš° (í¬ì§€ì…˜ ìì²´ í™•ì¸)
                                        position_exists = await check_position_exists(user_id, symbol, direction)
                                        
                                        if not position_exists:
                                            # í¬ì§€ì…˜ì´ ì—†ìœ¼ë©´ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì‚­ì œ
                                            logger.info(f"[íŠ¸ë ˆì¼ë§] í¬ì§€ì…˜ ì—†ìŒ, íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì‚­ì œ: {user_id}:{symbol}:{direction}")
                                            await clear_trailing_stop(user_id, symbol, direction)
                            except Exception as e:
                                logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í˜„ì¬ê°€ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
                    except Exception as ts_error:
                        logger.error(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(ts_error)}")
                        traceback.print_exc()
            
            
            
                
            # ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰ (10ë¶„ë§ˆë‹¤)
            force_memory_cleanup = current_time - last_memory_cleanup_time >= MEMORY_CLEANUP_INTERVAL
            if force_memory_cleanup:
                logger.info(f"ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œì‘ (ê°„ê²©: {MEMORY_CLEANUP_INTERVAL}ì´ˆ)")
                last_memory_cleanup_time = current_time
                # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¡œê¹…
                process = psutil.Process()
                memory_info = process.memory_info()
                logger.info(f"í˜„ì¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {memory_info.rss / 1024 / 1024:.2f} MB")
                # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
                gc.collect()
                # Redis ì—°ê²° í’€ ì •ë¦¬
                await redis_client.connection_pool.disconnect()
                
                # ì£¼ë¬¸ ìƒíƒœ ìºì‹œ ì •ë¦¬
                current_time_cleanup = time.time()
                expired_keys = [k for k, (t, _) in order_status_cache.items() if current_time_cleanup - t > ORDER_STATUS_CACHE_TTL]
                for key in expired_keys:
                    del order_status_cache[key]
                logger.info(f"ì£¼ë¬¸ ìƒíƒœ ìºì‹œ ì •ë¦¬ ì™„ë£Œ: {len(expired_keys)}ê°œ í•­ëª© ì œê±°, í˜„ì¬ {len(order_status_cache)}ê°œ í•­ëª© ìœ ì§€")
                
                # ì¶”ê°€ ë©”ëª¨ë¦¬ ì •ë¦¬: ë§Œë£Œëœ ê±°ë˜ ë°ì´í„° ì •ë¦¬
                try:
                    # 2ì£¼ ì´ìƒ ì§€ë‚œ ì™„ë£Œëœ ì£¼ë¬¸ ë°ì´í„° ì‚­ì œ
                    two_weeks_ago = int((datetime.now() - timedelta(days=14)).timestamp())
                    pattern = "completed:user:*:order:*"
                    old_order_keys = await redis_client.keys(pattern)
                    
                    for key in old_order_keys:
                        try:
                            order_data = await redis_client.hgetall(key)
                            last_updated = int(order_data.get("last_updated_time", "0"))
                            if last_updated < two_weeks_ago:
                                logger.info(f"ì˜¤ë˜ëœ ì™„ë£Œ ì£¼ë¬¸ ë°ì´í„° ì‚­ì œ: {key}")
                                await redis_client.delete(key)
                        except Exception as e:
                            logger.error(f"ì™„ë£Œ ì£¼ë¬¸ ë°ì´í„° ì‚­ì œ ì¤‘ ì˜¤ë¥˜: {str(e)}")
                            continue
                except Exception as e:
                    logger.error(f"ë§Œë£Œëœ ë°ì´í„° ì •ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
                
            # API í˜¸ì¶œ ì†ë„ ì œí•œ ê´€ë¦¬
            current_time_ms = time.time()
            # 1ì´ˆ ì´ë‚´ì˜ API í˜¸ì¶œë§Œ ìœ ì§€
            api_call_timestamps = [t for t in api_call_timestamps if current_time_ms - t < 1.0]
            
            
            # ê° ì‚¬ìš©ìì˜ ì£¼ë¬¸ í™•ì¸
            for user_id in running_users:
                try:
                    # ì‚¬ìš©ìì˜ ëª¨ë“  ëª¨ë‹ˆí„°ë§ ì£¼ë¬¸ ê°€ì ¸ì˜¤ê¸°
                    user_orders = await get_user_monitor_orders(user_id)
                    if not user_orders:
                        continue
                        
                    logger.info(f"ì‚¬ìš©ì {user_id}ì˜ ëª¨ë‹ˆí„°ë§ ì£¼ë¬¸ ìˆ˜: {len(user_orders)}")
                    
                    # ì‹¬ë³¼ë³„ ì£¼ë¬¸ ê·¸ë£¹í™” (í•œ ë²ˆë§Œ í˜„ì¬ê°€ë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•¨)
                    symbol_orders = {}
                    
                    for order_id, order_data in user_orders.items():
                        symbol = order_data.get("symbol")
                        if symbol not in symbol_orders:
                            symbol_orders[symbol] = []
                        symbol_orders[symbol].append(order_data)
                    
                    # ê° ì‹¬ë³¼ì— ëŒ€í•´ í˜„ì¬ê°€ ì¡°íšŒ ë° ì£¼ë¬¸ ìƒíƒœ í™•ì¸

                    for symbol, orders in symbol_orders.items():
                        position_sides = set(order_data.get("position_side", "") for order_data in orders)
                        try:
                            # í˜„ì¬ê°€ ì¡°íšŒ
                            async with get_exchange_context(str(user_id)) as exchange:
                                current_price = await get_current_price(symbol, "1m", exchange)
                                
                                if current_price <= 0:
                                    logger.warning(f"ìœ íš¨í•˜ì§€ ì•Šì€ í˜„ì¬ê°€: {current_price}, ì‹¬ë³¼: {symbol}")
                                    continue
                                    
                                logger.info(f"ì‹¬ë³¼ {symbol}ì˜ í˜„ì¬ê°€: {current_price}")
                                
                                # ì •ê¸° í¬ì§€ì…˜ í™•ì¸ ì‹œê°„ì— í¬ì§€ì…˜ í™•ì¸ ë° ì •ë¦¬
                                if force_check_positions:
                                    # ê° ë°©í–¥(long, short)ì— ëŒ€í•´ í¬ì§€ì…˜ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ ë° ì •ë¦¬
                                    position_sides = set(order_data.get("position_side", "") for order_data in orders)
                                    for direction in position_sides:
                                        position_key = f"user:{user_id}:position:{symbol}:{direction}"
                                        #print("===============")
                                        #print(f"direction: {direction}")
                                        #print("===============")
                                        if direction not in ["long", "short"]:
                                            await send_telegram_message(f"ì´ìƒí•œ ê²ƒ ë°œê²¬. {direction}", user_id, debug=True)
                                            continue 
                                        # í¬ì§€ì…˜ í™•ì¸ ë° ì •ë¦¬
                                        await check_and_cleanup_orders(user_id, symbol, direction)
                                    await check_position_exists(user_id, symbol, direction)
                                
                                # ì‹¬ë³¼ë³„ë¡œ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™”ëœ ë°©í–¥ í™•ì¸
                                trailing_sides = set()
                                for direction in ["long", "short"]:
                                    ts_key = f"trailing:user:{user_id}:{symbol}:{direction}"
                                    if await redis_client.exists(ts_key):
                                        trailing_sides.add(direction)
                                
                                # ê° ì£¼ë¬¸ í™•ì¸
                                for order_data in orders:
                                    order_id = order_data.get("order_id")
                                    order_type = order_data.get("order_type", "")
                                    position_side = order_data.get("position_side", "")
                                    
                                    # ì´ë¯¸ ì²´ê²°/ì·¨ì†Œëœ ì£¼ë¬¸ì€ ìŠ¤í‚µ
                                    if order_data.get("status", "") != "open":
                                        continue
                                    
                                    # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ì´ í™œì„±í™”ëœ ë°©í–¥ì˜ TP ì£¼ë¬¸ì€ ìŠ¤í‚µ (SLë§Œ í™•ì¸)
                                    if position_side in trailing_sides and order_type.startswith("tp"):
                                        logger.info(f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ í™œì„±í™”ë¨ ({position_side}), TP ì£¼ë¬¸ ({order_id}) ìŠ¤í‚µ")
                                        continue
                                    
                                    check_needed = False
                                    
                                    # ì •ê¸° í™•ì¸ ì‹œê°„ì´ë©´ ê°•ì œë¡œ í™•ì¸
                                    if force_check_orders:
                                        check_needed = True
                                        #logger.info(f"ì •ê¸° í™•ì¸: {order_id}, íƒ€ì…: {order_type}")
                                    else:
                                        # TP ì£¼ë¬¸ ì¡°ê±´ í™•ì¸
                                        if order_type.startswith("tp"):
                                            check_needed = await should_check_tp_order(order_data, current_price)
                                        # SL ì£¼ë¬¸ ì¡°ê±´ í™•ì¸
                                        elif order_type == "sl":
                                            check_needed = await should_check_sl_order(order_data, current_price)
                                    
                                    # ì£¼ë¬¸ ìƒíƒœ í™•ì¸ì´ í•„ìš”í•œ ê²½ìš°
                                    if check_needed:
                                        order_id = order_data.get("order_id")
                                        order_type = order_data.get("order_type", "")
                                        logger.info(f"ì£¼ë¬¸ ìƒíƒœ í™•ì¸: {order_id}, íƒ€ì…: {order_type}")
                                        tp_index = 0
                                        if order_type.startswith("tp"):
                                            tp_index = int(order_type[2:])
                                        # ì£¼ë¬¸ í™•ì¸ ê°„ ì§§ì€ ë”œë ˆì´ ì¶”ê°€ (ì„œë²„ ë¶€í•˜ ë°©ì§€)
                                        await asyncio.sleep(0.1)
                                        
                                        # order_type ë§¤ê°œë³€ìˆ˜ë¥¼ ì¶”ê°€í•˜ì—¬ í˜¸ì¶œ
                                        order_status = await check_order_status(
                                            user_id=user_id, 
                                            symbol=symbol, 
                                            order_id=order_id,
                                            order_type=order_type
                                        )
                                        
                                        # API ì‘ë‹µ ë¶„ì„
                                        if isinstance(order_status, dict):
                                            # OrderResponse í˜•ì‹ (get_order_detail ê²°ê³¼)
                                            if 'status' in order_status:
                                                if order_status['status'] in ['FILLED', 'CLOSED', 'filled', 'closed']:
                                                    status = 'filled'
                                                    filled_sz = order_status.get('filled_amount', order_status.get('amount', '0'))
                                                    
                                                    # TP ì£¼ë¬¸ì´ ì²´ê²°ë˜ë©´ ë¸Œë ˆì´í¬ì´ë¸/íŠ¸ë ˆì¼ë§ìŠ¤íƒ‘ ì²˜ë¦¬ëŠ” process_break_even_settingsì—ì„œ ëª¨ë‘ ë‹´ë‹¹
                                                elif order_status['status'] in ['CANCELED', 'canceled']:
                                                    status = 'canceled'
                                                    filled_sz = order_status.get('filled_amount', '0')
                                                else:
                                                    status = 'open'
                                                    filled_sz = order_status.get('filled_amount', '0')
                                                    
                                                # TP ì£¼ë¬¸ì´ ì²´ê²°ëœ ê²½ìš° ë¸Œë ˆì´í¬ì´ë¸/íŠ¸ë ˆì¼ë§ìŠ¤íƒ‘ ì²˜ë¦¬
                                                if status == 'filled' and order_type.startswith('tp'):
                                                    try:
                                                        #get TP ì—…ë°ì´íŠ¸
                                                        await redis_client.hset(position_key, f"get_tp{tp_index}", "true")
                                                        
                                                        # TP ì£¼ë¬¸ ì²´ê²° ë¡œê¹…
                                                        price = float(order_data.get("price", "0"))
                                                        filled_amount = float(filled_sz) if filled_sz else 0
                                                        
                                                        # TP ì£¼ë¬¸ ì²´ê²° ë¡œê¹…
                                                        try:
                                                            log_order(
                                                                user_id=user_id,
                                                                symbol=symbol,
                                                            action_type='tp_execution',
                                                            position_side=position_side,
                                                            price=price,
                                                            quantity=filled_amount,
                                                            tp_index=tp_index,
                                                                order_id=order_id,
                                                                current_price=current_price
                                                            )
                                                        except Exception as e:
                                                            logger.error(f"TP ì£¼ë¬¸ ì²´ê²° ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
                                                        
                                                        # ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¥¸ ë¸Œë ˆì´í¬ì´ë¸/íŠ¸ë ˆì¼ë§ìŠ¤íƒ‘ ì²˜ë¦¬
                                                        await process_break_even_settings(
                                                            user_id=user_id,
                                                            symbol=symbol,
                                                            order_type=order_type,
                                                            position_data=order_data
                                                        )
                                                    except Exception as be_error:
                                                        logger.error(f"ë¸Œë ˆì´í¬ì´ë¸/íŠ¸ë ˆì¼ë§ìŠ¤íƒ‘ ì²˜ë¦¬ ì‹¤íŒ¨: {str(be_error)}")
                                                
                                                # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                                                await update_order_status(
                                                    user_id=user_id,
                                                    symbol=symbol,
                                                    order_id=order_id,
                                                    status=status,
                                                    filled_amount=str(filled_sz)
                                                )
                                                
                                                # SL ì£¼ë¬¸ì´ ì²´ê²°ëœ ê²½ìš°, ê´€ë ¨ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì •ë¦¬
                                                if status == 'filled' and order_type == 'sl':
                                                    await clear_trailing_stop(user_id, symbol, position_side)
                                                    
                                                    
                                                    # ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ - SL ì£¼ë¬¸ ì²´ê²° ë¡œê¹…
                                                    price = float(order_status.get('avgPx', order_status.get('px', 0)))
                                                    filled_amount = float(filled_sz) if filled_sz else 0
                                                    
                                                    try:
                                                        log_order(
                                                        user_id=user_id,
                                                        symbol=symbol,
                                                        action_type='sl_execution',
                                                        position_side=position_side,
                                                        price=price,
                                                        quantity=filled_amount,
                                                        order_id=order_id,
                                                            current_price=current_price,
                                                            api_type='okx_algo'
                                                        )
                                                    except Exception as e:
                                                        logger.error(f"SL ì£¼ë¬¸ ì²´ê²° ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
                                                
                                                # TP ì£¼ë¬¸ì´ ì²´ê²°ëœ ê²½ìš° ë¡œê¹…
                                                if status == 'filled' and order_type.startswith('tp'):
                                                    try:
                                                        # TP ë ˆë²¨ ì¶”ì¶œ
                                                        tp_index = int(order_type[2:]) if len(order_type) > 2 and order_type[2:].isdigit() else 0
                                                        
                                                        # ê°€ê²© ì •ë³´ ì¶”ì¶œ
                                                        price = float(order_status.get('avgPx', order_status.get('px', 0)))
                                                        filled_amount = float(filled_sz) if filled_sz else 0
                                                        
                                                        # OKX API - TP ì£¼ë¬¸ ì²´ê²° ë¡œê¹…
                                                        log_order(
                                                            user_id=user_id,
                                                            symbol=symbol,
                                                            action_type='tp_execution',
                                                            position_side=position_side,
                                                            price=price,
                                                            quantity=filled_amount,
                                                            tp_index=tp_index,
                                                            order_id=order_id,
                                                            current_price=current_price,
                                                            api_type='okx_algo'
                                                        )
                                                    except Exception as e:
                                                        logger.error(f"OKX TP ì£¼ë¬¸ ì²´ê²° ë¡œê¹… ì‹¤íŒ¨: {str(e)}")
                                            # OKX API ì‘ë‹µ (ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸)
                                            elif 'state' in order_status:
                                                state = order_status.get('state')
                                                filled_sz = order_status.get('accFillSz', '0')
                                                
                                                # ìƒíƒœ ë§¤í•‘
                                                status_mapping = {
                                                    'filled': 'filled',
                                                    'effective': 'open',
                                                    'canceled': 'canceled',
                                                    'order_failed': 'failed'
                                                }
                                                status = status_mapping.get(state, 'unknown')
                                                
                                                # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                                                await update_order_status(
                                                    user_id=user_id,
                                                    symbol=symbol,
                                                    order_id=order_id,
                                                    status=status,
                                                    filled_amount=filled_sz)
                                                
                                                # SL ì£¼ë¬¸ì´ ì²´ê²°ëœ ê²½ìš°, ê´€ë ¨ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°ì´í„° ì •ë¦¬
                                                if status == 'filled' and order_type == 'sl':
                                                    await clear_trailing_stop(user_id, symbol, position_side)
                        except Exception as symbol_error:
                            logger.error(f"ì‹¬ë³¼ {symbol} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(symbol_error)}")
                            traceback.print_exc()
                
                except Exception as user_error:
                    logger.error(f"ì‚¬ìš©ì {user_id} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(user_error)}")
                    traceback.print_exc()
            
            # ì²˜ë¦¬ ê°„ê²© ì„¤ì • (ì´ˆ)
            await asyncio.sleep(MONITOR_INTERVAL)
            
            # ì—°ì† ì˜¤ë¥˜ ì¹´ìš´í„° ì´ˆê¸°í™” (ì„±ê³µì ì¸ ë°˜ë³µ)
            consecutive_errors = 0
            
        except Exception as loop_error:
            logger.error(f"ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜: {str(loop_error)}")
            traceback.print_exc()
            
            # ì—°ì† ì˜¤ë¥˜ ì¦ê°€
            consecutive_errors += 1
            
            # Redis ì—°ê²° ë³µêµ¬ ì‹œë„
            try:
                if not await redis_client.ping():
                    logger.warning("Redis ì—°ê²° ëŠê¹€ ê°ì§€, ì¬ì—°ê²° ì‹œë„...")
                    # Redis í´ë¼ì´ì–¸íŠ¸ ì¬ì—°ê²°
                    await redis_client.connection_pool.disconnect()
                    await redis_client.ping()
                    logger.info("Redis ì—°ê²° ë³µêµ¬ ì„±ê³µ")
            except Exception as redis_error:
                logger.error(f"Redis ì¬ì—°ê²° ì‹¤íŒ¨: {str(redis_error)}")
            
            # ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ëŒ€ê¸° ì‹œê°„ ê³„ì‚° (ìµœëŒ€ 60ì´ˆê¹Œì§€)
            backoff_time = min(5 * 2 ** (consecutive_errors - 1), 60)
            logger.warning(f"ì—°ì† ì˜¤ë¥˜ {consecutive_errors}íšŒ ë°œìƒ, {backoff_time}ì´ˆ í›„ ì¬ì‹œë„")
            
            # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ëŒ€ê¸° í›„ ì¬ì‹œë„
            await asyncio.sleep(backoff_time)

async def start_monitoring():
    """
    ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ì˜¤ë¥˜ ë°œìƒ ì‹œ ì¬ì‹œì‘ ë¡œì§ í¬í•¨.
    """
    restart_attempts = 0
    restart_delay = 5  # ì´ˆê¸° ì¬ì‹œì‘ ë”œë ˆì´ (ì´ˆ)
    
    while restart_attempts < MAX_RESTART_ATTEMPTS:
        try:
            logger.info(f"ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì‹œì‘ (ì‹œë„ {restart_attempts + 1}/{MAX_RESTART_ATTEMPTS})")
            
            # Redis ì—°ê²° ìƒíƒœ í™•ì¸
            try:
                if not await redis_client.ping():
                    logger.warning("Redis ì—°ê²° ì‹¤íŒ¨, ì¬ì—°ê²° ì‹œë„...")
                    await redis_client.connection_pool.disconnect()
                    await redis_client.ping()
            except Exception as redis_error:
                logger.error(f"Redis ì—°ê²° ì˜¤ë¥˜: {str(redis_error)}")
                # Redis ì—°ê²° ì‹¤íŒ¨í•´ë„ ê³„ì† ì‹œë„
            
            # ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹¤í–‰
            await monitor_orders_loop()
            
            # ì—¬ê¸°ì— ë„ë‹¬í•˜ë©´ ì •ìƒ ì¢…ë£Œëœ ê²ƒ (ë¬´í•œ ë£¨í”„ì´ë¯€ë¡œ ì¼ë°˜ì ìœ¼ë¡œëŠ” ë„ë‹¬í•˜ì§€ ì•ŠìŒ)
            logger.info("ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì •ìƒ ì¢…ë£Œ")
            break
            
        except Exception as e:
            restart_attempts += 1
            logger.error(f"ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì‹¤íŒ¨ ({restart_attempts}/{MAX_RESTART_ATTEMPTS}): {str(e)}")
            traceback.print_exc()
            
            # ë‹¤ìŒ ì¬ì‹œì‘ ì‹œë„ ì „ì— ìì› ì •ë¦¬
            try:
                # Redis ì—°ê²° ì •ë¦¬
                await redis_client.connection_pool.disconnect()
                
                # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
                gc.collect()
                
                # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¡œê¹…
                process = psutil.Process()
                memory_info = process.memory_info()
                logger.info(f"ì¬ì‹œì‘ ì „ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {memory_info.rss / 1024 / 1024:.2f} MB")
                
                # í…”ë ˆê·¸ë¨ìœ¼ë¡œ ê´€ë¦¬ìì—ê²Œ ì•Œë¦¼ (ì„ íƒì )
                await send_telegram_message(
                    f"âš ï¸ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ë°œìƒ\nì¬ì‹œì‘ ì‹œë„: {restart_attempts}/{MAX_RESTART_ATTEMPTS}\nì˜¤ë¥˜: {str(e)}",
                    user_id=1709556958,
                    debug=True
                )
            except Exception as cleanup_error:
                logger.error(f"ì¬ì‹œì‘ ì „ ìì› ì •ë¦¬ ì˜¤ë¥˜: {str(cleanup_error)}")
            
            # ì§€ìˆ˜ ë°±ì˜¤í”„ ë°©ì‹ìœ¼ë¡œ ëŒ€ê¸° ì‹œê°„ ì¦ê°€ (ìµœëŒ€ 5ë¶„ê¹Œì§€)
            restart_delay = min(restart_delay * 2, 300)
            logger.info(f"{restart_delay}ì´ˆ í›„ ì„œë¹„ìŠ¤ ì¬ì‹œì‘ ì‹œë„...")
            await asyncio.sleep(restart_delay)
    
    # ìµœëŒ€ ì¬ì‹œì‘ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼
    if restart_attempts >= MAX_RESTART_ATTEMPTS:
        logger.critical(f"ìµœëŒ€ ì¬ì‹œì‘ ì‹œë„ íšŸìˆ˜({MAX_RESTART_ATTEMPTS})ë¥¼ ì´ˆê³¼í•˜ì—¬ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.")
        # ë§ˆì§€ë§‰ í…”ë ˆê·¸ë¨ ì•Œë¦¼
        try:
            await send_telegram_message(
                f"ğŸš¨ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ê°•ì œ ì¢…ë£Œ\nìµœëŒ€ ì¬ì‹œì‘ ì‹œë„ íšŸìˆ˜({MAX_RESTART_ATTEMPTS})ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.\nìˆ˜ë™ ê°œì…ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                user_id=1709556958,
                debug=True
            )
        except Exception:
            pass
        
        # í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì½”ë“œ
        sys.exit(1)

def exit_handler():
    """
    í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ ì •ë¦¬ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    """
    logger.info("í”„ë¡œê·¸ë¨ ì¢…ë£Œ, ìì› ì •ë¦¬ ì¤‘...")
    try:
        # ì—¬ê¸°ì— í•„ìš”í•œ ì •ë¦¬ ë¡œì§ ì¶”ê°€
        logger.info("ìì› ì •ë¦¬ ì™„ë£Œ, í”„ë¡œê·¸ë¨ ì¢…ë£Œ")
    except Exception as e:
        logger.error(f"ì¢…ë£Œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")

async def cancel_algo_orders_for_no_position_sides(user_id: int):
    """
    í¬ì§€ì…˜ì´ ì—†ëŠ” ë°©í–¥ì— ëŒ€í•´ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ì„ ì·¨ì†Œí•˜ëŠ” í•¨ìˆ˜
    """
    try:
        logger.info(f"ì‚¬ìš©ì {user_id}ì˜ í¬ì§€ì…˜ ì—†ëŠ” ë°©í–¥ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ í™•ì¸")
        # ê±°ë˜ì†Œ ì»¨í…ìŠ¤íŠ¸ ì–»ê¸°
        async with get_exchange_context(str(user_id)) as exchange:
            # í˜„ì¬ ë³´ìœ  ì¤‘ì¸ ëª¨ë“  í¬ì§€ì…˜ í™•ì¸
            try:
                positions = await exchange.fetch_positions()
                
                # ê° ì‹¬ë³¼ë³„ í¬ì§€ì…˜ ë°©í–¥ ì €ì¥
                symbol_positions = {}
                
                for position in positions:
                    if not position or not isinstance(position, dict):
                        continue
                    
                    # í¬ì§€ì…˜ ì •ë³´ ì¶”ì¶œ
                    symbol = position.get("symbol", "").replace("-", "")
                    side = position.get("side", "")
                    size = float(position.get("contracts", position.get("size", 0)))
                    
                    # ìœ íš¨í•œ í¬ì§€ì…˜ë§Œ ì²˜ë¦¬
                    if not (symbol and side) or size <= 0:
                        continue
                    
                    # í¬ì§€ì…˜ ë°©í–¥ ì •ê·œí™” (long/short)
                    normalized_side = "long" if side.lower() in ["buy", "long"] else "short"
                    
                    # ì‹¬ë³¼ë³„ í¬ì§€ì…˜ ë°©í–¥ ì €ì¥
                    if symbol not in symbol_positions:
                        symbol_positions[symbol] = set()
                    symbol_positions[symbol].add(normalized_side)
                    
                    # í™œì„± í¬ì§€ì…˜ì´ ìˆëŠ” ì‹¬ë³¼ì€ ìµœê·¼ ê±°ë˜ ì‹¬ë³¼ë¡œ ì¶”ê°€ (ë§Œë£Œ ì‹œê°„ ê°±ì‹ )
                    await add_recent_symbol(user_id, symbol)
                
                # API í‚¤ ê°€ì ¸ì˜¤ê¸° (TriggerCancelClient ì‚¬ìš©)
                try:
                    from src.api.dependencies import get_user_api_keys
                    from src.trading.cancel_trigger_okx import TriggerCancelClient
                    
                    api_keys = await get_user_api_keys(str(user_id))
                    cancel_client = TriggerCancelClient(
                        api_key=api_keys.get('api_key'),
                        secret_key=api_keys.get('api_secret'),
                        passphrase=api_keys.get('passphrase')
                    )
                except Exception as e:
                    logger.error(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨: {str(e)}")
                    return
                
                # ê° ì‹¬ë³¼ì— ëŒ€í•´ ë°˜ëŒ€ ë°©í–¥ ì°¾ê¸°
                for symbol, sides in symbol_positions.items():
                    missing_sides = set(["long", "short"]) - sides
                    
                    # ì‹¬ë³¼ í˜•ì‹ ë³µì› (-ë¥¼ í¬í•¨í•œ í˜•ì‹, ì˜ˆ: BTC-USDT-SWAP)
                    trading_symbol = convert_to_trading_symbol(symbol)
                    
                    # ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼ì´ë©´ ìŠ¤í‚µ
                    if trading_symbol not in SUPPORTED_SYMBOLS:
                        logger.info(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼ ìŠ¤í‚µ: {user_id}:{symbol} -> {trading_symbol}")
                        continue
                    
                    # í¬ì§€ì…˜ì´ ì—†ëŠ” ë°©í–¥ì´ ìˆìœ¼ë©´ ì²˜ë¦¬
                    for missing_side in missing_sides:
                        # ë°˜ëŒ€ ë°©í–¥ì˜ ì£¼ë¬¸ ì·¨ì†Œ
                        logger.info(f"í¬ì§€ì…˜ ì—†ìŒ í™•ì¸ (ì „ì²´ ê²€ì‚¬): {user_id}:{trading_symbol}:{missing_side}")
                        
                        try:
                            # TriggerCancelClientë¥¼ ì‚¬ìš©í•˜ì—¬ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ
                            result = await cancel_client.cancel_all_trigger_orders(
                                inst_id=trading_symbol,
                                side=missing_side,
                                algo_type="trigger",
                                user_id=str(user_id)
                            )
                            
                            if result and result.get('code') == '0':
                                # ì£¼ë¬¸ ì·¨ì†Œ ì„±ê³µ ë˜ëŠ” ì£¼ë¬¸ì´ ì—†ëŠ” ê²½ìš°
                                if 'No active orders to cancel' in result.get('msg', ''):
                                    logger.info(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì—†ìŒ: {trading_symbol} {missing_side}")
                                else:
                                    logger.info(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ì„±ê³µ: {result}")
                                    await send_telegram_message(f"ğŸ—‘ï¸ í¬ì§€ì…˜ ì—†ìŒ - {trading_symbol} {missing_side} ë°©í–¥ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ìë™ ì·¨ì†Œ", user_id, debug=True)
                            else:
                                logger.error(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨: {result}")
                        except Exception as cancel_error:
                            logger.error(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ API í˜¸ì¶œ ì˜¤ë¥˜: {str(cancel_error)}")
                
                # í¬ì§€ì…˜ì´ ì „í˜€ ì—†ëŠ” ì‹¬ë³¼ì— ëŒ€í•´ì„œë„ í™•ì¸ í•„ìš”
                # ìµœê·¼ ê±°ë˜í•œ ì‹¬ë³¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                try:
                    # ìˆ˜ì •ëœ í•¨ìˆ˜ ì‚¬ìš©
                    recent_symbols = await get_recent_symbols(user_id)
                    
                    for symbol in recent_symbols:
                        # ì´ë¯¸ í™•ì¸í•œ ì‹¬ë³¼ì€ ìŠ¤í‚µ
                        if symbol in symbol_positions:
                            continue
                        
                        # ì‹¬ë³¼ í˜•ì‹ ë³µì› (-ë¥¼ í¬í•¨í•œ í˜•ì‹, ì˜ˆ: BTC-USDT-SWAP)
                        trading_symbol = convert_to_trading_symbol(symbol)
                        
                        # ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼ì´ë©´ ìŠ¤í‚µ
                        if trading_symbol not in SUPPORTED_SYMBOLS:
                            logger.info(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼ ìŠ¤í‚µ: {user_id}:{symbol} -> {trading_symbol}")
                            continue
                            
                        logger.info(f"í¬ì§€ì…˜ ì—†ëŠ” ì‹¬ë³¼ í™•ì¸: {user_id}:{symbol} -> {trading_symbol}")
                        
                        # long, short ë°©í–¥ ëª¨ë‘ì— ëŒ€í•´ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ
                        for direction in ["long", "short"]:
                            try:
                                # TriggerCancelClientë¥¼ ì‚¬ìš©í•˜ì—¬ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ
                                result = await cancel_client.cancel_all_trigger_orders(
                                    inst_id=trading_symbol,
                                    side=direction,
                                    algo_type="trigger",
                                    user_id=str(user_id)
                                )
                                
                                if result and result.get('code') == '0':
                                    logger.info(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ì„±ê³µ: {result}")
                                    await send_telegram_message(f"ğŸ—‘ï¸1 í¬ì§€ì…˜ ì—†ìŒ - {trading_symbol} {direction} ë°©í–¥ ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ìë™ ì·¨ì†Œ", user_id, debug=True)
                                else:
                                    logger.error(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨: {result}")
                            except Exception as cancel_error:
                                logger.error(f"ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ API í˜¸ì¶œ ì˜¤ë¥˜: {str(cancel_error)}")
                    
                except Exception as e:
                    logger.error(f"ìµœê·¼ ì‹¬ë³¼ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
                    
            except Exception as e:
                logger.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
                
    except Exception as e:
        logger.error(f"ì‚¬ìš©ì {user_id} ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜: {str(e)}")

def convert_to_trading_symbol(symbol: str) -> str:
    """
    ë‹¤ì–‘í•œ í˜•ì‹ì˜ ì‹¬ë³¼ì„ OKX API í˜¸í™˜ í˜•ì‹(BTC-USDT-SWAP)ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    ì§€ì›í•˜ëŠ” ì‹¬ë³¼ë§Œ ë°˜í™˜í•˜ë©°, ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼ì€ ê¸°ë³¸ê°’ì¸ BTC-USDT-SWAPì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    Args:
        symbol (str): ë³€í™˜í•  ì‹¬ë³¼ (ì˜ˆ: "BTCUSDT", "BTC/USDT" ë“±)
        
    Returns:
        str: OKX API í˜¸í™˜ í˜•ì‹ì˜ ì‹¬ë³¼ (ì˜ˆ: "BTC-USDT-SWAP")
    """
    # ìŠ¬ë˜ì‹œ(/) ì œê±°
    symbol = symbol.replace("/", "")
    # í•˜ì´í”ˆ(-) ì œê±° 
    symbol = symbol.replace("-", "")
    
    # ì¼ë°˜ì ì¸ ì‹¬ë³¼ í˜•ì‹ ë³€í™˜ (BTCUSDT, ETHUSDT ë“±)
    converted_symbol = ""
    
    if len(symbol) >= 7:
        # ëŒ€ë¶€ë¶„ì˜ ì½”ì¸ì€ 3ê¸€ì + 4ê¸€ì(USDT) í˜•ì‹
        base = symbol[0:3]
        quote = symbol[3:7]
        converted_symbol = f"{base}-{quote}-SWAP"
    elif len(symbol) >= 6 and symbol.endswith("USDT"):
        # 2ê¸€ì ì½”ì¸ (XRPUSDT ê°™ì€ ê²½ìš°)
        base_len = len(symbol) - 4
        base = symbol[0:base_len]
        quote = symbol[base_len:]
        converted_symbol = f"{base}-{quote}-SWAP"
    else:
        # ê¸°íƒ€ í˜•ì‹ì€ ê¸°ë³¸ê°’ìœ¼ë¡œ ì²˜ë¦¬
        logger.warning(f"ì•Œ ìˆ˜ ì—†ëŠ” ì‹¬ë³¼ í˜•ì‹: {symbol}, ê¸°ë³¸ê°’ ì‚¬ìš©")
        converted_symbol = "BTC-USDT-SWAP"
    
    # ì§€ì›í•˜ëŠ” ì‹¬ë³¼ì¸ì§€ í™•ì¸
    if converted_symbol in SUPPORTED_SYMBOLS:
        return converted_symbol
    else:
        logger.warning(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼: {converted_symbol}, ê¸°ë³¸ê°’ ì‚¬ìš©")
        return "BTC-USDT-SWAP"

# ì‹¬ë³¼ ê´€ë¦¬ í•¨ìˆ˜ ì¶”ê°€
async def add_recent_symbol(user_id: int, symbol: str):
    """
    ì‚¬ìš©ìê°€ ê±°ë˜í•œ ì‹¬ë³¼ì„ Redisì— ì €ì¥í•˜ê³  1ì‹œê°„ì˜ ë§Œë£Œ ì‹œê°„ì„ ì„¤ì •í•©ë‹ˆë‹¤.
    
    Args:
        user_id (int): ì‚¬ìš©ì ID
        symbol (str): ê±°ë˜ ì‹¬ë³¼
    """
    try:
        # ê° ì‹¬ë³¼ì„ ë³„ë„ì˜ í‚¤ë¡œ ì €ì¥ (ê°œë³„ ë§Œë£Œ ì‹œê°„ ì„¤ì •ì„ ìœ„í•´)
        symbol_key = f"user:{user_id}:recent_symbol:{symbol}"
        
        # ì‹¬ë³¼ ì •ë³´ ì €ì¥ (ê°’ì€ ì¤‘ìš”í•˜ì§€ ì•ŠìŒ, í‚¤ì˜ ì¡´ì¬ ì—¬ë¶€ë§Œ í™•ì¸)
        await redis_client.set(symbol_key, "1")
        
        # 1ì‹œê°„(3600ì´ˆ) ë§Œë£Œ ì‹œê°„ ì„¤ì •
        await redis_client.expire(symbol_key, 3600)
        
        logger.info(f"ìµœê·¼ ê±°ë˜ ì‹¬ë³¼ ì¶”ê°€: {user_id}:{symbol}, ë§Œë£Œ: 1ì‹œê°„")
    except Exception as e:
        logger.error(f"ìµœê·¼ ê±°ë˜ ì‹¬ë³¼ ì¶”ê°€ ì‹¤íŒ¨: {str(e)}")

async def get_recent_symbols(user_id: int) -> List[str]:
    """
    ì‚¬ìš©ìê°€ ìµœê·¼ ê±°ë˜í•œ ì‹¬ë³¼ ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
    
    Args:
        user_id (int): ì‚¬ìš©ì ID
        
    Returns:
        List[str]: ìµœê·¼ ê±°ë˜ ì‹¬ë³¼ ëª©ë¡
    """
    try:
        # íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ëª¨ë“  í™œì„± ì‹¬ë³¼ í‚¤ ê°€ì ¸ì˜¤ê¸°
        pattern = f"user:{user_id}:recent_symbol:*"
        symbol_keys = await redis_client.keys(pattern)
        
        # í‚¤ì—ì„œ ì‹¬ë³¼ ë¶€ë¶„ë§Œ ì¶”ì¶œ
        symbols = []
        for key in symbol_keys:
            # í‚¤ í˜•ì‹: user:{user_id}:recent_symbol:{symbol}
            parts = key.split(":")
            if len(parts) >= 4:
                symbol = parts[3]
                symbols.append(symbol)
        
        return symbols
    except Exception as e:
        logger.error(f"ìµœê·¼ ê±°ë˜ ì‹¬ë³¼ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
        return []

if __name__ == "__main__":
    """
    ë…ë¦½ ì‹¤í–‰ ì‹œ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸
    """
    import atexit
    import signal
    
    # ì¢…ë£Œ í•¸ë“¤ëŸ¬ ë“±ë¡
    atexit.register(exit_handler)
    
    # ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì •
    def signal_handler(sig, frame):
        logger.info(f"ì‹œê·¸ë„ {sig} ìˆ˜ì‹ , í”„ë¡œê·¸ë¨ ì¢…ë£Œ...")
        # ì—¬ê¸°ì„œ cleanup ë¡œì§ì´ë‚˜ ì¢…ë£Œ ì•Œë¦¼ ë“±ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŒ
        sys.exit(0)
    
    # SIGINT(Ctrl+C), SIGTERM í•¸ë“¤ëŸ¬ ë“±ë¡
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê°€ì ¸ì˜¤ê¸°
    import sys
    import psutil
    
    # í”„ë¡œì„¸ìŠ¤ ìš°ì„ ìˆœìœ„ ì„¤ì • (ì„ íƒì )
    try:
        import os
        if hasattr(os, 'nice'):
            os.nice(10)  # ë‚®ì€ ìš°ì„ ìˆœìœ„ ì„¤ì • (Linux/Mac)
        elif sys.platform == 'win32':
            import win32process
            import win32api
            pid = win32api.GetCurrentProcessId()
            handle = win32api.OpenProcess(win32process.PROCESS_ALL_ACCESS, True, pid)
            win32process.SetPriorityClass(handle, win32process.BELOW_NORMAL_PRIORITY_CLASS)
    except Exception as e:
        logger.warning(f"í”„ë¡œì„¸ìŠ¤ ìš°ì„ ìˆœìœ„ ì„¤ì • ì‹¤íŒ¨: {str(e)}")
    
    # ë©”ëª¨ë¦¬ ì œí•œ ì„¤ì • (ì„ íƒì )
    try:
        if sys.platform != 'win32':  # Unix/Linux/Mac
            import resource
            # 2GB ë©”ëª¨ë¦¬ ì œí•œ (ì†Œí”„íŠ¸ ì œí•œ)
            rsrc = resource.RLIMIT_AS
            soft, hard = resource.getrlimit(rsrc)
            resource.setrlimit(rsrc, (2 * 1024 * 1024 * 1024, hard))
            logger.info(f"ë©”ëª¨ë¦¬ ì œí•œ ì„¤ì •: {2}GB (ì†Œí”„íŠ¸ ì œí•œ)")
    except Exception as e:
        logger.warning(f"ë©”ëª¨ë¦¬ ì œí•œ ì„¤ì • ì‹¤íŒ¨: {str(e)}")
        
    # ê¸°ë³¸ ëª¨ë‹ˆí„°ë§ ì •ë³´ ì¶œë ¥
    process = psutil.Process()
    logger.info(f"ì‹œì‘ ì‹œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {process.memory_info().rss / 1024 / 1024:.2f} MB")
    logger.info(f"CPU ì½”ì–´: {psutil.cpu_count()} / ë…¼ë¦¬ ì½”ì–´: {psutil.cpu_count(logical=True)}")
    
    # ë©”ì¸ ë£¨í”„ ì‹œì‘
    try:
        asyncio.run(start_monitoring())
    except KeyboardInterrupt:
        logger.info("ì‚¬ìš©ìê°€ í”„ë¡œê·¸ë¨ì„ ì¤‘ë‹¨í•¨ (KeyboardInterrupt)")
    except Exception as e:
        logger.critical(f"í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ì¹˜ëª…ì ì¸ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
        traceback.print_exc()
        sys.exit(1) 