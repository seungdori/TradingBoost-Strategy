# src/trading/monitoring.py

import asyncio
import json
from datetime import datetime, timedelta
import traceback
from typing import Dict, List, Optional, Set, Tuple
import time
import gc
import sys
import os
import aiohttp

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../../")))
from src.helpers.order_helper import contracts_to_qty
import signal
import atexit
import psutil
from src.core.logger import get_logger, log_order
from src.core.database import redis_client
from src.trading.services.get_current_price import get_current_price
from src.api.dependencies import  get_exchange_context
from src.bot.telegram_message import send_telegram_message
from src.core.error_handler import log_error
from src.api.routes.order import close_position, get_order_detail, update_stop_loss_order, get_algo_order_info, ClosePositionRequest
from src.trading.dual_side_entry import get_user_dual_side_settings

# 지원하는 거래 심볼 목록 (추후 확장 가능)
SUPPORTED_SYMBOLS = ["BTC-USDT-SWAP", "ETH-USDT-SWAP", "SOL-USDT-SWAP"]

# 불리언 값 또는 문자열을 안전하게 처리하는 함수
def is_true_value(value):
    if isinstance(value, bool):
        return value
    elif isinstance(value, str):
        return value.lower() == 'true'
    return False
# 시스템 특정 모듈 (조건부 임포트)
try:
    import resource  # Unix 전용
except ImportError:
    resource = None




MONITOR_INTERVAL = 5
ORDER_CHECK_INTERVAL = 10  # 주문 상태를 확인하는 간격(초)

# 모니터링 서비스 설정
MAX_RESTART_ATTEMPTS = 5  # 최대 재시작 횟수 
MAX_MEMORY_MB = 2048     # 최대 메모리 사용량 (MB)
MEMORY_CLEANUP_INTERVAL = 600  # 메모리 정리 간격 (10분)
CONNECTION_TIMEOUT = 30  # API 연결 타임아웃 (초)
API_RATE_LIMIT = 5       # 초당 최대 API 호출 수

# 상태 캐시 추가 (최근 체크한 주문 상태를 단시간 캐싱)
order_status_cache = {}
ORDER_STATUS_CACHE_TTL = 5  # 5초 캐시 유지

async def get_user_settings(user_id: int) -> dict:
    """
    사용자의 설정 정보를 가져옵니다.
    
    Args:
        user_id (int): 사용자 ID
        
    Returns:
        dict: 사용자 설정 정보
    """
    try:
        settings_key = f"user:{user_id}:settings"
        settings_data = await redis_client.get(settings_key)
        
        if settings_data:
            return json.loads(settings_data)
        else:
            # 기본 설정값
            return {
                'use_sl': True,
                'use_break_even': False,
                'use_break_even_tp2': False,
                'use_break_even_tp3': False
            }
    except Exception as e:
        logger.error(f"Error getting settings for user {user_id}: {str(e)}")
        return {
            'use_sl': True,
            'use_break_even': False,
            'use_break_even_tp2': False,
            'use_break_even_tp3': False
        }


logger = get_logger(__name__)

async def get_all_running_users() -> List[int]:
    """
    현재 'running' 상태인 모든 user_id를 조회
    """
    try:
        status_keys = await redis_client.keys("user:*:trading:status")
        running_users = []
        
        for key in status_keys:
            status = await redis_client.get(key)
            if status == "running":
                # key 구조: user:{user_id}:trading:status
                parts = key.split(":")
                user_id = int(parts[1])
                running_users.append(user_id)
        
        return running_users
    except Exception as e:
        logger.error(f"running_users 조회 실패: {str(e)}")
        return []

async def get_user_monitor_orders(user_id: int) -> Dict[str, Dict]:
    """
    사용자의 모든 모니터링 중인 주문을 조회합니다.
    
    Args:
        user_id: 사용자 ID
        
    Returns:
        Dict: {order_id: order_data, ...}
    """
    try:
        # 사용자 주문 모니터링 키 패턴
        pattern = f"monitor:user:{user_id}:*:order:*"
        order_keys = await redis_client.keys(pattern)
        
        orders = {}
        for key in order_keys:
            try:
                # 키 타입 확인
                key_type = await redis_client.type(key)
                
                # 해시 타입인지 확인 - 문자열로 변환하여 비교
                if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                    # 정상적인 해시 타입인 경우
                    order_data = await redis_client.hgetall(key)
                    if order_data and "status" in order_data and order_data["status"] == "open":
                        # key 형식: monitor:user:{user_id}:{symbol}:order:{order_id}
                        parts = key.split(":")
                        symbol = parts[3]
                        order_id = parts[5]
                        
                        # order_data에 symbol과 order_id 추가
                        order_data["symbol"] = symbol
                        order_data["order_id"] = order_id
                        orders[order_id] = order_data
                else:
                    # 다른 타입이면 로그만 남기고 스킵
                    logger.warning(f"주문 데이터가 해시 타입이 아닙니다. (key: {key}, 타입: {key_type})")
            except Exception as redis_error:
                logger.error(f"Redis 주문 데이터 조회 중 오류 (key: {key}): {str(redis_error)}")
                continue
                
        return orders
    except Exception as e:
        logger.error(f"사용자 {user_id}의 모니터링 주문 조회 실패: {str(e)}")
        return {}

async def check_order_status(user_id: int, symbol: str, order_id: str, order_type: str = None) -> Dict:
    """
    거래소 API를 통해 주문 상태를 확인합니다.
    
    Args:
        user_id: 사용자 ID
        symbol: 거래 심볼
        order_id: 주문 ID
        order_type: 주문 유형 ('tp1', 'tp2', 'tp3', 'sl' 등)
        
    Returns:
        Dict: 주문 상태 정보, 오류 발생 시 주문 취소 상태 반환
    """
    try:
        # 캐시 키 생성
        cache_key = f"{user_id}:{symbol}:{order_id}"
        current_time = time.time()
        
        # 캐시된 결과가 있으면 반환
        if cache_key in order_status_cache:
            cached_time, cached_result = order_status_cache[cache_key]
            if current_time - cached_time < ORDER_STATUS_CACHE_TTL:
                logger.debug(f"캐시된 주문 상태 사용: {order_id} (캐시 유효 시간: {ORDER_STATUS_CACHE_TTL - (current_time - cached_time):.1f}초)")
                return cached_result
            
        # TP 주문(tp1, tp2, tp3)은 일반 리밋 주문으로 처리
        is_algo = True
        
        # 주문 유형에 따라 API 호출 방식 결정
        if order_type and order_type.startswith('tp'):
            is_algo = False  # TP 주문은 일반 주문(limit)
            logger.debug(f"TP 주문({order_type}) 조회: {order_id}, 일반 주문 API 사용")
        else:
            # SL 주문 등은 알고리즘 주문
            is_algo = True
            logger.debug(f"SL 주문 조회: {order_id}, 알고리즘 주문 API 사용")
        
        try:
            # src/api/routes/order.py의 get_order_detail 함수 사용
            if is_algo:
                response = await get_algo_order_info(
                    user_id=str(user_id),
                    symbol=symbol,
                    order_id=order_id,
                    algo_type="trigger"
                )
            else:
                response = await get_order_detail(
                    order_id=order_id,
                    user_id=str(user_id),
                    symbol=symbol,
                    is_algo=is_algo,
                    algo_type= None
                )
            
            if response:
                # OrderResponse 모델을 딕셔너리로 변환
                if hasattr(response, "model_dump"):
                    result = response.model_dump()
                elif hasattr(response, "dict"):  # 하위 호환성 유지
                    result = response.dict()
                else:
                    result = dict(response)
                
                # 결과 캐싱
                order_status_cache[cache_key] = (current_time, result)
                return result
                
        except Exception as detail_error:
            # 404 오류이거나 '찾을 수 없음' 오류인 경우
            error_str = str(detail_error).lower()
            if "404" in error_str or "찾을 수 없습니다" in error_str or "not found" in error_str:
                logger.info(f"주문을 찾을 수 없음 (취소됨/만료됨): {order_id}, 오류: {str(detail_error)}")
                # 취소된 주문으로 처리
                result = {
                    "status": "canceled",
                    "order_id": order_id,
                    "symbol": symbol,
                    "filled_amount": "0",
                    "canceled_reason": "not_found_in_exchange"
                }
                # 결과 캐싱
                order_status_cache[cache_key] = (current_time, result)
                return result
            else:
                logger.warning(f"get_order_detail 호출 실패: {str(detail_error)}")
            
            # 직접 거래소 API 호출로 폴백
            try:
                async with get_exchange_context(str(user_id)) as exchange:
                    try:
                        if is_algo:
                            # 알고리즘 주문 조회 - 명시적으로 state 파라미터 추가
                            params = {
                                'ordType': 'conditional', 
                                'algoId': order_id,
                                'instId': symbol,
                                'state': 'live,effective,canceled,order_failed,filled'  # 모든 가능한 상태
                            }
                            
                            # API 호출 전 필요한 파라미터가 있는지 확인
                            if not order_id or not symbol:
                                logger.warning(f"알고리즘 주문 조회 필수 파라미터 누락: order_id={order_id}, symbol={symbol}")
                                result = {
                                    "status": "canceled",
                                    "order_id": order_id,
                                    "symbol": symbol,
                                    "filled_amount": "0",
                                    "canceled_reason": "missing_parameters"
                                }
                                # 결과 캐싱
                                order_status_cache[cache_key] = (current_time, result)
                                return result
                            
                            # 파라미터를 로깅하여 디버깅에 도움을 줌
                            logger.debug(f"알고리즘 주문 조회 파라미터: {params}")
                            
                            algo_orders = await exchange.privateGetTradeOrdersAlgoHistory(params)
                            
                            if algo_orders and 'data' in algo_orders and len(algo_orders['data']) > 0:
                                result = algo_orders['data'][0]
                                # 결과 캐싱
                                order_status_cache[cache_key] = (current_time, result)
                                return result
                            else:
                                # 주문이 없는 경우 취소된 것으로 처리
                                logger.info(f"알고리즘 주문이 존재하지 않음 (취소됨): {order_id}")
                                result = {
                                    "status": "canceled",
                                    "order_id": order_id,
                                    "symbol": symbol,
                                    "filled_amount": "0",
                                    "canceled_reason": "not_found_in_exchange"
                                }
                                # 결과 캐싱
                                order_status_cache[cache_key] = (current_time, result)
                                return result
                        else:
                            # 일반 주문 조회
                            try:
                                order_info = await exchange.fetch_order(order_id, symbol)
                                # 결과 캐싱
                                order_status_cache[cache_key] = (current_time, order_info)
                                return order_info
                            except Exception as fetch_error:
                                error_str = str(fetch_error).lower()
                                # 주문이 찾을 수 없는 경우 취소된 것으로 처리
                                if "not found" in error_str or "존재하지 않" in error_str or "찾을 수 없" in error_str:
                                    logger.info(f"일반 주문이 존재하지 않음 (취소됨): {order_id}")
                                    result = {
                                        "status": "canceled",
                                        "order_id": order_id,
                                        "symbol": symbol,
                                        "filled_amount": "0",
                                        "canceled_reason": "not_found_in_exchange"
                                    }
                                    # 결과 캐싱
                                    order_status_cache[cache_key] = (current_time, result)
                                    return result
                                raise
                    except Exception as api_error:
                        # API 호출 오류인 경우
                        error_str = str(api_error).lower()
                        if "50015" in error_str and "algoId or state is required" in error_str:
                            logger.info(f"알고리즘 주문 조회 파라미터 오류 - 주문이 이미 취소됨: {order_id}")
                            result = {
                                "status": "canceled",
                                "order_id": order_id,
                                "symbol": symbol,
                                "filled_amount": "0",
                                "canceled_reason": "api_parameter_error"
                            }
                            # 결과 캐싱
                            order_status_cache[cache_key] = (current_time, result)
                            return result
                        else:
                            logger.error(f"거래소 API 직접 호출 실패: {str(api_error)}")
                            raise
            except Exception as exchange_error:
                logger.error(f"거래소 컨텍스트 생성 중 오류: {str(exchange_error)}")
                # 장애 발생 시에도 안전하게 취소된 것으로 처리
                result = {
                    "status": "canceled",
                    "order_id": order_id,
                    "symbol": symbol,
                    "filled_amount": "0", 
                    "canceled_reason": "exchange_error"
                }
                # 결과 캐싱
                order_status_cache[cache_key] = (current_time, result)
                return result
            
        # 모든 방법을 시도했는데도 주문 정보를 가져오지 못한 경우
        result = {
            "status": "canceled",
            "order_id": order_id,
            "symbol": symbol,
            "filled_amount": "0",
            "canceled_reason": "all_retrieval_methods_failed"
        }
        # 결과 캐싱
        order_status_cache[cache_key] = (current_time, result)
        return result
    except Exception as e:
        logger.error(f"주문 상태 확인 중 예외 발생 (user_id:{user_id}, symbol:{symbol}, order_id:{order_id}, order_type:{order_type}): {str(e)}")
        traceback.print_exc()
        # 오류 발생 시 기본값으로 취소 상태 반환 (안전한 방식)
        result = {
            "status": "canceled", 
            "error": str(e),
            "order_id": order_id,
            "symbol": symbol,
            "filled_amount": "0",
            "canceled_reason": "exception"
        }
        # 결과 캐싱
        order_status_cache[cache_key] = (current_time, result)
        return result

async def update_order_status(user_id: int, symbol: str, order_id: str, status: str, filled_amount: str = "0") -> None:
    """
    주문 상태를 업데이트합니다.
    
    Args:
        user_id: 사용자 ID
        symbol: 거래 심볼
        order_id: 주문 ID
        status: 새 상태
        filled_amount: 체결된 수량
    """
    try:
        monitor_key = f"monitor:user:{user_id}:{symbol}:order:{order_id}"
        order_data = await redis_client.hgetall(monitor_key)
        
        if not order_data:
            logger.warning(f"주문 데이터를 찾을 수 없음: {monitor_key}")
            await redis_client.delete(monitor_key)
            return
        
        # 이미 같은 상태면 업데이트 및 알림 건너뛰기
        current_status = order_data.get("status", "")
        if current_status == status:
            #logger.info(f"주문 상태가 이미 '{status}'입니다. 업데이트 및 알림 건너뛰기: {order_id}")
            return
            
        # 상태 업데이트
        now = datetime.now()
        kr_time = now + timedelta(hours=9)
        
        contracts_amount = float(order_data.get("contracts_amount", "0"))
        filled_contracts = float(filled_amount or "0")
        remain_contracts = max(0, contracts_amount - filled_contracts)
        
        update_data = {
            "status": status,
            "filled_contracts_amount": str(filled_contracts),
            "remain_contracts_amount": str(remain_contracts),
            "last_updated_time": str(int(now.timestamp())),
            "last_updated_time_kr": kr_time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        # 완료된 주문 처리 (체결, 취소, 실패 등)
        final_statuses = ["filled", "canceled", "failed"]
        if status in final_statuses:
            # 완료된 주문은 completed 키로 이동
            completed_key = f"completed:user:{user_id}:{symbol}:order:{order_id}"
            
            # 현재 모니터링 데이터에 업데이트 데이터 적용
            updated_order_data = {**order_data, **update_data}
            
            # 포지션 정보(진입가격 등)가 있다면 포함시키기
            position_side = order_data.get("position_side", "")
            if position_side:
                try:
                    position_key = f"user:{user_id}:position:{symbol}:{position_side}"
                    position_data = await redis_client.hgetall(position_key)
                    
                    # 포지션 정보가 있으면 주요 데이터 추가
                    if position_data:
                        entry_price = position_data.get("entry_price", "0")
                        leverage = position_data.get("leverage", "1")
                        is_hedge = position_data.get("is_hedge", "false")
                        
                        # completed 주문 데이터에 포지션 정보 추가
                        updated_order_data["entry_price"] = entry_price
                        updated_order_data["leverage"] = leverage
                        updated_order_data["is_hedge"] = is_hedge
                except Exception as e:
                    logger.warning(f"포지션 정보 조회 중 오류 발생: {str(e)}")
            
            # completed 키에 데이터 저장
            await redis_client.hset(completed_key, mapping=updated_order_data)
            
            # 2주일(14일) TTL 설정
            await redis_client.expire(completed_key, 60 * 60 * 24 * 14)  # 14일 = 1,209,600초
            
            # 기존 모니터링 키 삭제
            await redis_client.delete(monitor_key)
            
            logger.info(f"주문 {order_id}를 모니터링에서 제거하고 완료 저장소로 이동 (TTL: 14일)")
        else:
            # 진행 중인 주문은 모니터링 키 업데이트
            await redis_client.hset(monitor_key, mapping=update_data)
            
        logger.info(f"주문 상태 업데이트 완료: {order_id}, 상태: {status}")
        
        # 완전 체결 또는 취소된 경우 알림 발송
        if status in ["filled"]:
            order_type = order_data.get("order_type", "unknown")
            price = float(order_data.get("price", "0"))
            position_side = order_data.get("position_side", "unknown")
            
            # PnL 계산을 위한 추가 정보 가져오기
            position_key = f"user:{user_id}:position:{symbol}:{position_side}"
            position_data = await redis_client.hgetall(position_key)
            position_qty = f"{float(position_data.get('position_qty', '0')):.3f}"
            is_hedge = position_data.get("is_hedge", "false")
            
            filled_qty = await contracts_to_qty(symbol = symbol, contracts = filled_contracts)
            
            # 메시지 구성 (주문 유형별 맞춤형 메시지)
            status_emoji = "✅" if status == "filled" else "❌"
            status_text = "체결 완료"
            
            # 주문 유형에 따른 메시지 제목 설정
            if status == "filled":
                if order_type == "break_even":
                    title = f"🟡 브레이크이븐 {status_text}"
                elif order_type == "sl":
                    if is_hedge:
                        title = f"🔴 반대포지션 손절 {status_text}"
                    else:
                        title = f"🔴 손절(SL) {status_text}"
                elif order_type.startswith("tp"):
                    tp_level = order_type[2:] if len(order_type) > 2 else "1"
                    title = f"🟢 익절(TP{tp_level}) {status_text}"
                else:
                    title = f"{status_emoji} 주문 {status_text}"
            else:
                if order_type == "sl":
                    title = f"⚠️ 손절(SL) 주문 {status_text}"
                elif order_type.startswith("tp"):
                    tp_level = order_type[2:] if len(order_type) > 2 else "1"
                    title = f"⚠️ 익절(TP{tp_level}) 주문 {status_text}"
                else:
                    title = f"{status_emoji} 주문 {status_text}"
            
            # PnL 계산 (체결된 경우만)
            pnl_text = ""
            if status == "filled" and position_data:
                try:
                    # 진입 가격 (평균 진입가)
                    entry_price = float(position_data.get("entry_price", 0))
                    
                    # PnL 계산
                    if entry_price > 0:
                        if position_side == "long":
                            pnl_percent = ((price / entry_price) - 1) * 100
                        else:  # short
                            pnl_percent = ((entry_price / price) - 1) * 100
                        
                        # PnL 아이콘 설정
                        pnl_icon = "📈" if pnl_percent > 0 else "📉"
                        
                        # PnL 텍스트 구성
                        pnl_text = f"\n{pnl_icon} 수익률: {pnl_percent:.2f}%"
                        
                        # 레버리지가 있는 경우 레버리지 적용 수익률도 표시
                        leverage = float(position_data.get("leverage", 1))
                        if leverage > 1:
                            leveraged_pnl = pnl_percent * leverage
                            pnl_text += f" (레버리지 x{leverage} 적용: {leveraged_pnl:.2f}%)"
                except Exception as pnl_error:
                    logger.error(f"PnL 계산 중 오류: {str(pnl_error)}")
                    pnl_text = "\n💡 PnL 계산 불가"
                
            message = (
                f"{title}\n"
                f"━━━━━━━━━━━━━━━\n"
                f"심볼: {symbol}\n"
                f"방향: {position_side.upper()}\n"
                f"체결가격: {price}\n"
            )
            
            # 체결수량이 0보다 클 때만 메시지에 추가
            if float(filled_qty) > 0:
                message += f"체결수량: {round(float(filled_qty), 3)}{pnl_text}"
                await send_telegram_message(message, user_id=user_id)
            
            
            
            if order_type == "break_even":
                # 브레이크이븐 설정 후 포지션이 아직 존재하는지 확인
                position_exists = await check_position_exists(user_id, symbol, position_side)

                # 포지션이 존재한다면 직접 종료
                if position_exists:
                    logger.info(f"브레이크이븐 설정 후 {symbol} {position_side} 포지션이 여전히 존재함. 직접 종료합니다.")
                    close_request = ClosePositionRequest(
                        close_type="market",
                        price=price,
                        close_percent=100
                    )
                    try:
                        close_result = asyncio.create_task(close_position(
                            symbol=symbol,
                            close_request=close_request,
                            user_id=user_id,
                            side=position_side
                        ))


                        await send_telegram_message(
                            f"🔒 브레이크이븐 설정 후 {symbol} {position_side} 포지션을 직접 종료했습니다.",
                            user_id, debug = True
                        )

                        # 포지션 종료 후 관련 데이터 정리
                        await check_and_cleanup_orders(user_id, symbol, position_side)

                    except Exception as e:
                        await send_telegram_message(f"브레이크이븐 종료 오류!!!: {str(e)}", user_id, debug = True)

            
    
    except Exception as e:
        logger.error(f"주문 상태 업데이트 실패: {str(e)}")
        traceback.print_exc()

async def move_sl_to_break_even(user_id: int, symbol: str, side: str, break_even_price: float, contracts_amount: float, tp_index: int = 0, is_hedge: bool = False):
    """
    거래소 API를 사용해 SL(Stop Loss) 가격을 break_even_price로 업데이트.
    """
    try:
        # side가 long 또는 buy이면 order_side는 sell, side가 short 또는 sell이면 order_side는 buy
        order_side = "sell"
        if side == "long" or side == "buy":
            order_side = "sell"
        elif side == "short" or side == "sell":
            order_side = "buy"
            
        result = await update_stop_loss_order(
                        new_sl_price=break_even_price,
                        symbol=symbol,
                        side=side,
                        order_side=order_side,
                        contracts_amount=contracts_amount,
                        user_id=user_id,
                        is_hedge=is_hedge,
                        order_type="break_even"
                    ),
                
        if isinstance(result, dict) and not result.get('success', True):
            logger.info(f"SL 업데이트 건너뜀: {result.get('message')}")
            return None
        await asyncio.sleep(3)

        
        telegram_message = ""


        if tp_index > 0:
            telegram_message += f"🔒 TP{tp_index} 체결 후 SL을 브레이크이븐({break_even_price:.2f})으로 이동\n"
            
            try:
                dual_side_settings = await get_user_dual_side_settings(user_id)
                dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
                dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
                if dual_side_settings.get('use_dual_side', False):
                    if dual_side_sl_type == 'existing_position':

                        if int(dual_side_sl_value) > tp_index:
                            dual_side_key = f"user:{user_id}:{symbol}:dual_side_position"
                            await redis_client.hset(dual_side_key, "stop_loss", break_even_price)
                            telegram_message += f"🔒 양방향 포지션 SL 업데이트: {break_even_price:.2f}$\n"
            except Exception as e:
                await send_telegram_message(f"[{user_id}]양방향 포지션 SL 업데이트 오류: {str(e)}", user_id, debug=True)
                
            
            asyncio.create_task(send_telegram_message(
                telegram_message,
                user_id
            ))
        position_key = f"user:{user_id}:position:{symbol}:{side}"
        await redis_client.hset(position_key, "sl_price", break_even_price)
        
        # 브레이크이븐 이동 로깅
        try:
            log_order(
                user_id=user_id,
                symbol=symbol,
            action_type='break_even_move',
            position_side=side,
            price=break_even_price,
            quantity=contracts_amount,
                tp_index=tp_index,
                is_hedge=is_hedge
            )
        except Exception as e:
            logger.error(f"브레이크이븐 이동 로깅 실패: {str(e)}")
            
        # dual_side_position이 있는지 확인
        dual_side_key = f"user:{user_id}:{symbol}:dual_side_position"
        dual_side_position_exists = await redis_client.exists(dual_side_key)
        
        if dual_side_position_exists:
            # dual_side_entry_tp_trigger_type 설정 확인

            dual_settings = await get_user_dual_side_settings(user_id)
            dual_side_entry_tp_trigger_type = dual_settings.get('dual_side_entry_tp_trigger_type', 'percent')
            dual_side_tp_value = dual_settings.get('dual_side_entry_tp_value', 10)
            dual_side_sl_value = dual_settings.get('dual_side_entry_sl_value', 10)
            
            if dual_side_entry_tp_trigger_type == "existing_position":
                # 반대 방향 포지션 찾기
                opposite_side = "short" if side == "long" else "long"
                
                # 반대 방향 포지션 종료
                if int(dual_side_sl_value) == tp_index:
                    
                    close_request = ClosePositionRequest(
                        close_type="market",
                        close_percent=100
                    )
                    
                    try:
                        logger.info(f"dual_side_position 종료 시도: {symbol}, {opposite_side}")
                        response = await close_position(
                            symbol=symbol, 
                            close_request=close_request, 
                            user_id=user_id, 
                            side=opposite_side
                        )
                        
                        # 양방향 종료 로깅
                        await send_telegram_message(
                            f"✅양방향 포지션 종료\n" +
                            f"━━━━━━━━━━━━━━━━\n" +
                            f"메인 포지션의 TP{tp_index} 체결로 양방향 포지션 종료\n" +
                            f"• 방향: {opposite_side}\n" +
                            f"━━━━━━━━━━━━━━━━\n",
                            user_id
                        )
                        
                        # dual_side_position 키 삭제
                        await redis_client.delete(dual_side_key)
                        
                    except Exception as e:
                        logger.error(f"dual_side_position 종료 실패: {str(e)}")
                        await send_telegram_message(f"양방향 포지션 종료 실패: {str(e)}", user_id, debug=True)

        return result
    except Exception as e:
        error_msg = f"move_sl_to_break_even 오류: {str(e)}"
        await send_telegram_message(error_msg, user_id, debug=True)
        log_error(
            error=e,
            user_id=user_id,
            additional_info={
                "function": "move_sl_to_break_even",
                "timestamp": datetime.now().isoformat()
            }
        )
        return None 

async def process_break_even_settings(user_id: int, symbol: str, order_type: str, position_data: dict):
    """
    TP 주문 체결 시 사용자 설정에 따라 브레이크이븐 처리를 수행합니다.
    """
    try:
        if not order_type.startswith('tp'):
            return False
            
        # TP 레벨 확인 (tp1, tp2, tp3)
        tp_level = int(order_type[2]) if len(order_type) > 2 and order_type[2].isdigit() else 1
        
        # 사용자 설정 가져오기
        settings = await get_user_settings(user_id) 
        dual_side_settings = await get_user_dual_side_settings(user_id)

        
        # 안전하게 값 처리
        use_break_even_tp1 = is_true_value(settings.get('use_break_even', False))
        use_break_even_tp2 = is_true_value(settings.get('use_break_even_tp2', False))
        use_break_even_tp3 = is_true_value(settings.get('use_break_even_tp3', False))
        
        dual_side_tp_type = dual_side_settings.get('dual_side_entry_tp_trigger_type', 'percent')
        dual_side_sl_type = dual_side_settings.get('dual_side_entry_sl_trigger_type', 'percent')
        dual_side_tp_value = dual_side_settings.get('dual_side_entry_tp_value', 10)
        dual_side_sl_value = dual_side_settings.get('dual_side_entry_sl_value', 10)
        dual_sl_on_tp = dual_side_sl_type == 'existing_position'
        use_dual_side = is_true_value(dual_side_settings.get('use_dual_side', False))
        
        
        # 포지션 정보 가져오기
        position_side = position_data.get('position_side', '')
        contracts_amount = float(position_data.get('contracts_amount', '0'))
        dual_side_position_side = None
        if use_dual_side:
            if position_side == 'long':
                dual_side_position_side = 'short'
            else:
                dual_side_position_side = 'long'
                
        position_key = f"user:{user_id}:position:{symbol}:{position_side}"
        full_position_data = await redis_client.hgetall(position_key)
        
        # 주문 가격 정보
        entry_price = float(full_position_data.get("entry_price", 0))
        contracts_amount = float(full_position_data.get("contracts_amount", 0))
        # TP 데이터 가져오기
        tp_data_str = full_position_data.get("tp_data", "{}")
        try:
            tp_data = json.loads(tp_data_str)
        except json.JSONDecodeError:
            tp_data = []
        # TP 레벨에 따른 브레이크이븐 적용
        
        try:
            if dual_side_tp_type == 'existing_position':
                if int(dual_side_tp_value) == tp_level:
                    close_request = ClosePositionRequest(
                        close_type="market",
                        close_percent=100
                    )
                    await close_position(
                        symbol=symbol,
                        close_request=close_request,
                        user_id=user_id,
                        side=dual_side_position_side
                    )
                    await send_telegram_message(
                        f"✅양방향 포지션 종료\n" +
                        f"━━━━━━━━━━━━━━━━\n" +
                        f"메인 포지션의 TP{tp_level} 체결로 양방향 포지션 종료\n" +
                        f"• 방향: {dual_side_position_side}\n" +
                        f"━━━━━━━━━━━━━━━━\n",
                        user_id)
        except Exception as e:
            logger.error(f"양방향 포지션 종료 실패!: {str(e)}")
            await send_telegram_message(f"양방향 포지션 종료 실패! {str(e)}", user_id, debug=True)
        
        
        if tp_level == 1 and use_break_even_tp1:
            #await send_telegram_message(f"TP1 브레이크이븐 확인. [DEBUG] TP1 체결: SL을 브레이크이븐({entry_price})으로 이동합니다.", user_id, debug = True)
            # TP1 체결 시 진입가(브레이크이븐)으로 SL 이동
            print(f"entry_price: {entry_price}, contracts_amount: {contracts_amount}")
            if entry_price > 0 and contracts_amount > 0:
                logger.info(f"TP1 체결: SL을 브레이크이븐({entry_price})으로 이동합니다.")
                return await move_sl_to_break_even(
                    user_id=user_id,
                    symbol=symbol,
                    side=position_side,
                    break_even_price=entry_price,
                    contracts_amount=contracts_amount,
                    tp_index=tp_level,
                )
            else:
                await send_telegram_message(f"오류. {entry_price}, {contracts_amount}\n아마 포지션이 이미 없는 경우.", user_id, debug = True)
                
        elif tp_level == 2 and use_break_even_tp2:
            # TP2 체결 시 TP1 가격으로 SL 이동
            if isinstance(tp_data, list):
                tp1_price = next((float(tp.get('price', 0)) for tp in tp_data 
                            if tp.get('level') == 1), None)
                if tp1_price and tp1_price > 0 and contracts_amount > 0:
                    logger.info(f"TP2 체결: SL을 TP1 가격({tp1_price})으로 이동합니다.")
                    return await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=position_side,
                        break_even_price=tp1_price,
                        contracts_amount=contracts_amount,
                        tp_index=tp_level
                    )
            
        elif tp_level == 3 and use_break_even_tp3:
            # TP3 체결 시 TP2 가격으로 SL 이동
            if isinstance(tp_data, list):
                tp2_price = next((float(tp.get('price', 0)) for tp in tp_data 
                            if tp.get('level') == 2), None)
                if tp2_price and tp2_price > 0 and contracts_amount > 0:
                    logger.info(f"TP3 체결: SL을 TP2 가격({tp2_price})으로 이동합니다.")
                    return await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=position_side,
                        break_even_price=tp2_price,
                        contracts_amount=contracts_amount,
                        tp_index=tp_level
                    )
                
        # TP 체결 시 트레일링 스탑 활성화 여부 확인 (사용자 설정에 따라)
        # 문자열과 불리언 모두 처리
        trailing_stop_active = is_true_value(settings.get('trailing_stop_active', False))
        
        # 문자열 값 처리
        trailing_start_point = str(settings.get('trailing_start_point', 'tp3')).lower()
        current_tp = f"tp{tp_level}"
        
        # 사용자 설정의 시작점에 도달했는지 확인
        if trailing_stop_active and current_tp.lower() == trailing_start_point:
            logger.info(f"{current_tp.upper()} 체결: 트레일링 스탑 활성화 조건 충족")
            await activate_trailing_stop(user_id, symbol, position_side, full_position_data, tp_data)
        
        return False
    except Exception as e:
        logger.error(f"브레이크이븐 처리 중 오류: {str(e)}")
        traceback.print_exc()
        return False

async def activate_trailing_stop(user_id: int, symbol: str, direction: str, position_data: dict, tp_data: list = None):
    """
    TP3 도달 시 트레일링 스탑 활성화
    """
    try:
        # 사용자 설정 가져오기
        settings = await get_user_settings(user_id) 
        use_trailing_stop = is_true_value(settings.get('trailing_stop_active', False))
        logger.info(f"[{user_id}] 트레일링 스탑 활성화 여부: {use_trailing_stop}")
        if not use_trailing_stop:
            logger.info(f"트레일링 스탑 기능이 비활성화되어 있습니다. (user_id: {user_id})")
            return
        
        
            
        # 트레일링 스탑 오프셋 값 계산
        use_tp2_tp3_diff = is_true_value(settings.get('use_trailing_stop_value_with_tp2_tp3_difference', False))
        trailing_offset = float(settings.get('trailing_stop_offset_value', '0.5'))
        logger.info(f"[{user_id}] 트레일링 스탑 오프셋 값: {trailing_offset}")
        if use_tp2_tp3_diff and tp_data:
            # TP2와 TP3 가격 차이로 오프셋 계산
            if isinstance(tp_data, list):
                tp2_price = next((float(tp.get('price', 0)) for tp in tp_data 
                             if tp.get('level') == 2), None)
                tp3_price = next((float(tp.get('price', 0)) for tp in tp_data 
                             if tp.get('level') == 3), None)
                
                if tp2_price and tp3_price:
                    if direction == "long":
                        trailing_offset = abs(tp3_price - tp2_price)
                    else:  # short
                        trailing_offset = abs(tp2_price - tp3_price)
                    logger.info(f"[{user_id}] TP2-TP3 가격 차이를 트레일링 스탑 오프셋으로 사용: {trailing_offset}")
        
        # 현재 가격 조회
        async with get_exchange_context(str(user_id)) as exchange:
            try:
                current_price = await get_current_price(symbol, "1m", exchange)
                
                if current_price <= 0:
                    logger.warning(f"현재가를 가져올 수 없습니다: {symbol}")
                    return
                    
                # 진입가 정보
                entry_price = float(position_data.get("avgPrice", 0))
                contracts_amount = float(position_data.get("contracts_amount", 0))
                
                # 트레일링 스탑 초기값 설정
                if direction == "long":
                    # 롱 포지션에서는 최고가 기준으로 추적
                    highest_price = current_price
                    trailing_stop_price = highest_price - trailing_offset
                else:  # short
                    # 숏 포지션에서는 최저가 기준으로 추적
                    lowest_price = current_price
                    trailing_stop_price = lowest_price + trailing_offset
                
                # 트레일링 스탑 전용 키 생성
                trailing_key = f"trailing:user:{user_id}:{symbol}:{direction}"
                
                # 트레일링 스탑 데이터 구성
                ts_data = {
                    "active": "true",
                    "user_id": str(user_id),
                    "symbol": symbol,
                    "direction": direction,
                    "entry_price": str(entry_price),
                    "contracts_amount": str(contracts_amount),
                    "trailing_offset": str(trailing_offset),
                    "highest_price": str(highest_price) if direction == "long" else "",
                    "lowest_price": str(lowest_price) if direction == "short" else "",
                    "trailing_stop_price": str(trailing_stop_price),
                    "start_time": str(int(datetime.now().timestamp())),
                    "leverage": position_data.get("leverage", "1"),
                    "sl_order_id": position_data.get("sl_order_id", "")
                }
                
                # 트레일링 키에 데이터 저장
                await redis_client.hset(trailing_key, mapping=ts_data)
                
                # 트레일링 키 만료 시간 설정 (7일 - 안전장치)
                await redis_client.expire(trailing_key, 60 * 60 * 24 * 7)
                
                # 기존 포지션 키에도 트레일링 활성화 정보 저장 (포지션이 남아있는 경우만)
                position_key = f"user:{user_id}:position:{symbol}:{direction}"
                position_exists = await redis_client.exists(position_key)
                
                if position_exists:
                    # SL 가격 업데이트
                    await redis_client.hset(position_key, "sl_price", trailing_stop_price)
                    await redis_client.hset(position_key, "trailing_stop_active", "true")
                    await redis_client.hset(position_key, "trailing_stop_key", trailing_key)
                
                # SL 주문 업데이트 시도
                try:
                    await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=direction,
                        break_even_price=trailing_stop_price,
                        contracts_amount=contracts_amount,
                        tp_index=0  # 트레일링 스탑은 TP 인덱스 0으로 표시
                    )
                except Exception as e:
                    logger.error(f"SL 주문 업데이트 실패: {str(e)}")
                
                try:
                    log_order(
                        user_id=user_id,
                        symbol=symbol,
                        action_type='trailing_stop_activation',
                        position_side=direction,
                        price=current_price,
                    trailing_offset=trailing_offset,
                    trailing_stop_price=trailing_stop_price,
                    highest_price=highest_price if direction == "long" else None,
                    lowest_price=lowest_price if direction == "short" else None,
                    entry_price=entry_price,
                    contracts_amount=contracts_amount
                )
                except Exception as e:
                    logger.error(f"트레일링 스탑 로깅 실패: {str(e)}")
                
                
                # 알림 전송
                message = (
                    f"🔹 트레일링 스탑 활성화\n"
                    f"━━━━━━━━━━━━━━━\n"
                    f"심볼: {symbol}\n"
                    f"방향: {'🟢 롱' if direction == 'long' else '🔴 숏'}\n"
                    f"현재가: {current_price:.2f}\n"
                    f"트레일링 오프셋: {trailing_offset:.2f}\n"
                    f"초기 스탑 가격: {trailing_stop_price:.2f}\n"
                )
                await send_telegram_message(message, user_id)
                
                logger.info(f"트레일링 스탑 활성화 완료 - 사용자:{user_id}, 심볼:{symbol}, 방향:{direction}, 키:{trailing_key}")
                
                return trailing_key
            except Exception as e:
                logger.error(f"트레일링 스탑 활성화 중 오류: {str(e)}")
                return None
    except Exception as e:
        logger.error(f"트레일링 스탑 활성화 오류: {str(e)}")
        traceback.print_exc()
        return None

async def check_trailing_stop(user_id: int, symbol: str, direction: str, current_price: float):
    """
    트레일링 스탑 업데이트 및 체크
    """
    try:
        # 트레일링 스탑 전용 키 확인
        trailing_key = f"trailing:user:{user_id}:{symbol}:{direction}"
        
        # 트레일링 스탑 키가 존재하는지 확인
        if not await redis_client.exists(trailing_key):
            # 포지션 키에서 트레일링 스탑 활성화 정보 확인 (레거시 지원)
            position_key = f"user:{user_id}:position:{symbol}:{direction}"
            
            try:
                # 키 타입 확인
                key_type = await redis_client.type(position_key)
                
                # 해시 타입인지 확인 - 문자열로 변환하여 비교
                if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                    # 정상적인 해시 타입인 경우
                    position_data = await redis_client.hgetall(position_key)
                else:
                    # 다른 타입이거나 키가 없는 경우
                    logger.warning(f"포지션 데이터가 해시 타입이 아닙니다. (key: {position_key}, 타입: {key_type})")
                    position_data = {}
            except Exception as redis_error:
                logger.error(f"Redis 포지션 데이터 조회 중 오류: {str(redis_error)}")
                position_data = {}
            
            trailing_stop_active = is_true_value(position_data.get("trailing_stop_active", False))
            
            if not position_data or not trailing_stop_active:
                return False
        
        # 트레일링 스탑 데이터 조회
        try:
            # 키 타입 확인
            key_type = await redis_client.type(trailing_key)
            
            # 해시 타입인지 확인 - 문자열로 변환하여 비교
            if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                # 정상적인 해시 타입인 경우
                ts_data = await redis_client.hgetall(trailing_key)
            else:
                # 다른 타입이거나 키가 없는 경우
                logger.warning(f"트레일링 스탑 데이터가 해시 타입이 아닙니다. (key: {trailing_key}, 타입: {key_type})")
                return False
        except Exception as redis_error:
            logger.error(f"Redis 트레일링 스탑 데이터 조회 중 오류: {str(redis_error)}")
            return False
        
        if not ts_data or not ts_data.get("active", False):
            # 비활성화된 트레일링 스탑은 삭제
            await redis_client.delete(trailing_key)
            return False
            
        # 기본 정보
        trailing_offset = float(ts_data.get("trailing_offset", 0))
        contracts_amount = float(ts_data.get("contracts_amount", 0))
        
        # 트레일링 스탑 업데이트 여부
        updated = False
        
        if direction == "long":
            highest_price = float(ts_data.get("highest_price", 0))
            
            # 새로운 최고가 갱신 시
            if current_price > highest_price:
                highest_price = current_price
                trailing_stop_price = highest_price - trailing_offset
                
                # 트레일링 스탑 키 업데이트
                await redis_client.hset(trailing_key, "highest_price", str(highest_price))
                await redis_client.hset(trailing_key, "trailing_stop_price", str(trailing_stop_price))
                await redis_client.hset(trailing_key, "last_updated", str(int(datetime.now().timestamp())))
                
                # 포지션 키가 존재하면 함께 업데이트
                position_key = f"user:{user_id}:position:{symbol}:{direction}"
                if await redis_client.exists(position_key):
                    try:
                        # 키 타입 확인
                        key_type = await redis_client.type(position_key)
                        # 해시 타입인지 확인 - 문자열로 변환하여 비교
                        if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                            await redis_client.hset(position_key, "sl_price", str(trailing_stop_price))
                        else:
                            logger.warning(f"포지션 데이터가 해시 타입이 아니라 SL 가격 업데이트를 건너뜁니다. (key: {position_key})")
                    except Exception as redis_error:
                        logger.error(f"포지션 SL 가격 업데이트 중 오류: {str(redis_error)}")
                
                updated = True
                
                # 1시간에 한 번 정도만 SL 주문 업데이트 (너무 잦은 업데이트 방지)
                # 마지막 SL 업데이트 시간 확인
                last_sl_update = float(ts_data.get("last_sl_update", "0"))
                current_time = datetime.now().timestamp()
                
                if current_time - last_sl_update > 3600:  # 1시간(3600초) 간격
                    # SL 주문 API 업데이트 
                    await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=direction,
                        break_even_price=trailing_stop_price,
                        contracts_amount=contracts_amount,
                        tp_index=0
                    )
                    
                    # 마지막 SL 업데이트 시간 기록
                    await redis_client.hset(trailing_key, "last_sl_update", str(current_time))
                
                logger.info(f"트레일링 스탑 업데이트 (롱) - 사용자:{user_id}, 심볼:{symbol}, "
                           f"새 최고가:{highest_price:.2f}, 새 스탑:{trailing_stop_price:.2f}")
            
            # 현재가가 트레일링 스탑 가격 아래로 떨어졌는지 체크 (종료 조건)
            trailing_stop_price = float(ts_data.get("trailing_stop_price", 0))
            if current_price <= trailing_stop_price:
                # 트레일링 스탑 알림
                # 포지션 종료

                
                await send_telegram_message(
                    f"⚠️ 트레일링 스탑 가격({trailing_stop_price:.2f}) 도달\n"
                    f"━━━━━━━━━━━━━━━\n"
                    f"현재가: {current_price:.2f}\n"
                    f"포지션: {symbol} {direction.upper()}\n",
                    user_id
                )
                
                close_request = ClosePositionRequest('market', current_price, 100)
                
                
                await close_position(symbol = symbol, close_request = close_request, user_id = user_id, side = direction)
                await clear_trailing_stop(user_id, symbol, direction)
                
                
                # 트레일링 스탑 키에 조건 충족 상태 기록
                await redis_client.hset(trailing_key, "status", "triggered")
                await redis_client.hset(trailing_key, "trigger_price", str(current_price))
                await redis_client.hset(trailing_key, "trigger_time", str(int(datetime.now().timestamp())))
                
                # 트레일링 스탑 실행 로깅
                try:
                    position_key = f"user:{user_id}:position:{symbol}:{direction}"
                    position_data = await redis_client.hgetall(position_key)
                    position_size = float(position_data.get("size", "0")) if position_data else 0
                    
                    log_order(
                        user_id=user_id,
                        symbol=symbol,
                        action_type='trailing_stop_execution',
                        position_side=direction,
                        price=current_price,
                        quantity=position_size,
                        trailing_stop_price=trailing_stop_price,
                        highest_price=float(ts_data.get("highest_price", "0")) if direction == "short" else None,
                        lowest_price=float(ts_data.get("lowest_price", "0")) if direction == "long" else None,
                        trailing_offset=trailing_offset
                    )
                except Exception as e:
                    logger.error(f"트레일링 스탑 로깅 실패: {str(e)}")
                
                return True  # 트레일링 스탑 조건 충족
        
        else:  # short
            lowest_price = float(ts_data.get("lowest_price", float('inf')))
            
            # 새로운 최저가 갱신 시
            if current_price < lowest_price:
                lowest_price = current_price
                trailing_stop_price = lowest_price + trailing_offset
                
                # 트레일링 스탑 키 업데이트
                await redis_client.hset(trailing_key, "lowest_price", str(lowest_price))
                await redis_client.hset(trailing_key, "trailing_stop_price", str(trailing_stop_price))
                await redis_client.hset(trailing_key, "last_updated", str(int(datetime.now().timestamp())))
                
                # 포지션 키가 존재하면 함께 업데이트
                position_key = f"user:{user_id}:position:{symbol}:{direction}"
                if await redis_client.exists(position_key):
                    try:
                        # 키 타입 확인
                        key_type = await redis_client.type(position_key)
                        # 해시 타입인지 확인 - 문자열로 변환하여 비교
                        if str(key_type).lower() == 'hash' or str(key_type).lower() == "b'hash'":
                            await redis_client.hset(position_key, "sl_price", str(trailing_stop_price))
                        else:
                            logger.warning(f"포지션 데이터가 해시 타입이 아니라 SL 가격 업데이트를 건너뜁니다. (key: {position_key})")
                    except Exception as redis_error:
                        logger.error(f"포지션 SL 가격 업데이트 중 오류: {str(redis_error)}")
                
                updated = True
                
                # 1시간에 한 번 정도만 SL 주문 업데이트 (너무 잦은 업데이트 방지)
                # 마지막 SL 업데이트 시간 확인
                last_sl_update = float(ts_data.get("last_sl_update", "0"))
                current_time = datetime.now().timestamp()
                
                if current_time - last_sl_update > 3600:  # 1시간(3600초) 간격
                    # SL 주문 API 업데이트
                    await move_sl_to_break_even(
                        user_id=user_id,
                        symbol=symbol,
                        side=direction,
                        break_even_price=trailing_stop_price,
                        contracts_amount=contracts_amount,
                        tp_index=0
                    )
                    
                    # 마지막 SL 업데이트 시간 기록
                    await redis_client.hset(trailing_key, "last_sl_update", str(current_time))
                
                logger.info(f"트레일링 스탑 업데이트 (숏) - 사용자:{user_id}, 심볼:{symbol}, "
                           f"새 최저가:{lowest_price:.2f}, 새 스탑:{trailing_stop_price:.2f}")
            
            # 현재가가 트레일링 스탑 가격 위로 올라갔는지 체크 (종료 조건)
            trailing_stop_price = float(ts_data.get("trailing_stop_price", float('inf')))
            if current_price >= trailing_stop_price:
                # 트레일링 스탑 알림
                await send_telegram_message(
                    f"⚠️ 트레일링 스탑 가격({trailing_stop_price:.2f}) 도달\n"
                    f"━━━━━━━━━━━━━━━\n"
                    f"현재가: {current_price:.2f}\n"
                    f"포지션: {symbol} {direction.upper()}\n"
                    f"트레일링 오프셋: {trailing_offset:.2f}",
                    user_id
                )
                
                close_request = ClosePositionRequest('market', current_price, 100)
                
                await close_position(symbol = symbol, close_request = close_request, user_id = user_id, side = direction)
                await clear_trailing_stop(user_id, symbol, direction)
                
                # 트레일링 스탑 키에 조건 충족 상태 기록
                await redis_client.hset(trailing_key, "status", "triggered")
                await redis_client.hset(trailing_key, "trigger_price", str(current_price))
                await redis_client.hset(trailing_key, "trigger_time", str(int(datetime.now().timestamp())))
                
                # 트레일링 스탑 실행 로깅
                try:
                    position_key = f"user:{user_id}:position:{symbol}:{direction}"
                    position_data = await redis_client.hgetall(position_key)
                    position_size = float(position_data.get("size", "0")) if position_data else 0
                    
                    log_order(
                        user_id=user_id,
                        symbol=symbol,
                        action_type='trailing_stop_execution',
                        position_side=direction,
                        price=current_price,
                        quantity=position_size,
                        trailing_stop_price=trailing_stop_price,
                        highest_price=float(ts_data.get("highest_price", "0")) if direction == "short" else None,
                        lowest_price=float(ts_data.get("lowest_price", "0")) if direction == "long" else None,
                        trailing_offset=trailing_offset
                    )
                except Exception as e:
                    logger.error(f"트레일링 스탑 로깅 실패: {str(e)}")
                
                return True  # 트레일링 스탑 조건 충족
        
        return False  # 트레일링 스탑 조건 미충족
        
    except Exception as e:
        logger.error(f"트레일링 스탑 체크 오류: {str(e)}")
        traceback.print_exc()
        return False

async def clear_trailing_stop(user_id: int, symbol: str, direction: str):

    try:
        # 트레일링 스탑 키 삭제
        trailing_key = f"trailing:user:{user_id}:{symbol}:{direction}"
        await redis_client.delete(trailing_key)
        
        # 포지션 키가 있으면 트레일링 스탑 관련 필드도 리셋
        position_key = f"user:{user_id}:position:{symbol}:{direction}"
        if await redis_client.exists(position_key):
            await redis_client.hset(position_key, "trailing_stop_active", "false")
            await redis_client.hdel(position_key, "trailing_stop_key")
            
        logger.info(f"트레일링 스탑 데이터 삭제 완료: {trailing_key}")
        return True
    except Exception as e:
        logger.error(f"트레일링 스탑 데이터 삭제 오류: {str(e)}")
        return False

async def get_active_trailing_stops() -> List[Dict]:

    try:
        trailing_keys = await redis_client.keys("trailing:user:*")
        trailing_stops = []
        for key in trailing_keys:
            data = await redis_client.hgetall(key)
            if data and data.get("active", "false").lower() == "true":
                # key 구조: trailing:user:{user_id}:{symbol}:{direction}
                parts = key.split(":")
                if len(parts) >= 5:
                    data["user_id"] = parts[2]
                    data["symbol"] = parts[3]
                    data["direction"] = parts[4]
                    trailing_stops.append(data)
        
        return trailing_stops
    except Exception as e:
        logger.error(f"활성 트레일링 스탑 조회 실패: {str(e)}")
        return []

async def check_position_exists(user_id: int, symbol: str, direction: str) -> bool:
    """
    특정 방향의 포지션이 존재하는지 확인합니다.
    
    Args:
        user_id: 사용자 ID
        symbol: 심볼
        direction: 포지션 방향 ('long' 또는 'short')
        
    Returns:
        bool: 포지션이 존재하면 True, 아니면 False
    """
    try:
        from src.trading.trading_service import TradingService
        trading_service = TradingService()
        
        # 포지션 조회
        positions = await trading_service.fetch_okx_position(str(user_id), symbol)
        
        # 포지션 데이터 확인
        if not positions:
            logger.info(f"사용자 {user_id}의 {symbol} 포지션이 없습니다.")
            return False
            
        # 특정 방향의 포지션이 있는지 확인
        for pos in positions.values() if isinstance(positions, dict) else [positions]:
            pos_side = pos.get('pos_side', '').lower()
            if pos_side == '':
                pos_side = pos.get('side', '').lower()
                
            if pos_side == direction:
                contracts = float(pos.get('contracts_amount', pos.get('size', '0')))
                if contracts > 0:
                    logger.info(f"사용자 {user_id}의 {symbol} {direction} 포지션 있음: {contracts} 계약")
                    return True
                    
        # 해당 방향의 포지션이 없음
        logger.info(f"사용자 {user_id}의 {symbol} {direction} 포지션이 없습니다.")
        return False
    except Exception as e:
        logger.error(f"포지션 확인 중 오류: {str(e)}")
        traceback.print_exc()
        # 오류 발생 시 기본값으로 포지션 있음 반환 (안전하게)
        return True

async def check_and_cleanup_orders(user_id: int, symbol: str, direction: str):
    """
    포지션이 없을 때 해당 방향의 모든 주문을 확인하고 모니터링 데이터를 정리합니다.
    
    Args:
        user_id: 사용자 ID
        symbol: 심볼
        direction: 포지션 방향 ('long' 또는 'short')
    """
    try:
        # 포지션 존재 여부 확인
        position_exists = await check_position_exists(user_id, symbol, direction)
        
        if position_exists:
            # 포지션이 있으면 아무 작업도 하지 않음
            return
            
        # 포지션이 없으면 해당 방향의 모든 주문 확인
        logger.info(f"사용자 {user_id}의 {symbol} {direction} 포지션이 없어 모니터링 데이터 정리 시작")
        position_key = f"user:{user_id}:position:{symbol}:{direction}"

        # 1. 해당 방향의 모니터링 중인 모든 주문 가져오기
        pattern = f"monitor:user:{user_id}:{symbol}:order:*"
        order_keys = await redis_client.keys(pattern)
        orders_to_check = []
        
        for key in order_keys:
            order_data = await redis_client.hgetall(key)
            if not order_data:
                continue
                
            # 해당 방향의 주문만 필터링
            if order_data.get("position_side", "").lower() == direction.lower():
                # key에서 order_id 추출 - monitor:user:{user_id}:{symbol}:order:{order_id}
                parts = key.split(":")
                if len(parts) >= 6:
                    order_id = parts[5]
                    order_data["order_id"] = order_id
                    order_data["symbol"] = symbol
                    orders_to_check.append(order_data)
        
        # 주문이 없으면 트레일링 스탑만 정리
        if not orders_to_check:
            logger.info(f"사용자 {user_id}의 {symbol} {direction} 방향의 모니터링 주문이 없습니다.")
            # 트레일링 스탑 정리
            await clear_trailing_stop(user_id, symbol, direction)
            return
            
        # 2. 각 주문의 상태 확인
        logger.info(f"사용자 {user_id}의 {symbol} {direction} 방향의 {len(orders_to_check)}개 주문 상태 확인")
        
        for order_data in orders_to_check:
            order_id = order_data.get("order_id")
            order_type = order_data.get("order_type", "")
            
            # 주문이 이미 완료 상태면 건너뜀
            if order_data.get("status", "") != "open":
                continue
                
            # 주문 상태 확인
            order_status = await check_order_status(
                user_id=user_id,
                symbol=symbol,
                order_id=order_id,
                order_type=order_type
            )
            
            # 주문 상태 업데이트
            if isinstance(order_status, dict):
                status = "canceled"  # 기본값은 취소됨
                filled_sz = "0"
                
                # OrderResponse 형식 (get_order_detail 결과)
                if 'status' in order_status:
                    if order_status['status'] in ['FILLED', 'CLOSED', 'filled', 'closed']:
                        status = 'filled'
                        filled_sz = order_status.get('filled_amount', order_status.get('amount', '0'))
                    elif order_status['status'] in ['CANCELED', 'canceled']:
                        status = 'canceled'
                        filled_sz = order_status.get('filled_amount', '0')
                    else:
                        status = 'canceled'  # 포지션이 없으므로 남은 주문은 취소로 처리
                        filled_sz = order_status.get('filled_amount', '0')
                # OKX API 응답 (알고리즘 주문)
                elif 'state' in order_status:
                    state = order_status.get('state')
                    filled_sz = order_status.get('accFillSz', '0')
                    
                    # 상태 매핑
                    status_mapping = {
                        'filled': 'filled',
                        'effective': 'canceled',  # 포지션이 없으므로 활성 주문도 취소로 처리
                        'canceled': 'canceled',
                        'order_failed': 'failed'
                    }
                    status = status_mapping.get(state, 'canceled')
                
                # TP 주문이 체결된 경우 브레이크이븐/트레일링스탑 처리
                if status == 'filled' and order_type.startswith('tp'):
                    logger.info(f"[{user_id}] TP 주문 체결됨: {order_id}({order_type})")
                    try:
                       
                        # 사용자 설정에 따른 브레이크이븐/트레일링스탑 처리
                        await process_break_even_settings(
                            user_id=user_id,
                            symbol=symbol,
                            order_type=order_type,
                            position_data=order_data
                        )
                    except Exception as be_error:
                        logger.error(f"브레이크이븐/트레일링스탑 처리 실패: {str(be_error)}")
                
                # 주문 상태 업데이트
                await update_order_status(
                    user_id=user_id,
                    symbol=symbol,
                    order_id=order_id,
                    status=status,
                    filled_amount=str(filled_sz)
                )
                
                
                
                # SL 주문이 체결된 경우, 관련 트레일링 스탑 데이터 정리
                if status == 'filled' and order_type == 'sl':
                    logger.info(f"[{user_id}] SL 주문 체결됨: {order_id}({order_type})")
                    await clear_trailing_stop(user_id, symbol, direction)
                    
                    # SL 주문 체결 로깅
                    price = float(order_data.get("price", "0"))
                    filled_amount = float(filled_sz) if filled_sz else 0
                    
                    # SL 주문 체결 로깅
                    try:
                        log_order(
                            user_id=user_id,
                            symbol=symbol,
                            action_type='sl_execution',
                            position_side=direction,
                            price=price,
                        quantity=filled_amount,
                            order_id=order_id,
                            current_price=price
                        )
                    except Exception as e:
                        logger.error(f"SL 주문 체결 로깅 실패: {str(e)}")
                
                # 체결됐으면 알림 발송
                if status == 'filled':
                    logger.info(f"포지션이 없지만 주문 {order_id}({order_type})이 체결됨을 발견")
            else:
                # 상태를 알 수 없는 경우 취소로 처리
                status = 'canceled'
                filled_sz = '0'
                
                # 주문 상태 업데이트
                await update_order_status(
                    user_id=user_id,
                    symbol=symbol,
                    order_id=order_id,
                    status=status,
                    filled_amount=str(filled_sz)
                )
        
        # 3. 트레일링 스탑 정리
        await clear_trailing_stop(user_id, symbol, direction)
        
        # 4. 포지션 데이터 정리
        position_key = f"user:{user_id}:position:{symbol}:{direction}"
        if await redis_client.exists(position_key):
            logger.info(f"포지션이 없어 Redis에서 포지션 데이터 삭제: {position_key}")
            await redis_client.delete(position_key)
            
        logger.info(f"사용자 {user_id}의 {symbol} {direction} 모니터링 데이터 정리 완료")
    except Exception as e:
        logger.error(f"주문 정리 중 오류: {str(e)}")
        traceback.print_exc()

async def should_check_tp_order(order_data: Dict, current_price: float) -> bool:
    """
    TP 주문을 확인해야 하는지 결정합니다.
    
    Args:
        order_data: 주문 데이터
        current_price: 현재 가격
        
    Returns:
        bool: 주문을 확인해야 하는 경우 True
    """
    order_type = order_data.get("order_type", "")
    position_side = order_data.get("position_side", "")
    tp_price = float(order_data.get("price", "0"))
    
    if not order_type.startswith("tp") or tp_price <= 0:
        return False
        
    # Long 포지션: 현재가가 TP보다 높으면 확인
    if position_side == "long" and current_price >= tp_price:
        return True
    # Short 포지션: 현재가가 TP보다 낮으면 확인
    elif position_side == "short" and current_price <= tp_price:
        return True
        
    return False

async def should_check_sl_order(order_data: Dict, current_price: float) -> bool:
    """
    SL 주문을 확인해야 하는지 결정합니다.
    
    Args:
        order_data: 주문 데이터
        current_price: 현재 가격
        
    Returns:
        bool: 주문을 확인해야 하는 경우 True
    """
    order_type = order_data.get("order_type", "")
    position_side = order_data.get("position_side", "")
    sl_price = float(order_data.get("price", "0"))
    
    if order_type != "sl" or sl_price <= 0:
        return False
        
    # Long 포지션: 현재가가 SL보다 낮으면 확인
    if position_side == "long" and current_price <= sl_price:
        
        symbol = order_data.get("symbol", "")
        user_id = order_data.get("user_id", "")
        direction = order_data.get("position_side", "")
        
        
        close_request = ClosePositionRequest(
            close_type="market",
            price=current_price,
            close_percent=100
        )

        await close_position(
            symbol=symbol,
            close_request=close_request,
            user_id=user_id,
            side=direction
        )
        
        return True
    # Short 포지션: 현재가가 SL보다 높으면 확인
    elif position_side == "short" and current_price >= sl_price:
        symbol = order_data.get("symbol", "")
        user_id = order_data.get("user_id", "")
        direction = order_data.get("position_side", "")
        
        
        close_request = ClosePositionRequest(
            close_type="market",
            price=current_price,
            close_percent=100
        )

        await close_position(
            symbol=symbol,
            close_request=close_request,
            user_id=user_id,
            side=direction
        )
        return True
        
    return False

async def monitor_orders_loop():
    """
    주문을 지속적으로 모니터링하는 무한 루프 함수
    """
    logger.info("주문 모니터링 서비스 시작")
    last_order_check_time = 0  # 마지막 주문 상태 전체 확인 시간
    last_position_check_time = 0  # 마지막 포지션 확인 시간
    last_memory_cleanup_time = 0  # 마지막 메모리 정리 시간
    last_memory_check_time = 0    # 마지막 메모리 체크 시간
    last_algo_cancel_time = 0     # 마지막 알고리즘 주문 취소 시간
    POSITION_CHECK_INTERVAL = 60  # 포지션 확인 간격(초)
    MEMORY_CHECK_INTERVAL = 60    # 메모리 체크 간격(초)
    ALGO_ORDER_CANCEL_INTERVAL = 300  # 알고리즘 주문 취소 간격(초, 5분)
    consecutive_errors = 0  # 연속 오류 카운터
    
    # API 속도 제한 관리
    api_call_timestamps = []
    
    while True:
        try:
            current_time = time.time()
            
            # 메모리 사용량 체크 (1분마다)
            if current_time - last_memory_check_time >= MEMORY_CHECK_INTERVAL:
                last_memory_check_time = current_time
                process = psutil.Process()
                memory_info = process.memory_info()
                memory_usage_mb = memory_info.rss / 1024 / 1024
                logger.info(f"현재 메모리 사용량: {memory_usage_mb:.2f} MB")
                
                # 메모리 사용량이 임계치를 초과하면 강제 정리
                if memory_usage_mb > MAX_MEMORY_MB:
                    logger.warning(f"메모리 사용량({memory_usage_mb:.2f} MB)이 제한({MAX_MEMORY_MB} MB)을 초과하여 강제 정리 수행")
                    # 가비지 컬렉션 강제 실행
                    gc.collect()
                    # Redis 연결 초기화
                    await redis_client.connection_pool.disconnect()
                    # 메모리 사용량 다시 계산
                    memory_info = process.memory_info()
                    logger.info(f"메모리 정리 후 사용량: {memory_info.rss / 1024 / 1024:.2f} MB")
            
            # 활성 사용자 목록 가져오기
            running_users = await get_all_running_users()
            last_active_users_num_logging = await redis_client.get(f"last_active_users_num_logging")
            if len(running_users) > 0 and last_active_users_num_logging is None:
                logger.info(f"[활성 사용자 수: {len(running_users)}]")
                await redis_client.set(f"last_active_users_num_logging", current_time)
            elif len(running_users) > 0 and last_active_users_num_logging is not None and abs(current_time - float(last_active_users_num_logging)) >= 60:
                logger.info(f"[활성 사용자 수: {len(running_users)}]")
                await redis_client.set(f"last_active_users_num_logging", current_time)
            
            # 주문 강제 확인 여부 (15초마다)
            force_check_orders = current_time - last_order_check_time >= ORDER_CHECK_INTERVAL
            if force_check_orders:
                #logger.info(f"정기 주문 상태 확인 시작 (간격: {ORDER_CHECK_INTERVAL}초)")
                last_order_check_time = current_time
            
            # 포지션 확인 여부 (60초마다)
            force_check_positions = current_time - last_position_check_time >= POSITION_CHECK_INTERVAL
            if force_check_positions:
                #logger.info(f"정기 포지션 확인 시작 (간격: {POSITION_CHECK_INTERVAL}초)")
                last_position_check_time = current_time
            
            # 알고리즘 주문 취소 여부 (5분마다)
            force_cancel_algo_orders = current_time - last_algo_cancel_time >= ALGO_ORDER_CANCEL_INTERVAL
            if force_cancel_algo_orders:
                logger.info(f"알고리즘 주문 취소 확인 시작 (간격: {ALGO_ORDER_CANCEL_INTERVAL}초)")
                last_algo_cancel_time = current_time
                
                # 5분마다 모든 사용자에 대해 포지션 없는 방향의 알고리즘 주문 취소
                for user_id in running_users:
                    # 각 사용자에 대해 포지션이 없는 방향의 알고리즘 주문 취소 함수 호출
                    asyncio.create_task(cancel_algo_orders_for_no_position_sides(user_id))
            
            # 먼저 모든 활성 트레일링 스탑 체크 (독립적인 트레일링 스탑)
            active_trailings = await get_active_trailing_stops()
            if len(active_trailings) > 0:
                logger.info(f"활성 트레일링 스탑 수: {len(active_trailings)}")
                for ts_data in active_trailings:
                    try:
                        user_id = int(ts_data.get("user_id", "0"))
                        symbol = ts_data.get("symbol", "")
                        direction = ts_data.get("direction", "")
                        
                        if not (user_id and symbol and direction) or user_id not in running_users:
                            continue
                        
                        # 현재가 조회
                        async with get_exchange_context(str(user_id)) as exchange:
                            try:
                                current_price = await get_current_price(symbol, "1m", exchange)
                                
                                if current_price <= 0:
                                    logger.warning(f"[트레일링] 유효하지 않은 현재가: {current_price}, 심볼: {symbol}")
                                    continue
                                
                                # 트레일링 스탑 조건 체크
                                ts_hit = await check_trailing_stop(user_id, symbol, direction, current_price)
                                
                                # 트레일링 스탑 조건 충족 시
                                if ts_hit:
                                    # SL 주문 ID 확인
                                    
                                    
                                    close_request = ClosePositionRequest(
                                        close_type="market",
                                        price=current_price,
                                        close_percent=100
                                    )
                                    
                                    await close_position(
                                        symbol=symbol,
                                        close_request=close_request,
                                        user_id=user_id,
                                        side=direction
                                    )
                                    
                                    sl_order_id = ts_data.get("sl_order_id", "")
                                    
                                    
                                    
                                    if sl_order_id:
                                        # SL 주문 상태 확인
                                        logger.info(f"[트레일링] SL 주문 상태 확인: {sl_order_id}")
                                        sl_status = await check_order_status(
                                            user_id=user_id,
                                            symbol=symbol,
                                            order_id=sl_order_id,
                                            order_type="sl"
                                        )
                                        
                                        # SL 주문이 체결되었는지 확인
                                        if isinstance(sl_status, dict) and sl_status.get('status') in ['FILLED', 'CLOSED', 'filled', 'closed']:
                                            logger.info(f"[트레일링] SL 주문 체결됨: {sl_order_id}")
                                            # 트레일링 스탑 데이터 삭제
                                            await clear_trailing_stop(user_id, symbol, direction)
                                        elif isinstance(sl_status, dict) and sl_status.get('status') in ['CANCELED', 'canceled']:
                                            # SL 주문이 취소된 경우 트레일링 스탑 데이터 삭제
                                            logger.info(f"[트레일링] SL 주문 취소됨: {sl_order_id}")
                                            await clear_trailing_stop(user_id, symbol, direction)
                                    else:
                                        # SL 주문 ID가 없는 경우 (포지션 자체 확인)
                                        position_exists = await check_position_exists(user_id, symbol, direction)
                                        
                                        if not position_exists:
                                            # 포지션이 없으면 트레일링 스탑 데이터 삭제
                                            logger.info(f"[트레일링] 포지션 없음, 트레일링 스탑 삭제: {user_id}:{symbol}:{direction}")
                                            await clear_trailing_stop(user_id, symbol, direction)
                            except Exception as e:
                                logger.error(f"트레일링 스탑 현재가 조회 오류: {str(e)}")
                    except Exception as ts_error:
                        logger.error(f"트레일링 스탑 처리 중 오류: {str(ts_error)}")
                        traceback.print_exc()
            
            
            
                
            # 메모리 정리 실행 (10분마다)
            force_memory_cleanup = current_time - last_memory_cleanup_time >= MEMORY_CLEANUP_INTERVAL
            if force_memory_cleanup:
                logger.info(f"메모리 정리 시작 (간격: {MEMORY_CLEANUP_INTERVAL}초)")
                last_memory_cleanup_time = current_time
                # 메모리 사용량 로깅
                process = psutil.Process()
                memory_info = process.memory_info()
                logger.info(f"현재 메모리 사용량: {memory_info.rss / 1024 / 1024:.2f} MB")
                # 가비지 컬렉션 강제 실행
                gc.collect()
                # Redis 연결 풀 정리
                await redis_client.connection_pool.disconnect()
                
                # 주문 상태 캐시 정리
                current_time_cleanup = time.time()
                expired_keys = [k for k, (t, _) in order_status_cache.items() if current_time_cleanup - t > ORDER_STATUS_CACHE_TTL]
                for key in expired_keys:
                    del order_status_cache[key]
                logger.info(f"주문 상태 캐시 정리 완료: {len(expired_keys)}개 항목 제거, 현재 {len(order_status_cache)}개 항목 유지")
                
                # 추가 메모리 정리: 만료된 거래 데이터 정리
                try:
                    # 2주 이상 지난 완료된 주문 데이터 삭제
                    two_weeks_ago = int((datetime.now() - timedelta(days=14)).timestamp())
                    pattern = "completed:user:*:order:*"
                    old_order_keys = await redis_client.keys(pattern)
                    
                    for key in old_order_keys:
                        try:
                            order_data = await redis_client.hgetall(key)
                            last_updated = int(order_data.get("last_updated_time", "0"))
                            if last_updated < two_weeks_ago:
                                logger.info(f"오래된 완료 주문 데이터 삭제: {key}")
                                await redis_client.delete(key)
                        except Exception as e:
                            logger.error(f"완료 주문 데이터 삭제 중 오류: {str(e)}")
                            continue
                except Exception as e:
                    logger.error(f"만료된 데이터 정리 중 오류: {str(e)}")
                
            # API 호출 속도 제한 관리
            current_time_ms = time.time()
            # 1초 이내의 API 호출만 유지
            api_call_timestamps = [t for t in api_call_timestamps if current_time_ms - t < 1.0]
            
            
            # 각 사용자의 주문 확인
            for user_id in running_users:
                try:
                    # 사용자의 모든 모니터링 주문 가져오기
                    user_orders = await get_user_monitor_orders(user_id)
                    if not user_orders:
                        continue
                        
                    logger.info(f"사용자 {user_id}의 모니터링 주문 수: {len(user_orders)}")
                    
                    # 심볼별 주문 그룹화 (한 번만 현재가를 가져오기 위함)
                    symbol_orders = {}
                    
                    for order_id, order_data in user_orders.items():
                        symbol = order_data.get("symbol")
                        if symbol not in symbol_orders:
                            symbol_orders[symbol] = []
                        symbol_orders[symbol].append(order_data)
                    
                    # 각 심볼에 대해 현재가 조회 및 주문 상태 확인

                    for symbol, orders in symbol_orders.items():
                        position_sides = set(order_data.get("position_side", "") for order_data in orders)
                        try:
                            # 현재가 조회
                            async with get_exchange_context(str(user_id)) as exchange:
                                current_price = await get_current_price(symbol, "1m", exchange)
                                
                                if current_price <= 0:
                                    logger.warning(f"유효하지 않은 현재가: {current_price}, 심볼: {symbol}")
                                    continue
                                    
                                logger.info(f"심볼 {symbol}의 현재가: {current_price}")
                                
                                # 정기 포지션 확인 시간에 포지션 확인 및 정리
                                if force_check_positions:
                                    # 각 방향(long, short)에 대해 포지션 존재 여부 확인 및 정리
                                    position_sides = set(order_data.get("position_side", "") for order_data in orders)
                                    for direction in position_sides:
                                        position_key = f"user:{user_id}:position:{symbol}:{direction}"
                                        #print("===============")
                                        #print(f"direction: {direction}")
                                        #print("===============")
                                        if direction not in ["long", "short"]:
                                            await send_telegram_message(f"이상한 것 발견. {direction}", user_id, debug=True)
                                            continue 
                                        # 포지션 확인 및 정리
                                        await check_and_cleanup_orders(user_id, symbol, direction)
                                    await check_position_exists(user_id, symbol, direction)
                                
                                # 심볼별로 트레일링 스탑 활성화된 방향 확인
                                trailing_sides = set()
                                for direction in ["long", "short"]:
                                    ts_key = f"trailing:user:{user_id}:{symbol}:{direction}"
                                    if await redis_client.exists(ts_key):
                                        trailing_sides.add(direction)
                                
                                # 각 주문 확인
                                for order_data in orders:
                                    order_id = order_data.get("order_id")
                                    order_type = order_data.get("order_type", "")
                                    position_side = order_data.get("position_side", "")
                                    
                                    # 이미 체결/취소된 주문은 스킵
                                    if order_data.get("status", "") != "open":
                                        continue
                                    
                                    # 트레일링 스탑이 활성화된 방향의 TP 주문은 스킵 (SL만 확인)
                                    if position_side in trailing_sides and order_type.startswith("tp"):
                                        logger.info(f"트레일링 스탑 활성화됨 ({position_side}), TP 주문 ({order_id}) 스킵")
                                        continue
                                    
                                    check_needed = False
                                    
                                    # 정기 확인 시간이면 강제로 확인
                                    if force_check_orders:
                                        check_needed = True
                                        #logger.info(f"정기 확인: {order_id}, 타입: {order_type}")
                                    else:
                                        # TP 주문 조건 확인
                                        if order_type.startswith("tp"):
                                            check_needed = await should_check_tp_order(order_data, current_price)
                                        # SL 주문 조건 확인
                                        elif order_type == "sl":
                                            check_needed = await should_check_sl_order(order_data, current_price)
                                    
                                    # 주문 상태 확인이 필요한 경우
                                    if check_needed:
                                        order_id = order_data.get("order_id")
                                        order_type = order_data.get("order_type", "")
                                        logger.info(f"주문 상태 확인: {order_id}, 타입: {order_type}")
                                        tp_index = 0
                                        if order_type.startswith("tp"):
                                            tp_index = int(order_type[2:])
                                        # 주문 확인 간 짧은 딜레이 추가 (서버 부하 방지)
                                        await asyncio.sleep(0.1)
                                        
                                        # order_type 매개변수를 추가하여 호출
                                        order_status = await check_order_status(
                                            user_id=user_id, 
                                            symbol=symbol, 
                                            order_id=order_id,
                                            order_type=order_type
                                        )
                                        
                                        # API 응답 분석
                                        if isinstance(order_status, dict):
                                            # OrderResponse 형식 (get_order_detail 결과)
                                            if 'status' in order_status:
                                                if order_status['status'] in ['FILLED', 'CLOSED', 'filled', 'closed']:
                                                    status = 'filled'
                                                    filled_sz = order_status.get('filled_amount', order_status.get('amount', '0'))
                                                    
                                                    # TP 주문이 체결되면 브레이크이븐/트레일링스탑 처리는 process_break_even_settings에서 모두 담당
                                                elif order_status['status'] in ['CANCELED', 'canceled']:
                                                    status = 'canceled'
                                                    filled_sz = order_status.get('filled_amount', '0')
                                                else:
                                                    status = 'open'
                                                    filled_sz = order_status.get('filled_amount', '0')
                                                    
                                                # TP 주문이 체결된 경우 브레이크이븐/트레일링스탑 처리
                                                if status == 'filled' and order_type.startswith('tp'):
                                                    try:
                                                        #get TP 업데이트
                                                        await redis_client.hset(position_key, f"get_tp{tp_index}", "true")
                                                        
                                                        # TP 주문 체결 로깅
                                                        price = float(order_data.get("price", "0"))
                                                        filled_amount = float(filled_sz) if filled_sz else 0
                                                        
                                                        # TP 주문 체결 로깅
                                                        try:
                                                            log_order(
                                                                user_id=user_id,
                                                                symbol=symbol,
                                                            action_type='tp_execution',
                                                            position_side=position_side,
                                                            price=price,
                                                            quantity=filled_amount,
                                                            tp_index=tp_index,
                                                                order_id=order_id,
                                                                current_price=current_price
                                                            )
                                                        except Exception as e:
                                                            logger.error(f"TP 주문 체결 로깅 실패: {str(e)}")
                                                        
                                                        # 사용자 설정에 따른 브레이크이븐/트레일링스탑 처리
                                                        await process_break_even_settings(
                                                            user_id=user_id,
                                                            symbol=symbol,
                                                            order_type=order_type,
                                                            position_data=order_data
                                                        )
                                                    except Exception as be_error:
                                                        logger.error(f"브레이크이븐/트레일링스탑 처리 실패: {str(be_error)}")
                                                
                                                # 주문 상태 업데이트
                                                await update_order_status(
                                                    user_id=user_id,
                                                    symbol=symbol,
                                                    order_id=order_id,
                                                    status=status,
                                                    filled_amount=str(filled_sz)
                                                )
                                                
                                                # SL 주문이 체결된 경우, 관련 트레일링 스탑 데이터 정리
                                                if status == 'filled' and order_type == 'sl':
                                                    await clear_trailing_stop(user_id, symbol, position_side)
                                                    
                                                    
                                                    # 알고리즘 주문 - SL 주문 체결 로깅
                                                    price = float(order_status.get('avgPx', order_status.get('px', 0)))
                                                    filled_amount = float(filled_sz) if filled_sz else 0
                                                    
                                                    try:
                                                        log_order(
                                                        user_id=user_id,
                                                        symbol=symbol,
                                                        action_type='sl_execution',
                                                        position_side=position_side,
                                                        price=price,
                                                        quantity=filled_amount,
                                                        order_id=order_id,
                                                            current_price=current_price,
                                                            api_type='okx_algo'
                                                        )
                                                    except Exception as e:
                                                        logger.error(f"SL 주문 체결 로깅 실패: {str(e)}")
                                                
                                                # TP 주문이 체결된 경우 로깅
                                                if status == 'filled' and order_type.startswith('tp'):
                                                    try:
                                                        # TP 레벨 추출
                                                        tp_index = int(order_type[2:]) if len(order_type) > 2 and order_type[2:].isdigit() else 0
                                                        
                                                        # 가격 정보 추출
                                                        price = float(order_status.get('avgPx', order_status.get('px', 0)))
                                                        filled_amount = float(filled_sz) if filled_sz else 0
                                                        
                                                        # OKX API - TP 주문 체결 로깅
                                                        log_order(
                                                            user_id=user_id,
                                                            symbol=symbol,
                                                            action_type='tp_execution',
                                                            position_side=position_side,
                                                            price=price,
                                                            quantity=filled_amount,
                                                            tp_index=tp_index,
                                                            order_id=order_id,
                                                            current_price=current_price,
                                                            api_type='okx_algo'
                                                        )
                                                    except Exception as e:
                                                        logger.error(f"OKX TP 주문 체결 로깅 실패: {str(e)}")
                                            # OKX API 응답 (알고리즘 주문)
                                            elif 'state' in order_status:
                                                state = order_status.get('state')
                                                filled_sz = order_status.get('accFillSz', '0')
                                                
                                                # 상태 매핑
                                                status_mapping = {
                                                    'filled': 'filled',
                                                    'effective': 'open',
                                                    'canceled': 'canceled',
                                                    'order_failed': 'failed'
                                                }
                                                status = status_mapping.get(state, 'unknown')
                                                
                                                # 주문 상태 업데이트
                                                await update_order_status(
                                                    user_id=user_id,
                                                    symbol=symbol,
                                                    order_id=order_id,
                                                    status=status,
                                                    filled_amount=filled_sz)
                                                
                                                # SL 주문이 체결된 경우, 관련 트레일링 스탑 데이터 정리
                                                if status == 'filled' and order_type == 'sl':
                                                    await clear_trailing_stop(user_id, symbol, position_side)
                        except Exception as symbol_error:
                            logger.error(f"심볼 {symbol} 처리 중 오류: {str(symbol_error)}")
                            traceback.print_exc()
                
                except Exception as user_error:
                    logger.error(f"사용자 {user_id} 처리 중 오류: {str(user_error)}")
                    traceback.print_exc()
            
            # 처리 간격 설정 (초)
            await asyncio.sleep(MONITOR_INTERVAL)
            
            # 연속 오류 카운터 초기화 (성공적인 반복)
            consecutive_errors = 0
            
        except Exception as loop_error:
            logger.error(f"모니터링 루프 오류: {str(loop_error)}")
            traceback.print_exc()
            
            # 연속 오류 증가
            consecutive_errors += 1
            
            # Redis 연결 복구 시도
            try:
                if not await redis_client.ping():
                    logger.warning("Redis 연결 끊김 감지, 재연결 시도...")
                    # Redis 클라이언트 재연결
                    await redis_client.connection_pool.disconnect()
                    await redis_client.ping()
                    logger.info("Redis 연결 복구 성공")
            except Exception as redis_error:
                logger.error(f"Redis 재연결 실패: {str(redis_error)}")
            
            # 지수 백오프로 대기 시간 계산 (최대 60초까지)
            backoff_time = min(5 * 2 ** (consecutive_errors - 1), 60)
            logger.warning(f"연속 오류 {consecutive_errors}회 발생, {backoff_time}초 후 재시도")
            
            # 오류 발생 시 지수 백오프로 대기 후 재시도
            await asyncio.sleep(backoff_time)

async def start_monitoring():
    """
    모니터링 서비스를 시작합니다. 오류 발생 시 재시작 로직 포함.
    """
    restart_attempts = 0
    restart_delay = 5  # 초기 재시작 딜레이 (초)
    
    while restart_attempts < MAX_RESTART_ATTEMPTS:
        try:
            logger.info(f"모니터링 서비스 시작 (시도 {restart_attempts + 1}/{MAX_RESTART_ATTEMPTS})")
            
            # Redis 연결 상태 확인
            try:
                if not await redis_client.ping():
                    logger.warning("Redis 연결 실패, 재연결 시도...")
                    await redis_client.connection_pool.disconnect()
                    await redis_client.ping()
            except Exception as redis_error:
                logger.error(f"Redis 연결 오류: {str(redis_error)}")
                # Redis 연결 실패해도 계속 시도
            
            # 모니터링 루프 실행
            await monitor_orders_loop()
            
            # 여기에 도달하면 정상 종료된 것 (무한 루프이므로 일반적으로는 도달하지 않음)
            logger.info("모니터링 서비스 정상 종료")
            break
            
        except Exception as e:
            restart_attempts += 1
            logger.error(f"모니터링 서비스 실패 ({restart_attempts}/{MAX_RESTART_ATTEMPTS}): {str(e)}")
            traceback.print_exc()
            
            # 다음 재시작 시도 전에 자원 정리
            try:
                # Redis 연결 정리
                await redis_client.connection_pool.disconnect()
                
                # 가비지 컬렉션 강제 실행
                gc.collect()
                
                # 메모리 사용량 로깅
                process = psutil.Process()
                memory_info = process.memory_info()
                logger.info(f"재시작 전 메모리 사용량: {memory_info.rss / 1024 / 1024:.2f} MB")
                
                # 텔레그램으로 관리자에게 알림 (선택적)
                await send_telegram_message(
                    f"⚠️ 모니터링 서비스 오류 발생\n재시작 시도: {restart_attempts}/{MAX_RESTART_ATTEMPTS}\n오류: {str(e)}",
                    user_id=1709556958,
                    debug=True
                )
            except Exception as cleanup_error:
                logger.error(f"재시작 전 자원 정리 오류: {str(cleanup_error)}")
            
            # 지수 백오프 방식으로 대기 시간 증가 (최대 5분까지)
            restart_delay = min(restart_delay * 2, 300)
            logger.info(f"{restart_delay}초 후 서비스 재시작 시도...")
            await asyncio.sleep(restart_delay)
    
    # 최대 재시작 시도 횟수 초과
    if restart_attempts >= MAX_RESTART_ATTEMPTS:
        logger.critical(f"최대 재시작 시도 횟수({MAX_RESTART_ATTEMPTS})를 초과하여 모니터링 서비스를 종료합니다.")
        # 마지막 텔레그램 알림
        try:
            await send_telegram_message(
                f"🚨 모니터링 서비스 강제 종료\n최대 재시작 시도 횟수({MAX_RESTART_ATTEMPTS})를 초과했습니다.\n수동 개입이 필요합니다.",
                user_id=1709556958,
                debug=True
            )
        except Exception:
            pass
        
        # 프로세스 종료 코드
        sys.exit(1)

def exit_handler():
    """
    프로그램 종료 시 정리 작업을 수행합니다.
    """
    logger.info("프로그램 종료, 자원 정리 중...")
    try:
        # 여기에 필요한 정리 로직 추가
        logger.info("자원 정리 완료, 프로그램 종료")
    except Exception as e:
        logger.error(f"종료 처리 중 오류: {str(e)}")

async def cancel_algo_orders_for_no_position_sides(user_id: int):
    """
    포지션이 없는 방향에 대해 알고리즘 주문을 취소하는 함수
    """
    try:
        logger.info(f"사용자 {user_id}의 포지션 없는 방향 알고리즘 주문 확인")
        # 거래소 컨텍스트 얻기
        async with get_exchange_context(str(user_id)) as exchange:
            # 현재 보유 중인 모든 포지션 확인
            try:
                positions = await exchange.fetch_positions()
                
                # 각 심볼별 포지션 방향 저장
                symbol_positions = {}
                
                for position in positions:
                    if not position or not isinstance(position, dict):
                        continue
                    
                    # 포지션 정보 추출
                    symbol = position.get("symbol", "").replace("-", "")
                    side = position.get("side", "")
                    size = float(position.get("contracts", position.get("size", 0)))
                    
                    # 유효한 포지션만 처리
                    if not (symbol and side) or size <= 0:
                        continue
                    
                    # 포지션 방향 정규화 (long/short)
                    normalized_side = "long" if side.lower() in ["buy", "long"] else "short"
                    
                    # 심볼별 포지션 방향 저장
                    if symbol not in symbol_positions:
                        symbol_positions[symbol] = set()
                    symbol_positions[symbol].add(normalized_side)
                    
                    # 활성 포지션이 있는 심볼은 최근 거래 심볼로 추가 (만료 시간 갱신)
                    await add_recent_symbol(user_id, symbol)
                
                # API 키 가져오기 (TriggerCancelClient 사용)
                try:
                    from src.api.dependencies import get_user_api_keys
                    from src.trading.cancel_trigger_okx import TriggerCancelClient
                    
                    api_keys = await get_user_api_keys(str(user_id))
                    cancel_client = TriggerCancelClient(
                        api_key=api_keys.get('api_key'),
                        secret_key=api_keys.get('api_secret'),
                        passphrase=api_keys.get('passphrase')
                    )
                except Exception as e:
                    logger.error(f"알고리즘 주문 취소 클라이언트 생성 실패: {str(e)}")
                    return
                
                # 각 심볼에 대해 반대 방향 찾기
                for symbol, sides in symbol_positions.items():
                    missing_sides = set(["long", "short"]) - sides
                    
                    # 심볼 형식 복원 (-를 포함한 형식, 예: BTC-USDT-SWAP)
                    trading_symbol = convert_to_trading_symbol(symbol)
                    
                    # 지원하지 않는 심볼이면 스킵
                    if trading_symbol not in SUPPORTED_SYMBOLS:
                        logger.info(f"지원하지 않는 심볼 스킵: {user_id}:{symbol} -> {trading_symbol}")
                        continue
                    
                    # 포지션이 없는 방향이 있으면 처리
                    for missing_side in missing_sides:
                        # 반대 방향의 주문 취소
                        logger.info(f"포지션 없음 확인 (전체 검사): {user_id}:{trading_symbol}:{missing_side}")
                        
                        try:
                            # TriggerCancelClient를 사용하여 알고리즘 주문 취소
                            result = await cancel_client.cancel_all_trigger_orders(
                                inst_id=trading_symbol,
                                side=missing_side,
                                algo_type="trigger",
                                user_id=str(user_id)
                            )
                            
                            if result and result.get('code') == '0':
                                # 주문 취소 성공 또는 주문이 없는 경우
                                if 'No active orders to cancel' in result.get('msg', ''):
                                    logger.info(f"알고리즘 주문 없음: {trading_symbol} {missing_side}")
                                else:
                                    logger.info(f"알고리즘 주문 취소 성공: {result}")
                                    await send_telegram_message(f"🗑️ 포지션 없음 - {trading_symbol} {missing_side} 방향 알고리즘 주문 자동 취소", user_id, debug=True)
                            else:
                                logger.error(f"알고리즘 주문 취소 실패: {result}")
                        except Exception as cancel_error:
                            logger.error(f"알고리즘 주문 취소 API 호출 오류: {str(cancel_error)}")
                
                # 포지션이 전혀 없는 심볼에 대해서도 확인 필요
                # 최근 거래한 심볼 목록 가져오기
                try:
                    # 수정된 함수 사용
                    recent_symbols = await get_recent_symbols(user_id)
                    
                    for symbol in recent_symbols:
                        # 이미 확인한 심볼은 스킵
                        if symbol in symbol_positions:
                            continue
                        
                        # 심볼 형식 복원 (-를 포함한 형식, 예: BTC-USDT-SWAP)
                        trading_symbol = convert_to_trading_symbol(symbol)
                        
                        # 지원하지 않는 심볼이면 스킵
                        if trading_symbol not in SUPPORTED_SYMBOLS:
                            logger.info(f"지원하지 않는 심볼 스킵: {user_id}:{symbol} -> {trading_symbol}")
                            continue
                            
                        logger.info(f"포지션 없는 심볼 확인: {user_id}:{symbol} -> {trading_symbol}")
                        
                        # long, short 방향 모두에 대해 알고리즘 주문 취소
                        for direction in ["long", "short"]:
                            try:
                                # TriggerCancelClient를 사용하여 알고리즘 주문 취소
                                result = await cancel_client.cancel_all_trigger_orders(
                                    inst_id=trading_symbol,
                                    side=direction,
                                    algo_type="trigger",
                                    user_id=str(user_id)
                                )
                                
                                if result and result.get('code') == '0':
                                    logger.info(f"알고리즘 주문 취소 성공: {result}")
                                    await send_telegram_message(f"🗑️1 포지션 없음 - {trading_symbol} {direction} 방향 알고리즘 주문 자동 취소", user_id, debug=True)
                                else:
                                    logger.error(f"알고리즘 주문 취소 실패: {result}")
                            except Exception as cancel_error:
                                logger.error(f"알고리즘 주문 취소 API 호출 오류: {str(cancel_error)}")
                    
                except Exception as e:
                    logger.error(f"최근 심볼 조회 오류: {str(e)}")
                    
            except Exception as e:
                logger.error(f"포지션 조회 오류: {str(e)}")
                
    except Exception as e:
        logger.error(f"사용자 {user_id} 알고리즘 주문 취소 중 오류: {str(e)}")

def convert_to_trading_symbol(symbol: str) -> str:
    """
    다양한 형식의 심볼을 OKX API 호환 형식(BTC-USDT-SWAP)으로 변환합니다.
    지원하는 심볼만 반환하며, 지원하지 않는 심볼은 기본값인 BTC-USDT-SWAP을 반환합니다.
    
    Args:
        symbol (str): 변환할 심볼 (예: "BTCUSDT", "BTC/USDT" 등)
        
    Returns:
        str: OKX API 호환 형식의 심볼 (예: "BTC-USDT-SWAP")
    """
    # 슬래시(/) 제거
    symbol = symbol.replace("/", "")
    # 하이픈(-) 제거 
    symbol = symbol.replace("-", "")
    
    # 일반적인 심볼 형식 변환 (BTCUSDT, ETHUSDT 등)
    converted_symbol = ""
    
    if len(symbol) >= 7:
        # 대부분의 코인은 3글자 + 4글자(USDT) 형식
        base = symbol[0:3]
        quote = symbol[3:7]
        converted_symbol = f"{base}-{quote}-SWAP"
    elif len(symbol) >= 6 and symbol.endswith("USDT"):
        # 2글자 코인 (XRPUSDT 같은 경우)
        base_len = len(symbol) - 4
        base = symbol[0:base_len]
        quote = symbol[base_len:]
        converted_symbol = f"{base}-{quote}-SWAP"
    else:
        # 기타 형식은 기본값으로 처리
        logger.warning(f"알 수 없는 심볼 형식: {symbol}, 기본값 사용")
        converted_symbol = "BTC-USDT-SWAP"
    
    # 지원하는 심볼인지 확인
    if converted_symbol in SUPPORTED_SYMBOLS:
        return converted_symbol
    else:
        logger.warning(f"지원하지 않는 심볼: {converted_symbol}, 기본값 사용")
        return "BTC-USDT-SWAP"

# 심볼 관리 함수 추가
async def add_recent_symbol(user_id: int, symbol: str):
    """
    사용자가 거래한 심볼을 Redis에 저장하고 1시간의 만료 시간을 설정합니다.
    
    Args:
        user_id (int): 사용자 ID
        symbol (str): 거래 심볼
    """
    try:
        # 각 심볼을 별도의 키로 저장 (개별 만료 시간 설정을 위해)
        symbol_key = f"user:{user_id}:recent_symbol:{symbol}"
        
        # 심볼 정보 저장 (값은 중요하지 않음, 키의 존재 여부만 확인)
        await redis_client.set(symbol_key, "1")
        
        # 1시간(3600초) 만료 시간 설정
        await redis_client.expire(symbol_key, 3600)
        
        logger.info(f"최근 거래 심볼 추가: {user_id}:{symbol}, 만료: 1시간")
    except Exception as e:
        logger.error(f"최근 거래 심볼 추가 실패: {str(e)}")

async def get_recent_symbols(user_id: int) -> List[str]:
    """
    사용자가 최근 거래한 심볼 목록을 가져옵니다.
    
    Args:
        user_id (int): 사용자 ID
        
    Returns:
        List[str]: 최근 거래 심볼 목록
    """
    try:
        # 패턴 매칭으로 모든 활성 심볼 키 가져오기
        pattern = f"user:{user_id}:recent_symbol:*"
        symbol_keys = await redis_client.keys(pattern)
        
        # 키에서 심볼 부분만 추출
        symbols = []
        for key in symbol_keys:
            # 키 형식: user:{user_id}:recent_symbol:{symbol}
            parts = key.split(":")
            if len(parts) >= 4:
                symbol = parts[3]
                symbols.append(symbol)
        
        return symbols
    except Exception as e:
        logger.error(f"최근 거래 심볼 조회 실패: {str(e)}")
        return []

if __name__ == "__main__":
    """
    독립 실행 시 엔트리포인트
    """
    import atexit
    import signal
    
    # 종료 핸들러 등록
    atexit.register(exit_handler)
    
    # 시그널 핸들러 설정
    def signal_handler(sig, frame):
        logger.info(f"시그널 {sig} 수신, 프로그램 종료...")
        # 여기서 cleanup 로직이나 종료 알림 등을 추가할 수 있음
        sys.exit(0)
    
    # SIGINT(Ctrl+C), SIGTERM 핸들러 등록
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # 필수 라이브러리 가져오기
    import sys
    import psutil
    
    # 프로세스 우선순위 설정 (선택적)
    try:
        import os
        if hasattr(os, 'nice'):
            os.nice(10)  # 낮은 우선순위 설정 (Linux/Mac)
        elif sys.platform == 'win32':
            import win32process
            import win32api
            pid = win32api.GetCurrentProcessId()
            handle = win32api.OpenProcess(win32process.PROCESS_ALL_ACCESS, True, pid)
            win32process.SetPriorityClass(handle, win32process.BELOW_NORMAL_PRIORITY_CLASS)
    except Exception as e:
        logger.warning(f"프로세스 우선순위 설정 실패: {str(e)}")
    
    # 메모리 제한 설정 (선택적)
    try:
        if sys.platform != 'win32':  # Unix/Linux/Mac
            import resource
            # 2GB 메모리 제한 (소프트 제한)
            rsrc = resource.RLIMIT_AS
            soft, hard = resource.getrlimit(rsrc)
            resource.setrlimit(rsrc, (2 * 1024 * 1024 * 1024, hard))
            logger.info(f"메모리 제한 설정: {2}GB (소프트 제한)")
    except Exception as e:
        logger.warning(f"메모리 제한 설정 실패: {str(e)}")
        
    # 기본 모니터링 정보 출력
    process = psutil.Process()
    logger.info(f"시작 시 메모리 사용량: {process.memory_info().rss / 1024 / 1024:.2f} MB")
    logger.info(f"CPU 코어: {psutil.cpu_count()} / 논리 코어: {psutil.cpu_count(logical=True)}")
    
    # 메인 루프 시작
    try:
        asyncio.run(start_monitoring())
    except KeyboardInterrupt:
        logger.info("사용자가 프로그램을 중단함 (KeyboardInterrupt)")
    except Exception as e:
        logger.critical(f"프로그램 실행 중 치명적인 오류 발생: {str(e)}")
        traceback.print_exc()
        sys.exit(1) 