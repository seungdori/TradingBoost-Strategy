from typing import Dict, List, Optional, Union, Any
import json

from HYPERRSI.src.trading.models import Position
from datetime import datetime
from shared.logging import get_logger, log_order
from HYPERRSI.src.api.dependencies import get_exchange_context
from shared.utils import get_contract_size
import matplotlib.pyplot as plt
import pandas as pd
import tempfile
from datetime import datetime
import time

logger = get_logger(__name__)

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error


# Module-level attribute for backward compatibility
def __getattr__(name):
    if name == "redis_client":
        return _get_redis_client()
    raise AttributeError(f"module has no attribute {name}")

# Redis key formats
def get_redis_key(user_id: Union[str, int], key_type: str) -> str:
    """Generate Redis key based on user_id and key type"""
    return f"user:{user_id}:{key_type}"

class TradeStatus:
    OPEN = "open"
    CLOSED = "closed"
    PARTIALLY_CLOSED = "partially_closed"
    CANCELED = "canceled"
    EXPIRED = "expired"

TRADING_STATS_SCHEMA = {
    "total_trades": 0,        # 총 거래 횟수
    "entry_trade": 0,        # 총 진입 횟수
    "winning_trades": 0,      # 수익 거래 횟수
    "losing_trades": 0,       # 손실 거래 횟수
    "total_profit": 0.0,      # 총 수익(USDT)
    "total_loss": 0.0,        # 총 손실(USDT)
    "max_profit": 0.0,        # 최대 수익
    "max_loss": 0.0,         # 최대 손실
    "avg_profit": 0.0,        # 평균 수익
    "avg_loss": 0.0,         # 평균 손실
    "win_rate": 0.0,         # 승률
    "profit_factor": 0.0,    # 수익률(total_profit/total_loss)
    "trades": []             # 개별 거래 기록
}

TRADE_HISTORY_SCHEMA = {
    "timestamp": "",         # 거래 시작 시간
    "symbol": "",           # 거래 심볼
    "side": "",            # 거래 방향 (long/short)
    "size": 0.0,           # 거래 크기
    "initial_size": 0.0,    # 초기 거래 크기
    "entry_price": 0.0,     # 진입가
    "exit_price": None,     # 청산가
    "leverage": 0.0,        # 레버리지
    "status": "",          # 상태 (open/closed/partially_closed)
    "pnl": None,           # 실현 손익
    "pnl_percent": None,    # 수익률
    "order_id": "",        # 주문 ID
    "close_type": None,    # 청산 유형 (TP/SL/Manual)
    "close_comment": None,  # 청산 코멘트
    "exit_timestamp": None,  # 청산 시간
    "last_filled_price": None  # 최근 진입가
}

async def get_position_pnl(exchange: Any, symbol: str, order_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """
    거래소 API를 통해 포지션의 PNL 정보를 조회합니다.

    Args:
        exchange: CCXT exchange 인스턴스
        symbol: 심볼 (예: "BTC-USDT-SWAP")
        order_id: 주문 ID (선택사항)
    """
    try:
        # OKX API를 통해 포지션 히스토리 조회
        params = {
            'instType': 'SWAP',
            'instId': symbol,
            'limit': '50'  # 최근 50개 조회
        }
        
        if order_id:
            params['ordId'] = order_id
            
        logger.info(f"[DEBUG] PNL 조회 파라미터: {json.dumps(params, indent=2)}")
        response = await exchange.private_get_trade_fills(params)
        logger.info(f"[DEBUG] PNL 조회 응답: {json.dumps(response, indent=2)}")
        
        if response.get('code') != '0':
            logger.error(f"포지션 조회 실패: {response.get('msg')}")
            return None
            
        fills = response.get('data', [])
        if not fills:
            logger.info("[DEBUG] 거래 내역이 없습니다.")
            return None
            
        # 가장 최근 거래 정보 사용
        latest_fill = fills[0]
        #logger.info(f"[DEBUG] 최근 거래 정보: {json.dumps(latest_fill, indent=2)}")
        
        result = {
            'realized_pnl': float(latest_fill.get('pnl', 0)),
            'entry_price': float(latest_fill.get('fillPx', 0)),
            'exit_price': float(latest_fill.get('fillPx', 0)),
            'size': float(latest_fill.get('fillSz', 0)),
            'side': latest_fill.get('side', ''),
            'timestamp': int(latest_fill.get('ts', 0))
        }
        logger.info(f"[DEBUG] 변환된 PNL 정보: {json.dumps(result, indent=2)}")
        return result
        
    except Exception as e:
        logger.error(f"PNL 정보 조회 실패: {str(e)}")
        return None

async def get_trade_history(
    user_id: str,
    limit: int = 10,
    status: Optional[str] = None
) -> List[Dict[str, Any]]:
    """거래 히스토리 조회 및 상태 업데이트"""
    history_key = get_redis_key(user_id, "history")
    try:
        history = await _get_redis_client().lrange(history_key, 0, limit-1)
        result = []
        
        async with get_exchange_context(str(user_id)) as exchange:
            for trade_str in history:
                trade_info = json.loads(trade_str)
                #logger.info(f"[DEBUG] 처리 전 거래 정보: {json.dumps(trade_info, indent=2)}")
                
                if status and trade_info['status'] != status:
                    continue

                try:
                    order_id = trade_info.get('order_id')
                    symbol = trade_info.get('symbol')
                    
                    if not order_id or not symbol:
                        continue

                    # 1. 주문 상세 정보 조회
                    try:
                        order = await exchange.fetch_order(order_id, symbol)
                        #logger.info(f"[DEBUG] 주문 상세 조회 결과: {json.dumps(order, indent=2)}")
                        
                        # 주문 상태가 종료된 경우
                        if order['status'] in ['closed', 'canceled', 'expired']:
                            trade_info['status'] = TradeStatus.CLOSED
                            
                            # 2. 실제 체결 정보 업데이트
                            trade_info['exit_price'] = float(order['average']) if order.get('average') else float(order['price'])
                            trade_info['exit_timestamp'] = datetime.fromtimestamp(
                                order.get('lastTradeTimestamp', order['timestamp']) / 1000
                            ).strftime('%Y-%m-%d %H:%M:%S')
                            
                            # 3. PNL 계산
                            entry_price = float(trade_info['entry_price'])
                            exit_price = float(trade_info['exit_price'])
                            size = float(trade_info['size'])
                            is_long = trade_info['side'] == 'long'
                            
                            if entry_price > 0 and size > 0:
                                if is_long:
                                    pnl = (exit_price - entry_price) * size
                                else:
                                    pnl = (entry_price - exit_price) * size
                                    
                                trade_info['pnl'] = pnl
                                trade_info['pnl_percent'] = (pnl / (entry_price * size)) * 100
                                
                            # 4. 수수료 정보 추가
                            if order.get('fee'):
                                trade_info['fee'] = {
                                    'cost': float(order['fee']['cost']),
                                    'currency': order['fee']['currency']
                                }
                            
                            # 5. 청산 유형 판단
                            if order.get('info', {}).get('tpTriggerPx'):
                                trade_info['close_type'] = 'TP'
                            elif order.get('info', {}).get('slTriggerPx'):
                                trade_info['close_type'] = 'SL'
                            else:
                                trade_info['close_type'] = 'Manual'
                            
                            # Redis 업데이트
                            await _get_redis_client().lset(history_key, history.index(trade_str), json.dumps(trade_info))
                            
                    except Exception as e:
                        logger.error(f"주문 정보 조회 실패 (order_id: {order_id}): {str(e)}")
                        
                except Exception as e:
                    logger.error(f"거래 정보 처리 중 오류: {str(e)}")
                    
                result.append(trade_info)
                
        return result
        
    except Exception as e:
        logger.error(f"거래 히스토리 조회 실패: {str(e)}")
        return []

async def record_trade_history_entry(
    user_id: str,
    symbol: str,
    side: str,
    size: float,
    entry_price: float,
    leverage: float,
    order_id: str,
    last_filled_price: float
) -> None:
    """새로운 거래 진입을 히스토리에 기록"""
    history_key = get_redis_key(user_id, "history")
    
    trade_history = TRADE_HISTORY_SCHEMA.copy()
    trade_history.update({
        "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        "symbol": symbol,
        "side": side,
        "size": size,
        "initial_size": size,  # 초기 사이즈 저장
        "entry_price": entry_price,
        "leverage": leverage,
        "status": TradeStatus.OPEN,
        "order_id": order_id,
        "last_filled_price": last_filled_price,
        
    })
    
    try:
        # Redis에 저장 (최근 100개만 유지)
        await _get_redis_client().lpush(history_key, json.dumps(trade_history))
        await _get_redis_client().ltrim(history_key, 0, 99)
        logger.info(f"거래 히스토리 기록 완료: {trade_history}")
    except Exception as e:
        logger.error(f"거래 히스토리 기록 실패: {str(e)}")

async def update_trade_history_exit(
    user_id: str,
    symbol: str,
    order_id: str,
    exit_price: float,
    pnl: float,
    close_type: str,
    comment: str,
    percent_closed: float = 100.0
) -> None:
    """기존 거래 히스토리 업데이트 (청산 시)"""
    history_key = get_redis_key(user_id, "history")
    
    try:
        # 최근 히스토리에서 해당 거래 찾기
        history = await _get_redis_client().lrange(history_key, 0, -1)
        for i, trade in enumerate(history):
            trade_info = json.loads(trade)
            if (trade_info['symbol'] == symbol and 
                trade_info['status'] == TradeStatus.OPEN and 
                trade_info['order_id'] == order_id):
                
                # 진입가 기준으로 수익률 계산
                entry_price = float(trade_info['entry_price'])
                size = float(trade_info['size'])
                contract_size = await get_contract_size(trade_info['symbol'])
                pnl_percent = (pnl / (entry_price * size)) * 100
                position_qty = size * contract_size
                # 히스토리 업데이트
                trade_info.update({
                    'status': TradeStatus.CLOSED if percent_closed >= 99.9 else TradeStatus.PARTIALLY_CLOSED,
                    'exit_price': exit_price,
                    'exit_timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'pnl': pnl,
                    'pnl_percent': pnl_percent,
                    'position_qty': position_qty,
                    'close_type': close_type,
                    'close_comment': comment
                })
                
                # 부분 청산의 경우
                if percent_closed < 99.9:
                    remaining_size = size * (1 - percent_closed/100)
                    trade_info['remaining_size'] = remaining_size
                
                # Redis 히스토리 업데이트
                await _get_redis_client().lset(history_key, i, json.dumps(trade_info))
                break
                
        logger.info(f"거래 히스토리 업데이트 완료: {trade_info}")
        
    except Exception as e:
        logger.error(f"거래 히스토리 업데이트 실패: {str(e)}")

async def record_trade_entry(
    user_id: str,
    symbol: str,
    entry_price: float,
    current_price: float,
    size: float,  # 계약 수량
    side: str,
    is_DCA: bool = False,
    dca_count: int = 1,
) -> None:
    trade_key = get_redis_key(user_id, f"current_trade:{symbol}:{side}")
    contracts_amount = size
    contract_size: float = 1.0
    existing_trade: Dict[str, Any] = {}
    
    try:
        # 계약 사양 정보 조회
        contract_key = get_redis_key(user_id, f"symbol_info:contract_specifications")
        contract_raw = await _get_redis_client().get(contract_key)
        if contract_raw:
            contract_info = json.loads(contract_raw)
            contract_size = contract_info.get(symbol, {}).get("contractSize", 1)
        
        # 기존 거래 정보 조회
        existing_trade = await _get_redis_client().hgetall(trade_key)
    except Exception as e:
        logger.error(f"거래 정보 조회 실패: {str(e)}")
    
    position_qty = contracts_amount * contract_size
    entry_data: Dict[str, Any]
    if existing_trade and is_DCA:
        # DCA인 경우 기존 거래 정보 업데이트
        total_contracts = float(existing_trade.get("total_contracts_amount", 0)) + contracts_amount
        total_qty = float(existing_trade.get("total_position_qty", 0)) + position_qty
        entry_data = {
            "last_dca_time": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "last_filled_price": current_price,
            "last_dca_contracts_amount": contracts_amount,
            "last_dca_position_qty": position_qty,
            "dca_count": dca_count,
            "total_contracts_amount": total_contracts,
            "total_position_qty": total_qty,
            "status": TradeStatus.OPEN
        }
    else:
        # 새로운 진입인 경우
        entry_data = {
            "entry_time": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "entry_price": entry_price,
            "initial_contracts_amount": contracts_amount,
            "initial_position_qty": position_qty,
            "total_contracts_amount": contracts_amount,
            "total_position_qty": position_qty,
            "last_filled_price": current_price,
            "side": side,
            "symbol": symbol,
            "status": TradeStatus.OPEN,
            "dca_count": 1
        }
    log_order(user_id, symbol, 'entry', side, current_price, contracts_amount, dca_count)
    await _get_redis_client().hset(trade_key, mapping=entry_data)
    logger.info(f"거래 진입 기록 완료: {entry_data}")
    cooldown_key = f"user:{user_id}:cooldown:{symbol}:{side}"
    cooldown_seconds = 30  # 30초
    if not await _get_redis_client().get(cooldown_key):
        await _get_redis_client().set(cooldown_key, "true", ex=cooldown_seconds)
    

async def record_trade_exit(user_id: str, symbol: str, position: Position, exchange: Any) -> None:
    trade_key = get_redis_key(user_id, f"current_trade:{symbol}")
    stats_key = get_redis_key(user_id, "stats")

    # 진입 데이터 조회
    entry_data = await _get_redis_client().hgetall(trade_key)
    if not entry_data:
        return

    # PNL 정보 조회
    pnl_info = await get_position_pnl(exchange, symbol)
    if pnl_info:
        trade_data: Dict[str, Any] = {
            **entry_data,
            "exit_time": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "exit_price": pnl_info['exit_price'],
            "realized_pnl": pnl_info['realized_pnl'],
            "final_size": position.size,
            "status": TradeStatus.CLOSED
        }

        # 통계 업데이트
        current_stats = await _get_redis_client().get(stats_key)
        stats_dict: Dict[str, Any] = json.loads(current_stats) if current_stats else TRADING_STATS_SCHEMA.copy()

        stats_dict['total_trades'] = int(stats_dict.get('total_trades', 0)) + 1
        realized_pnl = float(pnl_info['realized_pnl'])
        if realized_pnl > 0:
            stats_dict['winning_trades'] = int(stats_dict.get('winning_trades', 0)) + 1
            stats_dict['total_profit'] = float(stats_dict.get('total_profit', 0.0)) + realized_pnl
        else:
            stats_dict['losing_trades'] = int(stats_dict.get('losing_trades', 0)) + 1
            stats_dict['total_loss'] = float(stats_dict.get('total_loss', 0.0)) + abs(realized_pnl)

        # 거래 기록 저장
        trades_list: List[Dict[str, Any]] = stats_dict.get('trades', [])
        trades_list.append(trade_data)
        stats_dict['trades'] = trades_list

        await _get_redis_client().set(stats_key, json.dumps(stats_dict))
        await _get_redis_client().delete(trade_key)  # 현재 거래 정보 삭제
        side = trade_data.get("side", trade_data.get("direction", ""))
        if side == "buy":
            side = "long"
        elif side == "sell":
            side = "short"
        cooldown_key = f"user:{user_id}:cooldown:{symbol}:{side}"
        cooldown_seconds = 40  # 40초
        if not await _get_redis_client().get(cooldown_key):
            await _get_redis_client().set(cooldown_key, "true", ex=cooldown_seconds)
    

async def get_trading_stats(user_id: str) -> Dict[str, Any]:
    stats_key = get_redis_key(user_id, "stats")
    stats_data = await _get_redis_client().get(stats_key)
    if not stats_data:
        schema_copy: Dict[str, Any] = TRADING_STATS_SCHEMA.copy()
        return schema_copy
    result: Dict[str, Any] = json.loads(stats_data)
    return result

async def update_trading_stats(
    user_id: str,
    symbol: str,
    entry_price: float,
    exit_price: float,
    position_size: float,
    pnl: float,
    side: str,
    entry_time: str,
    exit_time: str,
) -> None:
    stats_key = get_redis_key(user_id, "stats")

    try:
        # 현재 통계 데이터 가져오기
        current_stats = await _get_redis_client().get(stats_key)
        stats_dict: Dict[str, Any] = json.loads(current_stats) if current_stats else TRADING_STATS_SCHEMA.copy()

        # 새로운 거래 정보
        trade_info: Dict[str, Any] = {
            "symbol": symbol,
            "side": side,
            "entry_price": entry_price,
            "exit_price": exit_price,
            "position_size": position_size,
            "pnl": pnl,
            "entry_time": entry_time,
            "exit_time": exit_time,
        }

        # 통계 업데이트
        stats_dict["total_trades"] = int(stats_dict.get("total_trades", 0)) + 1
        if pnl > 0:
            stats_dict["winning_trades"] = int(stats_dict.get("winning_trades", 0)) + 1
            stats_dict["total_profit"] = float(stats_dict.get("total_profit", 0.0)) + pnl
            stats_dict["max_profit"] = max(float(stats_dict.get("max_profit", 0.0)), pnl)
        else:
            stats_dict["losing_trades"] = int(stats_dict.get("losing_trades", 0)) + 1
            stats_dict["total_loss"] = float(stats_dict.get("total_loss", 0.0)) + abs(pnl)
            stats_dict["max_loss"] = min(float(stats_dict.get("max_loss", 0.0)), pnl)

        # 평균값 계산
        winning_trades = int(stats_dict.get("winning_trades", 0))
        losing_trades = int(stats_dict.get("losing_trades", 0))
        if winning_trades > 0:
            stats_dict["avg_profit"] = float(stats_dict.get("total_profit", 0.0)) / winning_trades
        if losing_trades > 0:
            stats_dict["avg_loss"] = float(stats_dict.get("total_loss", 0.0)) / losing_trades

        # 승률 계산
        total_trades = int(stats_dict.get("total_trades", 1))
        stats_dict["win_rate"] = (winning_trades / total_trades) * 100

        # 수익률 계산
        total_loss = float(stats_dict.get("total_loss", 0.0))
        if total_loss > 0:
            stats_dict["profit_factor"] = float(stats_dict.get("total_profit", 0.0)) / total_loss

        # 거래 기록 추가 (최근 100개만 유지)
        trades_list: List[Dict[str, Any]] = stats_dict.get("trades", [])
        trades_list.append(trade_info)
        if len(trades_list) > 100:
            trades_list = trades_list[-100:]
        stats_dict["trades"] = trades_list

        # Redis에 저장
        await _get_redis_client().set(stats_key, json.dumps(stats_dict))

    except Exception as e:
        logger.error(f"통계 업데이트 실패: {str(e)}")
        
        
#==============================================
# 통계 이미지 생성
#==============================================






async def get_user_trading_statistics(user_id: str) -> Dict[str, Any]:
    """
    특정 유저의 거래 통계를 조회하는 함수
    """
    try:
        stats: Dict[str, Any] = {
            "total_pnl": 0.0,
            "winning_trades": 0,
            "losing_trades": 0,
            "total_trades": 0,
            "symbols": set(),
            "best_trade": {"pnl": float('-inf'), "symbol": None},
            "worst_trade": {"pnl": float('inf'), "symbol": None}
        }
        start_time = time.time()
        # 1. 기존 PnL 데이터 조회
        pnl_pattern = f"user:{user_id}:pnl:*"
        pnl_keys = await _get_redis_client().keys(pnl_pattern)
        
        for key in pnl_keys:
            pnl_data = await _get_redis_client().hgetall(key)
            if pnl_data and 'pnl' in pnl_data:
                current_pnl: float = float(pnl_data['pnl'])
                symbol = key.split(":")[3]

                stats["total_pnl"] += current_pnl
                stats["total_trades"] += 1
                stats["symbols"].add(symbol)

                if current_pnl > 0:
                    stats["winning_trades"] += 1
                elif current_pnl < 0:
                    stats["losing_trades"] += 1

                # 최고/최저 수익 거래 기록
                if current_pnl > stats["best_trade"]["pnl"]:
                    stats["best_trade"] = {"pnl": current_pnl, "symbol": symbol}
                if current_pnl < stats["worst_trade"]["pnl"]:
                    stats["worst_trade"] = {"pnl": current_pnl, "symbol": symbol}
        end_time = time.time()
        print("================================================")
        print(f"get_user_trading_statistics 소요시간: {end_time - start_time}초")
        print("================================================")
        # 2. completed 주문 데이터 조회
        
        start_time = time.time()
        completed_pattern = f"completed:user:{user_id}:*:order:*"
        completed_keys = await _get_redis_client().keys(completed_pattern)
        
        for key in completed_keys:
            data = await _get_redis_client().hgetall(key)
            if data and data.get('status') == 'filled' and all(field in data for field in ['price', 'contracts_amount', 'position_side']):
                parts = key.split(":")
                symbol = parts[3]
                
                # PnL 계산 시도
                try:
                    # None 값 처리 로직 추가
                    filled_contracts_str = data.get('filled_contracts_amount', '0')
                    filled_contracts: float = float(filled_contracts_str) if filled_contracts_str != 'None' else 0.0

                    price_str = data.get('price', '0')
                    price: float = float(price_str) if price_str != 'None' else 0.0

                    position_side = data.get('position_side', 'unknown')

                    # 진입가격 정보 가져오기 - 우선 completed 주문 데이터에서 직접 확인
                    entry_price: float = 0.0
                    if 'entry_price' in data:
                        # completed 주문 데이터에 진입가격이 저장되어 있는 경우
                        entry_price_str = data.get('entry_price', '0')
                        entry_price = float(entry_price_str) if entry_price_str != 'None' else 0.0
                    else:
                        # 기존 방식으로 포지션 데이터에서 조회
                        position_key = f"user:{user_id}:position:{symbol}:{position_side}"
                        position_data = await _get_redis_client().hgetall(position_key)
                        if position_data and 'entry_price' in position_data:
                            entry_price_str = position_data['entry_price']
                            entry_price = float(entry_price_str) if entry_price_str != 'None' else 0.0

                    # PnL 계산
                    pnl: float = 0.0
                    if entry_price > 0 and price > 0 and filled_contracts > 0:
                        contract_value = await get_contract_value(symbol, filled_contracts)
                        if position_side == 'long':
                            pnl = (price - entry_price) * contract_value
                        else:  # short
                            pnl = (entry_price - price) * contract_value
                    
                    # 빈 거래(PnL 계산 안 된 경우) 건너뛰기
                    if pnl == 0:
                        continue
                    
                    stats["total_pnl"] += pnl
                    stats["total_trades"] += 1
                    stats["symbols"].add(symbol)
                    
                    if pnl > 0:
                        stats["winning_trades"] += 1
                    elif pnl < 0:
                        stats["losing_trades"] += 1
                    
                    # 최고/최저 수익 거래 기록
                    if pnl > stats["best_trade"]["pnl"]:
                        stats["best_trade"] = {"pnl": pnl, "symbol": symbol}
                    if pnl < stats["worst_trade"]["pnl"]:
                        stats["worst_trade"] = {"pnl": pnl, "symbol": symbol}
                
                except Exception as e:
                    logger.error(f"Error processing completed order for statistics: {str(e)}")
                    continue
        end_time = time.time()
        print("================================================")
        print(f"completed 주문 데이터 조회 소요시간: {end_time - start_time}초")
        print("================================================")
        # 승률 계산
        stats["win_rate"] = (stats["winning_trades"] / stats["total_trades"] * 100) if stats["total_trades"] > 0 else 0
        
        # float('inf')를 실제 값으로 변환
        if stats["best_trade"]["pnl"] == float('-inf'):
            stats["best_trade"] = {"pnl": 0, "symbol": None}
        if stats["worst_trade"]["pnl"] == float('inf'):
            stats["worst_trade"] = {"pnl": 0, "symbol": None}
        
        return stats
    except Exception as e:
        logger.error(f"Error getting trading statistics: {str(e)}")
        raise


async def get_pnl_history(user_id: str, limit: int = 10) -> List[Dict[str, Any]]:
    """Redis에 저장된 TP PnL 데이터와 완료된 주문 데이터를 거래 내역 형식으로 조회"""
    try:
        trades: List[Dict[str, Any]] = []
        
        # 1. 기존 PnL 데이터 조회
        pnl_pattern = f"user:{user_id}:pnl:*"
        pnl_keys = await _get_redis_client().keys(pnl_pattern)
        
        for key in pnl_keys:
            data = await _get_redis_client().hgetall(key)
            if data and all(field in data for field in ['pnl', 'filled_price', 'filled_qty', 'entry_price', 'timestamp', 'side']):
                # user:1709556958:pnl:BTC-USDT-SWAP:2237354016760684544:tp1
                symbol = key.split(":")[3]
                tp_level = key.split(":")[-1]  # tp1, tp2, tp3 등

                trade: Dict[str, Any] = {
                    'timestamp': datetime.fromtimestamp(int(data['timestamp'])).strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'tp_level': tp_level,
                    'side': data['side'],
                    'size': float(data['filled_qty']) if data['filled_qty'] != 'None' else 0.0,
                    'entry_price': float(data['entry_price']) if data['entry_price'] != 'None' else 0.0,
                    'exit_price': float(data['filled_price']) if data['filled_price'] != 'None' else 0.0,
                    'pnl': float(data['pnl']) if data['pnl'] != 'None' else 0.0
                }
                trades.append(trade)
        
        # 2. completed 주문 데이터 조회 (update_order_status에서 저장한 데이터)
        completed_pattern = f"completed:user:{user_id}:*:order:*"
        completed_keys = await _get_redis_client().keys(completed_pattern)
        
        for key in completed_keys:
            data = await _get_redis_client().hgetall(key)
            if data and data.get('status') == 'filled' and all(field in data for field in ['price', 'contracts_amount', 'position_side', 'order_type']):
                # completed:user:{user_id}:{symbol}:order:{order_id}
                parts = key.split(":")
                symbol = parts[3]
                
                # order_type에서 tp_level 추출 (tp1, tp2, tp3 등)
                order_type = data.get('order_type', 'unknown')
                tp_level = order_type if (order_type.startswith('tp') or order_type.startswith('take_profit')) else 'unknown'
                
                timestamp = data.get('last_updated_time', data.get('create_time', '0'))
                filled_contracts_str = data.get('filled_contracts_amount', '0')
                filled_contracts: float = float(filled_contracts_str) if filled_contracts_str != 'None' else 0.0
                price_str = data.get('price', '0')
                price: float = float(price_str) if price_str != 'None' else 0.0
                position_side = data.get('position_side', 'unknown')

                # 진입가격 정보 가져오기 - 우선 completed 주문 데이터에서 직접 확인
                entry_price: float = 0.0
                if 'entry_price' in data:
                    # completed 주문 데이터에 진입가격이 저장되어 있는 경우 (수정된 로직)
                    entry_price_str = data.get('entry_price', '0')
                    entry_price = float(entry_price_str) if entry_price_str != 'None' else 0.0
                else:
                    # 기존 방식으로 포지션 데이터에서 조회 시도
                    position_key = f"user:{user_id}:position:{symbol}:{position_side}"
                    position_data = await _get_redis_client().hgetall(position_key)
                    if position_data and 'entry_price' in position_data:
                        entry_price_str = position_data.get('entry_price', '0')
                        entry_price = float(entry_price_str) if entry_price_str != 'None' else 0.0

                # PnL 계산
                pnl: float = 0.0
                if entry_price > 0 and price > 0 and filled_contracts > 0:
                    try:
                        contract_value = await get_contract_value(symbol, filled_contracts)
                        if position_side == 'long':
                            pnl = (price - entry_price) * contract_value
                        else:  # short
                            pnl = (entry_price - price) * contract_value
                    except Exception:
                        pass

                completed_trade: Dict[str, Any] = {
                    'timestamp': datetime.fromtimestamp(int(timestamp)).strftime('%Y-%m-%d %H:%M:%S') if timestamp.isdigit() else 'Unknown',
                    'symbol': symbol,
                    'tp_level': tp_level,
                    'side': position_side,
                    'size': filled_contracts,
                    'entry_price': entry_price,
                    'exit_price': price,
                    'pnl': pnl
                }
                trades.append(completed_trade)
        
        # 시간순 정렬 (최신 거래가 앞으로)
        trades.sort(key=lambda x: x['timestamp'], reverse=True)
        
        return trades[:limit]
        
    except Exception as e:
        logger.error(f"Error getting PnL history from Redis: {str(e)}")
        return []


async def get_contract_value(symbol: str, contracts_amount: float) -> float:
    """계약 수량에 해당하는 USD 가치를 계산합니다"""
    try:
        # 심볼에 따른 계약 크기 및 가치 계산 로직
        contract_size = await get_contract_size(symbol)
        return float(contracts_amount) * float(contract_size)
    except Exception as e:
        logger.error(f"Error calculating contract value: {str(e)}")
        return contracts_amount  # 기본값으로 계약 수량 반환


async def generate_pnl_statistics_image(user_id: str) -> Optional[str]:
    """
    누적 PnL 시각화를 이미지로 생성 (completed 주문 데이터도 함께 처리)
    """
    try:
        pnl_data: List[Dict[str, Any]] = []
        
        # 1. 기존 PnL 데이터 수집
        pnl_pattern = f"user:{user_id}:pnl:*"
        pnl_keys = await _get_redis_client().keys(pnl_pattern)
        
        for key in pnl_keys:
            data = await _get_redis_client().hgetall(key)
            if data:
                timestamp_str = data.get("timestamp", "0")
                timestamp = int(timestamp_str) if timestamp_str.isdigit() else 0

                pnl_str = data.get("pnl", "0")
                historical_pnl: float = float(pnl_str) if pnl_str != 'None' else 0.0

                symbol = key.split(":")[3]

                pnl_data.append({
                    'timestamp': datetime.fromtimestamp(timestamp),
                    'pnl': historical_pnl,
                    'symbol': symbol
                })
        
        # 2. completed 주문 데이터 수집
        completed_pattern = f"completed:user:{user_id}:*:order:*"
        completed_keys = await _get_redis_client().keys(completed_pattern)
        
        for key in completed_keys:
            data = await _get_redis_client().hgetall(key)
            if data and data.get('status') == 'filled':
                try:
                    parts = key.split(":")
                    symbol = parts[3]
                    
                    timestamp_str = data.get('last_updated_time', data.get('create_time', '0'))
                    if not timestamp_str.isdigit():
                        continue  # 타임스탬프가 유효하지 않으면 건너뛰기
                    
                    timestamp = int(timestamp_str)
                    
                    filled_contracts_str = data.get('filled_contracts_amount', '0')
                    filled_contracts: float = float(filled_contracts_str) if filled_contracts_str != 'None' else 0.0

                    price_str = data.get('price', '0')
                    price: float = float(price_str) if price_str != 'None' else 0.0

                    position_side = data.get('position_side', 'unknown')

                    # 진입가격 정보 가져오기 - 우선 completed 주문 데이터에서 직접 확인
                    entry_price: float = 0.0
                    if 'entry_price' in data:
                        # completed 주문 데이터에 진입가격이 저장되어 있는 경우
                        entry_price_str = data.get('entry_price', '0')
                        entry_price = float(entry_price_str) if entry_price_str != 'None' else 0.0
                    else:
                        # 기존 방식으로 포지션 데이터에서 조회 시도
                        position_key = f"user:{user_id}:position:{symbol}:{position_side}"
                        position_data = await _get_redis_client().hgetall(position_key)
                        if position_data and 'entry_price' in position_data:
                            entry_price_str = position_data.get('entry_price', '0')
                            entry_price = float(entry_price_str) if entry_price_str != 'None' else 0.0

                    # PnL 계산
                    pnl: float = 0.0
                    if entry_price > 0 and price > 0 and filled_contracts > 0:
                        contract_value = await get_contract_value(symbol, filled_contracts)
                        if position_side == 'long':
                            pnl = (price - entry_price) * contract_value
                        else:  # short
                            pnl = (entry_price - price) * contract_value
                    
                    # PnL이 0이면 계산 불가능한 경우이므로 건너뛰기
                    if pnl == 0:
                        continue
                    
                    pnl_data.append({
                        'timestamp': datetime.fromtimestamp(timestamp),
                        'pnl': pnl,
                        'symbol': symbol
                    })
                except Exception as e:
                    logger.error(f"Error processing completed order for PnL chart: {str(e)}")
                    continue
        
        if not pnl_data:
            return None
            
        df = pd.DataFrame(pnl_data)
        df.set_index('timestamp', inplace=True)
        df.sort_index(inplace=True)
        
        # 누적 수익 계산
        df['cumulative_pnl'] = df['pnl'].cumsum()
        
        # 그래프 생성 (누적 PnL 단일 그래프)
        plt.style.use('dark_background')  # 다크 테마 적용
        _, ax = plt.subplots(figsize=(12, 8), facecolor='black')
        
        # 누적 PnL 선 그래프
        ax.plot(df.index, df['cumulative_pnl'], color='cyan', linewidth=2)
        ax.set_title('Cumulative PnL', fontsize=20, color='white')
        ax.set_xlabel('Time', fontsize=14, color='white')
        ax.set_ylabel('PnL', fontsize=14, color='white')
        ax.grid(True, alpha=0.3)
        ax.tick_params(axis='x', rotation=45, colors='white')
        ax.tick_params(axis='y', colors='white')
        
        plt.tight_layout()
        
        # 임시 파일에 저장 후 경로 반환
        with tempfile.NamedTemporaryFile(delete=False, suffix='.png') as tmp_file:
            plt.savefig(tmp_file.name, format='png', dpi=300, bbox_inches='tight', 
                        facecolor='black', edgecolor='none')
            plt.close()
            return tmp_file.name
            
    except Exception as e:
        logger.error(f"Error generating cumulative PnL image: {str(e)}")
        return None

