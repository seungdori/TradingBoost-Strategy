# filename: position_monitor.py

import asyncio
import json
import logging
from celery import shared_task

# src/trading/models에 정의된 Position, PositionState를 그대로 사용
from HYPERRSI.src.trading.models import Position, PositionState
from HYPERRSI.src.trading.trading_service import TradingService
  # 비동기 Redis 클라이언트

logger = logging.getLogger(__name__)

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error

# Module-level attribute for backward compatibility
def __getattr__(name):
    if name == "redis_client":
        return _get_redis_client()
    raise AttributeError(f"module has no attribute {name}")

async def subscribe_order_updates_event(
    user_id: str,
    position: Position,
    trading_service: TradingService,
    poll_interval: float = 10.0
) -> PositionState:
    """
    Redis Pub/Sub 채널을 구독하여 TP/SL 주문 업데이트 이벤트를 기반으로 포지션 상태를 업데이트합니다.
    
    - 이벤트 메시지는 예시:
        {
            "event_type": "order_update",  # 또는 "new_order"
            "order_type": "tp",            # "tp" 또는 "sl"
            "order_id": "tp_order_004",
            "status": "filled"             # 또는 "open"
        }
    - 이벤트에 따라 새 주문이 추가되거나, 기존 주문의 상태를 확인합니다.
    - 주기적으로(짧은 딜레이) 현재 주문 상태도 재확인하여 최종 PositionState를 업데이트합니다.
    """
    channel = f"order_updates:{user_id}:{position.symbol}"
    pubsub = _get_redis_client().pubsub()
    await pubsub.subscribe(channel)
    logger.info(f"Subscribed to channel: {channel}")
    
    pos_state = PositionState(symbol=position.symbol, side=position.side)
    
    try:
        while True:
            # 이벤트 메시지 수신 (없으면 poll_interval까지 대기)
            message = await pubsub.get_message(ignore_subscribe_messages=True, timeout=poll_interval)
            if message:
                try:
                    event = json.loads(message['data'])
                    logger.info(f"Received event: {event}")
                    event_type = event.get("event_type")
                    if event_type == "order_update":
                        order_type = event.get("order_type")
                        order_id = event.get("order_id")
                        if order_type == "tp":
                            status_info = await trading_service.get_order_status(
                                user_id=user_id, order_id=order_id, symbol=position.symbol
                            )
                            if status_info.get("status") == "filled":
                                logger.info(f"TP order {order_id} filled.")
                        elif order_type == "sl":
                            status_info = await trading_service.get_order_status(
                                user_id=user_id, order_id=order_id, symbol=position.symbol
                            )
                            if status_info.get("status") == "filled":
                                logger.info(f"SL order {order_id} filled.")
                    elif event_type == "new_order":
                        order_type = event.get("order_type")
                        new_order_id = event.get("order_id")
                        if order_type == "tp":
                            if new_order_id not in position.tp_order_ids:
                                position.tp_order_ids.append(new_order_id)
                                logger.info(f"New TP order added: {new_order_id}")
                        elif order_type == "sl":
                            position.sl_order_id = new_order_id
                            logger.info(f"SL order updated: {new_order_id}")
                except Exception as e:
                    logger.error(f"Error processing event: {e}")
            
            # 주기적으로 각 주문 상태를 재확인하여 PositionState 업데이트
            tp_executed = 0
            for order_id in position.tp_order_ids:
                try:
                    status = await trading_service.get_order_status(
                        user_id=user_id, order_id=order_id, symbol=position.symbol
                    )
                    if status.get("status") == "filled":
                        tp_executed += 1
                except Exception as e:
                    logger.error(f"Error checking TP order {order_id}: {e}")
            pos_state.tp_executed_count = tp_executed
            
            if position.sl_order_id:
                try:
                    sl_status = await trading_service.get_order_status(
                        user_id=user_id, order_id=position.sl_order_id, symbol=position.symbol
                    )
                    if sl_status.get("status") == "filled":
                        pos_state.sl_filled = True
                except Exception as e:
                    logger.error(f"Error checking SL order {position.sl_order_id}: {e}")
            
            logger.info(f"Current position state: {pos_state}")
            
            # 종료 조건: 모든 TP 주문 체결되거나 SL 주문 체결 시 종료
            if pos_state.tp_executed_count >= len(position.tp_order_ids) or pos_state.sl_filled:
                logger.info(f"Final position state: {pos_state}")
                break
            
            await asyncio.sleep(0.1)
    finally:
        await pubsub.unsubscribe(channel)
        await pubsub.close()
    
    return pos_state

@shared_task
def monitor_position_task(user_id: str, symbol: str):
    """
    Celery Task: 지정한 사용자와 심볼에 대한 포지션을 모니터링합니다.
    
    1. TradingService 인스턴스를 생성하고,
    2. 현재 포지션을 조회한 후,
    3. 이벤트 기반으로 주문 업데이트를 감시합니다.
    
    최종 포지션 상태를 dict 형태로 반환합니다.
    """
    try:
        # 새로운 이벤트 루프 생성 (Celery worker는 기본적으로 동기이므로)
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # TradingService 인스턴스 생성
        trading_service = loop.run_until_complete(TradingService.create_for_user(user_id))
        
        # 현재 포지션 조회 (없으면 모니터링 종료)
        position = loop.run_until_complete(trading_service.get_current_position(user_id, symbol))
        if not position:
            logger.info(f"No active position for user {user_id} on {symbol}.")
            return {"message": "No active position"}
        
        # 이벤트 기반 모니터링 실행
        pos_state = loop.run_until_complete(
            subscribe_order_updates_event(user_id, position, trading_service)
        )
        logger.info(f"Monitoring completed. Final state: {pos_state}")
        return pos_state.__dict__
    except Exception as e:
        logger.error(f"Error in monitor_position_task: {e}")
        return {"error": str(e)}
