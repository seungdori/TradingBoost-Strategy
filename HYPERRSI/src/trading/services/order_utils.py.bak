# src/trading/services/order_utils.py

import asyncio
import datetime
import traceback
import json
from typing import Optional, Dict, Any
import ccxt.async_support as ccxt
from shared.logging import get_logger, log_bot_error

from HYPERRSI.src.trading.models import OrderStatus
from HYPERRSI.src.trading.error_message import map_exchange_error
from shared.utils import safe_float, round_to_qty, convert_symbol_to_okx_instrument
from HYPERRSI.src.trading.cancel_trigger_okx import TriggerCancelClient
from HYPERRSI.src.api.dependencies import get_user_api_keys
from HYPERRSI.src.bot.telegram_message import send_telegram_message
import httpx
from HYPERRSI.src.trading.models import order_type_mapping
from HYPERRSI.src.trading.services.get_current_price import get_current_price
from HYPERRSI.src.core.config import API_BASE_URL
from HYPERRSI.src.api.dependencies import get_exchange_context
from decimal import Decimal, ROUND_DOWN

logger = get_logger(__name__)

# Dynamic redis_client access
def _get_redis_client() -> Any:
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error


# Module-level attribute for backward compatibility
def __getattr__(name: str) -> Any:
    if name == "redis_client":
        return _get_redis_client()
    raise AttributeError(f"module has no attribute {name}")

# íŠ¹ë³„í•œ ì˜ˆì™¸ í´ë˜ìŠ¤ ì¶”ê°€
class InsufficientMarginError(Exception):
    """ìê¸ˆ ë¶€ì¡± ì˜¤ë¥˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì˜ˆì™¸ í´ë˜ìŠ¤"""
    pass

async def cancel_order(
    user_id: str,
    symbol: str,
    order_id: Optional[str] = None,
    side: Optional[str] = None,
    order_type: Optional[str] = None,  # 'limit' | 'market' | 'stop_loss' | 'take_profit' ë“±
    algo_type: str = "trigger"
) -> None:
    """
    OKXì—ì„œ ì§€ì •ëœ order_idì˜ ì£¼ë¬¸ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.
    order_type ë“±ì„ í†µí•´ ì¼ë°˜ ì£¼ë¬¸ / Algo ì£¼ë¬¸ ì·¨ì†Œë¥¼ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
    """
    exchange = None
    try:
        print(f"[ì·¨ì†Œì£¼ë¬¸ {user_id}] : side : {side}, order_id : {order_id}, order_type : {order_type}")
        api_keys = await get_user_api_keys(user_id)
        # âœ… OrderWrapper ì‚¬ìš© (ORDER_BACKEND ìë™ ê°ì§€)
        from HYPERRSI.src.trading.services.order_wrapper import OrderWrapper
        exchange = OrderWrapper(str(user_id), api_keys)

        # 1) OKX ì‹¬ë³¼(InstID) ë³€í™˜ ë¡œì§
        #    ì˜ˆ: 'BTC/USDT:USDT' -> 'BTC-USDT-SWAP'
        #inst_id = convert_symbol_to_okx_instrument(symbol)
        
        # 2) Algo ì£¼ë¬¸ì¸ì§€ ì—¬ë¶€ë¥¼ order_typeì´ë‚˜ order_id ì €ì¥ë°©ì‹ìœ¼ë¡œ íŒë‹¨
        #    ì˜ˆ: order_typeì´ 'stop_loss'ë‚˜ 'take_profit'ì´ë©´ algo ì·¨ì†Œë¡œ ë¶„ê¸°
        is_algo_order = order_type in ('stop_loss', 'trigger', 'conditional')
        
        if is_algo_order:
            # ---- Algo ì£¼ë¬¸ ì·¨ì†Œ ----
            # 1) CCXTì˜ cancelOrder()ë¡œ ì‹œë„ (ê°€ëŠ¥í•œ ë²„ì „ë„ ìˆìŒ)
            #    ì•ˆ ë  ê²½ìš° private_post_trade_cancel_algos() ì§ì ‘ í˜¸ì¶œ

            # (1) cancelOrder() ì‹œë„
            try:
                api_keys = await get_user_api_keys(user_id)
                trigger_cancel_client = TriggerCancelClient(
                    api_key=api_keys.get('api_key'),
                    secret_key=api_keys.get('api_secret'),
                    passphrase=api_keys.get('passphrase')
                )
                # OKXì—ì„œëŠ” cancelOrder() íŒŒë¼ë¯¸í„°ê°€ ë…íŠ¹í•˜ì—¬ algoIdë¡œ ì „ë‹¬
                await trigger_cancel_client.cancel_all_trigger_orders(inst_id = symbol, side = side or "", algo_type = algo_type, user_id = user_id)
                logger.info(f"Canceled algo order {order_id} for {symbol}")
            except Exception as e:
                # (2) cancelOrder()ê°€ ì•ˆ ëœë‹¤ë©´ private_post_trade_cancel_algos() ì§ì ‘ í˜¸ì¶œ
                logger.warning(f"[{user_id}] cancelOrder() failed for algo; trying private_post_trade_cancel_algos. Err={str(e)}")
                try:
                    await exchange.private_post_trade_cancel_algos({
                        "algoId": [order_id],  # ë°°ì—´ë¡œ multiple IDs ê°€ëŠ¥
                        "instId": symbol
                    })
                    logger.info(f"Canceled algo order via private_post_trade_cancel_algos: {order_id}")
                except Exception as e2:
                    logger.error(f"Failed to cancel algo order {order_id} via both ways. {str(e2)}")
                    raise

        else:
            # ---- ì¼ë°˜ ì£¼ë¬¸ ì·¨ì†Œ ----
            await exchange.cancel_order(order_id or "", symbol)
            logger.info(f"Canceled normal order {order_id} for {symbol}")

    except Exception as e:
        logger.error(f"Failed to cancel order {order_id}: {str(e)}")
        raise
    finally:
        if exchange is not None:
            await exchange.close()





async def send_order(
    user_id: str,
    symbol: str,
    side: str,
    size: float,
    leverage: float,
    order_type: str,
    price: Optional[float] = None,
    trigger_price: Optional[float] = None,
    direction: Optional[str] = None,
    exchange: Optional[Any] = None,  # ccxt.Exchange ë˜ëŠ” OrderWrapper
) -> OrderStatus:
    """
    ì£¼ë¬¸ ìƒì„± ë¡œì§(ê¸°ì¡´ _send_order, _try_send_order) í†µí•©/ë¶„ë¦¬
    """
    try:
        # ì²« ì‹œë„
        print("Round TO QTY ì „ì˜ size: ", size)
        # size = await round_to_qty(size, symbol=symbol)  # TODO: Fix round_to_qty call signature
        print("Round TO QTY í›„ì˜ size: ", size)
        
        return await try_send_order(user_id, symbol, side, size, leverage, order_type, price, trigger_price, direction, exchange)
    except Exception as e:
        error_str = str(e)
        
        # ì—ëŸ¬ ì½”ë“œë³„ ì²˜ë¦¬
        if "59000" in error_str:  # ì—´ë¦° ì£¼ë¬¸ ìˆìŒ
            logger.info("ì—´ë¦° ì£¼ë¬¸ì´ ìˆì–´ ì£¼ë¬¸ ì·¨ì†Œ í›„ ì¬ì‹œë„í•©ë‹ˆë‹¤.")
            try:
                await cancel_order(user_id, symbol, side,  order_type=order_type)
                await asyncio.sleep(1)
                return await try_send_order(user_id, symbol, side, size, leverage, order_type, price, trigger_price, direction, exchange)
            except Exception as cancel_error:
                error_msg = (
                    f"âš ï¸ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    f"ì—´ë¦° ì£¼ë¬¸ ì·¨ì†Œ í›„ì—ë„ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n"
                    f"ìˆ˜ë™ìœ¼ë¡œ ì—´ë¦° ì£¼ë¬¸ì„ í™•ì¸í•´ì£¼ì„¸ìš”.\n\n"
                    f"ì—ëŸ¬: {map_exchange_error(cancel_error)}"
                )
                await send_telegram_message(error_msg, user_id)
                raise

        elif "51008" in error_str:  # ì”ê³  ë¶€ì¡±
            error_msg = (
                f"âš ï¸ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ê³„ì¢Œ ì”ê³ ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.\n"
                f"í•„ìš” ì¦ê±°ê¸ˆ: {size} USDT\n"
                f"ë ˆë²„ë¦¬ì§€: {leverage}x"
            )
            await send_telegram_message(error_msg, user_id)
            raise

        elif "51004" in error_str:  # ì£¼ë¬¸ ìˆ˜ëŸ‰ ì œí•œ
            error_msg = (
                f"âš ï¸ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ì£¼ë¬¸ ìˆ˜ëŸ‰ì´ ì œí•œì„ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤.\n"
                f"ì‹œë„í•œ ìˆ˜ëŸ‰: {size}\n"
                f"ì‹¬ë³¼: {symbol}"
            )
            await send_telegram_message(error_msg, user_id)
            raise

        elif "51002" in error_str:  # ë ˆë²„ë¦¬ì§€ ì˜¤ë¥˜
            error_msg = (
                f"âš ï¸ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ë ˆë²„ë¦¬ì§€ ì„¤ì •ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.\n"
                f"ì‹œë„í•œ ë ˆë²„ë¦¬ì§€: {leverage}x"
            )
            await send_telegram_message(error_msg, user_id)
            raise

        elif "51010" in error_str:  # ê°€ê²© ë²”ìœ„ ì´ˆê³¼
            error_msg = (
                f"âš ï¸ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ì£¼ë¬¸ ê°€ê²©ì´ í—ˆìš© ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤.\n"
                f"ì‹œë„í•œ ê°€ê²©: {price}"
            )
            await send_telegram_message(error_msg, user_id)
            raise

        elif "50001" in error_str:  # API í‚¤ ì˜¤ë¥˜
            error_msg = (
                f"âš ï¸ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"API í‚¤ ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n"
                f"API í‚¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
            )
            await send_telegram_message(error_msg, user_id)
            raise

        else:  # ê¸°íƒ€ ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬
            error_msg = (
                f"âš ï¸ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n"
                f"ì—ëŸ¬: {map_exchange_error(e)}\n\n"
                f"ì£¼ë¬¸ ì •ë³´:\n"
                f"ì‹¬ë³¼: {symbol}\n"
                f"ë°©í–¥: {'ë§¤ìˆ˜' if side == 'buy' else 'ë§¤ë„'}\n"
                f"ìˆ˜ëŸ‰: {size}\n"
                f"ê°€ê²©: {price if price else 'ì‹œì¥ê°€'}"
            )
            await send_telegram_message(error_msg, user_id)
            raise


async def store_order_in_redis(user_id: str, order_state: OrderStatus) -> None:
    """
    open_orders ë¦¬ìŠ¤íŠ¸/í•´ì‹œ ë“±ìœ¼ë¡œ ê´€ë¦¬ (ì—¬ê¸°ì„œëŠ” ë¦¬ìŠ¤íŠ¸ ì˜ˆì‹œ)
    - key: user:{user_id}:open_orders
    - value: JSON (OrderStatus)
    """
    redis_key: str = f"user:{user_id}:open_orders"
    existing: Any = await _get_redis_client().get(f"open_orders:{user_id}:{order_state.order_id}")
    if existing:
        return
    order_data: Dict[str, Any] = {
        "order_id": order_state.order_id,
        "symbol": order_state.symbol,
        "side": order_state.side,
        "size": order_state.size,
        "filled_size": order_state.filled_size,
        "status": order_state.status,
        "avg_fill_price": order_state.avg_fill_price,
        "create_time": order_state.create_time.isoformat(),
        "update_time": order_state.update_time.isoformat(),
        "order_type": order_state.order_type,
        "posSide": order_state.posSide
    }
    # ê°„ë‹¨íˆ lpush
    await _get_redis_client().lpush(redis_key, json.dumps(order_data))
    # ì‹¤ì œ ìš´ì˜ ì‹œ "open_orders"ì—ì„œ ìƒíƒœê°€ í™•ì •ëœ ì£¼ë¬¸(= filled or canceled ë“±)ì€ ì œê±°í•˜ê±°ë‚˜ ë³„ë„ ë¦¬ìŠ¤íŠ¸ì— ì˜®ê¸°ëŠ” ì‹ìœ¼ë¡œ ê´€ë¦¬




async def check_margin_block(user_id: str, symbol: str) -> bool:
    """ì‚¬ìš©ìì˜ íŠ¹ì • ì‹¬ë³¼ì— ëŒ€í•œ ìê¸ˆ ë¶€ì¡± ì°¨ë‹¨ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        user_id (int): ì‚¬ìš©ì ID
        symbol (str): ì‹¬ë³¼

    Returns:
        bool: ì°¨ë‹¨ëœ ê²½ìš° True, ì•„ë‹Œ ê²½ìš° False
    """
    block_key: str = f"margin_block:{user_id}:{symbol}"
    block_status: Any = await _get_redis_client().get(block_key)
    return block_status is not None

async def set_margin_block(user_id: str, symbol: str, duration_seconds: int = 600) -> None:
    """ì‚¬ìš©ìì˜ íŠ¹ì • ì‹¬ë³¼ì— ëŒ€í•œ ìê¸ˆ ë¶€ì¡± ì°¨ë‹¨ ìƒíƒœë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
    
    Args:
        user_id (int): ì‚¬ìš©ì ID
        symbol (str): ì‹¬ë³¼
        duration_seconds (int): ì°¨ë‹¨ ì§€ì† ì‹œê°„ (ì´ˆ)
    """
    block_key = f"margin_block:{user_id}:{symbol}"
    block_msg = f"ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•´ {symbol} ê±°ë˜ê°€ {duration_seconds}ì´ˆ ë™ì•ˆ ì°¨ë‹¨ë©ë‹ˆë‹¤."
    await _get_redis_client().set(block_key, "blocked", ex=duration_seconds)
    await send_telegram_message(f"ğŸ”’ {block_msg}", user_id, debug=True)
    logger.warning(f"[{user_id}] {block_msg}")

async def get_margin_retry_count(user_id: str, symbol: str) -> int:
    """ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ ì¬ì‹œë„ íšŸìˆ˜ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

    Args:
        user_id (int): ì‚¬ìš©ì ID
        symbol (str): ì‹¬ë³¼

    Returns:
        int: í˜„ì¬ê¹Œì§€ì˜ ì¬ì‹œë„ íšŸìˆ˜
    """
    retry_key: str = f"margin_retry_count:{user_id}:{symbol}"
    retry_count: Any = await _get_redis_client().get(retry_key)
    return int(retry_count) if retry_count else 0

async def increment_margin_retry_count(user_id: str, symbol: str) -> int:
    """ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ ì¬ì‹œë„ íšŸìˆ˜ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.

    Args:
        user_id (int): ì‚¬ìš©ì ID
        symbol (str): ì‹¬ë³¼

    Returns:
        int: ì¦ê°€ëœ ì¬ì‹œë„ íšŸìˆ˜
    """
    retry_key: str = f"margin_retry_count:{user_id}:{symbol}"
    # 24ì‹œê°„ ë™ì•ˆ ìœ ì§€ (í•„ìš”ì— ë”°ë¼ ì¡°ì • ê°€ëŠ¥)
    retry_count: int = int(await _get_redis_client().incr(retry_key))
    await _get_redis_client().expire(retry_key, 86400)  # 24ì‹œê°„ (ì´ˆ)
    return retry_count

async def reset_margin_retry_count(user_id: str, symbol: str) -> None:
    """ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ ì¬ì‹œë„ íšŸìˆ˜ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
    
    Args:
        user_id (int): ì‚¬ìš©ì ID
        symbol (str): ì‹¬ë³¼
    """
    retry_key = f"margin_retry_count:{user_id}:{symbol}"
    await _get_redis_client().delete(retry_key)

async def try_send_order(
    user_id: str,
    symbol: str,
    side: str,
    size: float,  #amountê°€ ë“¤ì–´ì™€ì•¼í•¨.
    leverage: Optional[float] = None,
    order_type: str = 'market',
    price: Optional[float] = None,
    trigger_price: Optional[float] = None,
    direction: Optional[str] = None,
    exchange: Optional[Any] = None,  # ccxt.Exchange ë˜ëŠ” OrderWrapper
    order_concept: Optional[str] = None,
    max_retries: int = 15,  # ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ë¥¼ 15íšŒë¡œ ë³€ê²½
    retry_count: int = 0   # í˜„ì¬ ì¬ì‹œë„ íšŸìˆ˜ (ë¶ˆí•„ìš”í•˜ì§€ë§Œ ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€)
) -> OrderStatus:
    # ìê¸ˆ ë¶€ì¡± ì°¨ë‹¨ ìƒíƒœ í™•ì¸
    is_blocked: bool = await check_margin_block(user_id, symbol)
    if is_blocked:
        block_msg: str = f"â›”ï¸ ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•´ í˜„ì¬ {symbol} ê±°ë˜ê°€ ì°¨ë‹¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
        await send_telegram_message(block_msg, user_id, debug=True)
        logger.warning(f"[{user_id}] {block_msg}")
        now: datetime.datetime = datetime.datetime.now()
        return OrderStatus(
            order_id="margin_blocked",
            symbol=symbol,
            side=side,
            size=size,
            filled_size=0.0,
            status='rejected',
            avg_fill_price=price or 0.0,
            create_time=now,
            update_time=now,
            order_type=order_type,
            posSide=direction or "net",
        )

    # Redisì—ì„œ í˜„ì¬ ì¬ì‹œë„ íšŸìˆ˜ ê°€ì ¸ì˜¤ê¸°
    current_retry_count: int = await get_margin_retry_count(user_id, symbol)
    
    # ì¬ì‹œë„ íšŸìˆ˜ í™•ì¸
    if current_retry_count >= max_retries:
        error_msg = f"â›”ï¸ ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜({max_retries}íšŒ)ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ë” ì´ìƒ ì£¼ë¬¸ì„ ì‹œë„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
        await send_telegram_message(error_msg, user_id, debug=True)
        logger.error(error_msg)
        # ìê¸ˆ ë¶€ì¡±ì´ ì§€ì†ë  ê²½ìš° ì°¨ë‹¨ ìƒíƒœ ì„¤ì • (10ë¶„)
        await set_margin_block(user_id, symbol, 600)
        
        # ì•Œë¦¼ ë¡œê·¸ ê¸°ë¡
        error_message = f"ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•´ {symbol} ê±°ë˜ê°€ ì¼ì‹œì ìœ¼ë¡œ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤ (10ë¶„)"
        log_bot_error(
            user_id=user_id,
            symbol=symbol,
            error_message=error_message,
            event_type='insufficient_margin',
            block_duration=600
        )
        
        # stop_trading API í˜¸ì¶œí•˜ì—¬ íŠ¸ë ˆì´ë”© ì¤‘ì§€
        try:
            async with httpx.AsyncClient() as client:
                stop_url = f"{API_BASE_URL}/trading/stop"
                response = await client.post(
                    stop_url,
                    json={"okx_uid": str(user_id)}
                )
                if response.status_code == 200:
                    logger.info(f"ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•´ íŠ¸ë ˆì´ë”©ì´ ìë™ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. user_id: {user_id}")
                    # í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡
                    stop_msg = f"âš ï¸ ìê¸ˆ ë¶€ì¡±ì´ 24íšŒ ì´ìƒ ì§€ì†ë˜ì–´ ê±°ë˜ê°€ ìë™ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.\n\nê³„ì¢Œì— ì¶©ë¶„í•œ ìê¸ˆì„ ì…ê¸ˆí•œ í›„ ë‹¤ì‹œ ì‹œì‘í•´ì£¼ì„¸ìš”."
                    await send_telegram_message(stop_msg, user_id)
                else:
                    logger.error(f"ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ íŠ¸ë ˆì´ë”© ì¤‘ì§€ API í˜¸ì¶œ ì‹¤íŒ¨: {response.status_code} - {response.text}")
        except Exception as e:
            logger.error(f"ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ íŠ¸ë ˆì´ë”© ì¤‘ì§€ API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜: {str(e)}")
        
        # íŠ¹ë³„í•œ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œì¼œ ìƒìœ„ í˜¸ì¶œìì—ê²Œ ì•Œë¦¼
        raise InsufficientMarginError(f"ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•´ {symbol} ê±°ë˜ê°€ ì¼ì‹œì ìœ¼ë¡œ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
    
    debug_order_params: Dict[str, Any] = {
        'symbol': symbol,
        'side': side,
        'size': size, #AMountê°€ ë§ë‚˜ í™•ì¸
        'leverage': leverage,
        'order_type': order_type,
        'price': price,
        'trigger_price': trigger_price,
        'direction': direction
    }
    is_contract_size: bool = True
    print(f"DEBUG: ì£¼ë¬¸ ìš”ì²­ -> {debug_order_params}")

    # exchangeê°€ Noneì´ë©´ OrderWrapper ìƒì„±
    need_close: bool = False
    if exchange is None:
        api_keys: Dict[str, Any] = await get_user_api_keys(user_id)
        from HYPERRSI.src.trading.services.order_wrapper import OrderWrapper
        exchange = OrderWrapper(str(user_id), api_keys)
        need_close = True
    else:
        need_close = False
    
    try:
        # ì‹¤ì œ ì‹¤í–‰
        specs_json: Any = await _get_redis_client().get("symbol_info:contract_specifications")
        tick_size: float = 0.001
        current_price: float = 0.0
        
        contracts_amount: str = ""
        if not is_contract_size: #ê¸°ë³¸ì ìœ¼ë¡œ is_contract_sizeê°€ Trueì„. ì´ê±´, ê¸ˆì•¡ìœ¼ë¡œ ë“¤ì–´ì˜¬ ë•Œë§Œì˜ ë¶„ê¸°.
            # ê³„ì•½ ì •ë³´ê°€ ì—†ìœ¼ë©´ account APIë¡œ ì¡°íšŒ
            if not specs_json:
                logger.info(f"ê³„ì•½ ì‚¬ì–‘ ì •ë³´ê°€ ì—†ì–´ ìƒˆë¡œ ì¡°íšŒí•©ë‹ˆë‹¤: {symbol}")
                async with httpx.AsyncClient() as client:
                    response = await client.get(
                        f"{API_BASE_URL}/account/contract-specs",
                        params={
                            "user_id": str(user_id),
                            "force_update": True
                        }
            )
                    if response.status_code != 200:
                        raise ValueError("ê³„ì•½ ì‚¬ì–‘ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨")

                    specs_json = await _get_redis_client().get(f"symbol_info:contract_specifications")
                    if not specs_json:
                        raise ValueError(f"ê³„ì•½ ì‚¬ì–‘ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {symbol}")
            specs_dict: Dict[str, Any] = json.loads(specs_json) if specs_json else {}
            contract_info: Optional[Dict[str, Any]] = specs_dict.get(symbol)

            if not contract_info:
                raise ValueError(f"í•´ë‹¹ ì‹¬ë³¼ì˜ ê³„ì•½ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤: {symbol}")

            current_price = await get_current_price(symbol)
            contract_size: float = float(contract_info.get('contractSize', 0))
            tick_size = float(contract_info.get('tickSize', 0.001))
            size = round(size / contract_size) * contract_size
            position_qty: float = (size / contract_size)
            contracts_amount_float: float = (size * (leverage or 1.0)) / (contract_size * current_price)
            min_size: float = float(contract_info.get('minSize', 1))
            #print("contracts: ", contracts)
            contracts_amount_float = max(min_size, safe_float(contracts_amount_float))
            contracts_amount = "{:.8f}".format(contracts_amount_float)  # ì†Œìˆ˜ì  8ìë¦¬ë¡œ í˜•ì‹í™”
                # (A) position_mode í™•ì¸

        else:
            # ì´ë¯¸ ê³„ì•½ ìˆ˜ëŸ‰ìœ¼ë¡œ ì „ë‹¬ëœ ê²½ìš°. ì´ê²Œ ì¼ë°˜ì ì¸ ìƒí™©.
            #print(f"DEBUG: ì´ë¯¸ ê³„ì•½ ìˆ˜ëŸ‰ìœ¼ë¡œ ì „ë‹¬ëœ ê²½ìš°: {size}")
            contracts_amount = "{:.8f}".format(float(size))

        position_mode: Dict[str, Any] = {'hedged': True, 'marginMode': 'cross'}
        try:
            position_mode = await exchange.fetch_position_mode(symbol=symbol)  # type: ignore
        except Exception as e:
            print("position_mode ì¡°íšŒ ì‹¤íŒ¨: ", e)
            position_mode = {'hedged': True, 'marginMode': 'cross'} #í…ŒìŠ¤íŠ¸ìš©ìœ¼ë¡œ True

        price_str: Optional[str] = None
        trigger_price_str: Optional[str] = None
        if price:
            price_str = "{:.4f}".format(safe_float(price))
        if trigger_price:
            trigger_price_str = "{:.4f}".format(safe_float(trigger_price))

        is_hedge_mode: bool = bool(position_mode.get('hedged', True)) #í…ŒìŠ¤íŠ¸ìš©ìœ¼ë¡œ True
        margin_mode: str = str(position_mode.get('marginMode', 'cross'))
        #sprint(f"is_hedge_mode: {is_hedge_mode}")
        order_params: Dict[str, Any] = {
            'leverage': leverage,
            'tdMode': margin_mode,
        }
        
        if order_type == 'take_profit':
            if not price_str:
                raise ValueError("TP ì£¼ë¬¸ì—ëŠ” ê°€ê²©ì´ í•„ìš”í•©ë‹ˆë‹¤")
            order_params.update({
                'price': price_str,
                'orderType': 'limit',
                'reduceOnly': True
            })
        elif order_type == 'stop_loss':
            order_params.update({
                'triggerPrice': trigger_price_str,
                'orderType': 'trigger',
                'slTriggerPx': trigger_price_str,
                'slOrdPx': price_str if price_str else '-1',
                'reduceOnly': True
            })
        elif order_type == 'limit':
            if not price_str:
                raise ValueError("ì§€ì •ê°€ ì£¼ë¬¸ì—ëŠ” ê°€ê²©ì´ í•„ìš”í•©ë‹ˆë‹¤")
            order_params.update({
                'price': price_str,
                'orderType': 'limit'
            })
        if is_hedge_mode:
            if order_type in ['take_profit', 'stop_loss']:
                if direction == 'long':
                    order_params['posSide'] = 'long'
                    side = 'sell'  # long í¬ì§€ì…˜ì„ ë‹«ìœ¼ë¯€ë¡œ sell
                elif direction == 'short':
                    order_params['posSide'] = 'short'
                    side = 'buy'   # short í¬ì§€ì…˜ì„ ë‹«ìœ¼ë¯€ë¡œ buy
                elif direction is None:
                    if side == 'buy':
                        order_params['posSide'] = 'long'
                    elif side == 'sell':
                        order_params['posSide'] = 'short'
                order_params['reduceOnly'] = True
            else:
                # ì‹ ê·œ í¬ì§€ì…˜ ì§„ì…
                if direction == 'long':
                    order_params['posSide'] = 'long'
                    side = 'buy'
                elif direction == 'short':
                    order_params['posSide'] = 'short'
                    side = 'sell'
                elif direction is None:
                    if side == 'buy':
                        order_params['posSide'] = 'long'
                    elif side == 'sell':
                        order_params['posSide'] = 'short'
                order_params['reduceOnly'] = False
        else:
            print("!!ORDER_PARAMS: ", order_params)
            order_params['posSide'] = 'net'
            if order_type in ['take_profit', 'stop_loss']:
                order_params['reduceOnly'] = True
                
        print(
            f"!ì£¼ë¬¸ ê³„ì‚°: ê³„ì•½ìˆ˜={contracts_amount}, "
        )
        try:
            if order_type == 'take_profit' or order_type == 'stop_loss':
                position: Dict[str, Any] = await exchange.fetch_position(symbol)  # type: ignore
                if not position or float(position.get('contracts', 0)) == 0:
                    logger.warning(f"[{user_id}] í¬ì§€ì…˜ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤. {order_type} ì£¼ë¬¸ì„ ì ì‹œ í›„ ì‹œë„í•©ë‹ˆë‹¤.")
                    await asyncio.sleep(0.5)
                    position = await exchange.fetch_position(symbol)  # type: ignore
                    if not position or float(position.get('contracts', 0)) == 0:
                        raise ValueError(f"[{user_id}] í¬ì§€ì…˜ì´ ì—†ì–´ TP/SL ì£¼ë¬¸ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
        
        order_result: Optional[Dict[str, Any]] = None
        try:
            #print("!!ìµœì¢… ORDER_PARAMS: ", order_params)
            if order_concept == 'new_position' or order_concept == 'add_position':
                print("New Position í˜¹ì€ DCA ì¶”ê°€ì§„ì…ì´ë¯€ë¡œ, ê¸°ì¡´ì˜ ì£¼ë¬¸ ì œê±°")
                # Import here to avoid circular dependency
                from HYPERRSI.src.api.routes.order.order import cancel_all_orders
                from shared.models.exchange import OrderSide as OrderSideEnum
                side_enum: Optional[OrderSideEnum] = OrderSideEnum(side) if side in ('buy', 'sell') else None
                cancel_order_result: Any = await cancel_all_orders(symbol= symbol,user_id=user_id, side=side_enum) #<-- í¬ì§€ì…˜ ë°©í–¥
                #print("cancel_order_result: ", cancel_order_result)

            # ì£¼ë¬¸ ìƒì„± ì „ ë¡œê¹…
            print(f"ğŸ’› ì£¼ë¬¸ ìƒì„± ì‹œë„ -  [ê³„ì•½ìˆ˜: {contracts_amount}], ì‹¬ë³¼: {symbol}, ë°©í–¥: {side},, ê°€ê²©: {price_str}, íƒ€ì…: {order_type}")
            #logger.info(f"ì£¼ë¬¸ íŒŒë¼ë¯¸í„°: {order_params}")
            try:
                order_result = await exchange.create_order(  # type: ignore
                    symbol=symbol,
                    side=side,
                    amount=safe_float(contracts_amount),
                    price=safe_float(price_str) if price_str else 0.0,
                    params=order_params
                )
            except Exception as e:
                traceback.print_exc()
                error_str: str = str(e)

                # ìê¸ˆ ë¶€ì¡± ì˜¤ë¥˜ ê°ì§€
                if "Insufficient USDT margin" in error_str or "Insufficient" in error_str:
                    # Redisì— ì¬ì‹œë„ íšŸìˆ˜ ì¦ê°€
                    current_retry_count = await increment_margin_retry_count(user_id, symbol)
                    
                    # ìê¸ˆ ë¶€ì¡± ì•Œë¦¼ì„ ì œí•œ (ì²˜ìŒ, 5íšŒ, 10íšŒ, 15íšŒì—ë§Œ ì•Œë¦¼)
                    should_notify: bool = current_retry_count in [1, 5, 10, 15]

                    if should_notify:
                        insufficient_msg: str = ""
                        if current_retry_count == 1:
                            insufficient_msg = f"ğŸ’° ìê¸ˆ ë¶€ì¡±: ê³„ì¢Œì— USDT ë§ˆì§„ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.\n{symbol} ì£¼ë¬¸ ì¬ì‹œë„ ì¤‘..."
                        elif current_retry_count == 15:
                            insufficient_msg = f"âš ï¸ ìê¸ˆ ë¶€ì¡±ì´ 15íšŒ ì§€ì†ë˜ì–´ {symbol} ê±°ë˜ë¥¼ 10ë¶„ê°„ ì¼ì‹œ ì¤‘ë‹¨í•©ë‹ˆë‹¤."
                        else:
                            insufficient_msg = f"ğŸ’° ìê¸ˆ ë¶€ì¡± ì§€ì† ì¤‘ ({current_retry_count}/15íšŒ)"

                        await send_telegram_message(insufficient_msg, user_id, debug=True)
                    
                    # 15íšŒ ì´ìƒ ìê¸ˆ ë¶€ì¡± ì‹œ ì¦‰ì‹œ ì°¨ë‹¨
                    if current_retry_count >= 15:
                        # ì¦‰ì‹œ ì°¨ë‹¨ ì„¤ì • (10ë¶„)
                        await set_margin_block(user_id, symbol, 600)
                        
                        # íŠ¹ë³„í•œ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œì¼œ ìƒìœ„ í˜¸ì¶œìì—ê²Œ ì•Œë¦¼
                        raise InsufficientMarginError(f"ìê¸ˆ ë¶€ì¡±ìœ¼ë¡œ ì¸í•´ {symbol} ê±°ë˜ê°€ ì¼ì‹œì ìœ¼ë¡œ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    else:
                        # ì¡°ìš©íˆ ì¬ì‹œë„ (ë©”ì‹œì§€ ì—†ì´)
                        await asyncio.sleep(5)  # 5ì´ˆ ëŒ€ê¸° í›„ ì¬ì‹œë„
                        return await try_send_order(
                            user_id=user_id, 
                            symbol=symbol, 
                            side=side, 
                            size=size, 
                            leverage=leverage, 
                            order_type=order_type,
                            price=price,
                            trigger_price=trigger_price,
                            direction=direction,
                            exchange=exchange,
                            order_concept=order_concept,
                            max_retries=max_retries
                            # retry_count íŒŒë¼ë¯¸í„°ëŠ” ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ (Redisì—ì„œ ê´€ë¦¬)
                        )
                else:
                    # ê¸°ì¡´ ì—ëŸ¬ ë©”ì‹œì§€ ì „ì†¡
                    await send_telegram_message(f"âš ï¸ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: {error_str}\n size: {contracts_amount}, symbol: {symbol}, side: {side}, price: {price}, type: {order_type}", user_id, debug=True)
                
                #print("ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: ", e)
                raise e
            
            # ì£¼ë¬¸ ê²°ê³¼ ë¡œê¹…
            
            print(f"================================================")
            if order_type == 'stop_loss':
                print("stop_loss ì£¼ë¬¸ ê²°ê³¼: ", order_result)

            # ì£¼ë¬¸ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìœ¼ë¯€ë¡œ ìê¸ˆ ë¶€ì¡± ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
            await reset_margin_retry_count(user_id, symbol)

            # order_resultê°€ Noneì¸ ê²½ìš° ì²˜ë¦¬
            if order_result is None:
                error_msg_null: str = f"ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨ (order_result is None) - ì‹¬ë³¼: {symbol}, ë°©í–¥: {side}, ìˆ˜ëŸ‰: {contracts_amount}"
                logger.error(error_msg_null)
                now_null: datetime.datetime = datetime.datetime.now()
                return OrderStatus(
                    order_id="error",
                    symbol=symbol,
                    side=side,
                    size=safe_float(contracts_amount),
                    filled_size=0.0,
                    status='rejected',
                    avg_fill_price=price or current_price,
                    create_time=now_null,
                    update_time=now_null,
                    order_type=order_type,
                    posSide=str(order_params.get('posSide', 'net'))
                )
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì‹¤íŒ¨: {str(e)}")
            traceback.print_exc()
            raise ValueError(f"ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: {str(e)}")
            
        if order_result is None:
            raise ValueError("ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: order_result is None")

        if order_result.get('info', {}).get('sCode') != '0':
            raise ValueError(f"ì£¼ë¬¸ ì‹¤íŒ¨: {order_result.get('info', {}).get('sMsg', 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜')}")

        order_id: Optional[str] = order_result.get('id') or order_result.get('ordId') or order_result.get('order_id') or order_result.get('uuid') or order_result.get('orderId')
        if not order_id:
            raise ValueError("ì£¼ë¬¸ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")

        if order_type in ['market', 'stop_loss']:
            now_market: datetime.datetime = datetime.datetime.now()
            if order_type == 'stop_loss':
                # stop_loss ì£¼ë¬¸ì˜ ê²½ìš° algoIdë¥¼ order_idë¡œ ì‚¬ìš©
                algo_id: Optional[str] = order_result.get('id') or order_result.get('info', {}).get('algoId')
                if not algo_id:
                    raise ValueError("ì•Œê³ ë¦¬ì¦˜ ì£¼ë¬¸ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")

                order_status: OrderStatus = OrderStatus(
                    order_id=algo_id,
                    symbol=symbol,
                    side=side,
                    size=safe_float(contracts_amount),
                    filled_size=0.0,
                    status='open',
                    avg_fill_price=price or trigger_price or 0.0,
                    create_time=now_market,
                    update_time=now_market,
                    order_type=order_type,
                    posSide=str(order_params.get('posSide', 'net'))
                )
                return order_status
            else:
                order_status = OrderStatus(
                    order_id=order_id,
                    symbol=symbol,
                    side=side,
                    size=safe_float(contracts_amount),
                    filled_size=safe_float(contracts_amount) if order_type == 'market' else 0.0,
                    status='filled' if order_type == 'market' else 'open',
                    avg_fill_price=current_price if order_type == 'market' else (price or 0.0),
                    create_time=now_market,
                    update_time=now_market,
                    order_type=order_type,
                    posSide=str(order_params.get('posSide', 'net'))
                )
                return order_status
        await asyncio.sleep(0.5)
        order_status_dict: Dict[str, Any] = {}
        try:
            print("order id : ", order_id, "symbol : ", symbol)
            if order_type == 'stop_loss':
                # Import here to avoid circular dependency
                from HYPERRSI.src.api.routes.order.order import get_algo_order_info
                order_status_response: Dict[str, Any] = await get_algo_order_info(
                    user_id = user_id, symbol = symbol, order_id = order_id
                )

                #print("order_status: ", order_status_response)

                status_mapping: Dict[str, str] = {
                    "live": "open",
                    "canceled": "canceled",
                    "partially_filled": "partially_filled",
                    "filled": "filled",
                    "failed": "rejected",
                    "closed": "closed"
                }

                status_str: str = status_mapping.get(str(order_status_response.get('state', 'open')), 'open')
                print(f"[order_status]: {status_str}")
                if order_status_response.get('data') and len(order_status_response['data']) > 0:
                    order_status_dict = order_status_response['data'][0]
                    print("order_status: ", order_status_dict)
                    return order_status_dict  # type: ignore
                else:
                    raise ValueError(f"[{user_id}]ì•Œê³  ì£¼ë¬¸ ì¡°íšŒ ì‹¤íŒ¨")
            else:
                order_status_dict = await exchange.fetch_order(order_id, symbol)
        except Exception as e:
            traceback.print_exc()
            logger.warning(f"[{user_id}] ì£¼ë¬¸ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨, ì´ˆê¸°ê°’ìœ¼ë¡œ ì²˜ë¦¬: {str(e)}")
            order_status_dict = {
                'filled': 0.0,
                'average': price or current_price,
                'status': 'open'
            }

        filled_size: float = safe_float(order_status_dict.get('filled', contracts_amount if order_type == 'market' else 0.0))
        avg_fill_price: float = safe_float(order_status_dict.get('average', price or current_price))
        status_str = str(order_status_dict.get('status', 'open'))

        now = datetime.datetime.now()
        order_state: OrderStatus = OrderStatus(
            order_id=order_id,
            symbol=symbol,
            side=side,
            size=safe_float(contracts_amount),
            filled_size=filled_size,
            status=status_str,
            avg_fill_price=avg_fill_price,
            create_time=now,
            update_time=now,
            order_type=order_type,
            posSide=str(order_params.get('posSide', 'net'))
        )
        logger.info(f"ì£¼ë¬¸ ì„±ê³µ: {order_state}")

        if order_type in ['take_profit', 'stop_loss']:
            order_state.order_type = order_type
            # Note: OrderStatus doesn't have trigger_price attribute
            # order_state.trigger_price = trigger_price
            
        await store_order_in_redis(user_id, order_state)
        return order_state
            
    except Exception as e:
        logger.error(f"_send_order() ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()
        raise
    finally:
        # ìƒˆë¡œ ìƒì„±í•œ exchangeë§Œ ë‹«ê¸°
        if need_close and exchange is not None:
            await exchange.close()




async def get_order_info(
    user_id: str,
    symbol: str,
    order_id: str,
    is_algo: bool = False,
    algo_type: str = "trigger",
    exchange: Optional[Any] = None,

) -> Dict[str, Any]:
    try:
        if not exchange:
            return {"status": "error", "id": order_id, "info": {"error": "Exchange not provided"}}

        if not is_algo:
            # 1) ì¼ë°˜ ì£¼ë¬¸ ì¡°íšŒ
            order: Dict[str, Any] = await exchange.fetch_order(order_id, symbol)
            # ccxtì˜ order êµ¬ì¡°: https://docs.ccxt.com/en/latest/manual.html#order-structure
            return {
                "status": str(order.get("status", "")).lower(),  # "open", "closed"(=filled), "canceled"
                "id": order.get("id"),
                "info": order.get("info", {})
            }
        else:
            # 2) OKX ALGO ì£¼ë¬¸ ì¡°íšŒ
            # OKXì˜ algo ì£¼ë¬¸ì„ ì¡°íšŒí•  ë• ccxt í‘œì¤€í•¨ìˆ˜ë¡œ ì•ˆ ë  ìˆ˜ ìˆìŒ => custom endpoint ì‚¬ìš©
            # ì•„ë˜ëŠ” OKX REST API ì˜ˆì‹œ(ë¬¸ì„œ ì°¸ê³ ):
            #   GET /api/v5/trade/orders-algo
            #   ë˜ëŠ” GET /api/v5/trade/orders-algo-history
            # CCXT okx ê°ì²´ì—ì„œ ì œê³µí•˜ëŠ” í”„ë¼ì´ë¹— ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì•¼ í•  ìˆ˜ ìˆìŒ

            # (A) í˜¹ì€ ccxtì—ëŠ” fetch_orders_by_algo()ê°€ ì—†ìœ¼ë¯€ë¡œ, ì•„ë˜ì²˜ëŸ¼ raw ë©”ì„œë“œë¥¼ ì§ì ‘ ì‚¬ìš©:
            params: Dict[str, Any] = {
                "algoId": order_id,
                "ordType": algo_type,
                "instId": symbol,   # í•„ìš”ì‹œ ì‹¬ë³¼ë„ ê°™ì´
            }
            # ëŒ€ê¸°: CCXT OKX ë‚´ë¶€ì— ë”°ë¼ í•¨ìˆ˜ëª…ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ.
            #      ë³´í†µì€ exchange.okxPrivateGetTradeOrdersAlgoListAlgo(params) ì‹ìœ¼ë¡œ ì§ì ‘ í˜¸ì¶œ.
            response: Dict[str, Any] = await exchange.privateGetTradeOrdersAlgoHistory(params)

            # response ì˜ˆì‹œ:
            # {
            #   "data": [
            #     {
            #       "algoId": "...",
            #       "state": "live" or "effective" or "cancelled" or "partially_effective" ...
            #       ...
            #     }
            #   ],
            #   "code": "0", "msg": ""
            # }

            data_list: list = response.get("data", [])
            if not data_list:
                return {"status": "not_found", "id": order_id, "info": {}}

            algo_info: Dict[str, Any] = data_list[0]
            # OKX ALGO ì£¼ë¬¸ ìƒíƒœ(state):
            #   - "live": ì£¼ë¬¸ ìƒì„±ë¨ (ëŒ€ê¸°ì¤‘)
            #   - "effective": ì£¼ë¬¸ì´ ì‹œì¥ì— ë°œë™ë˜ì–´ "filled" or "partially_filled" ìƒíƒœê°€ ë  ìˆ˜ ìˆìŒ
            #   - "cancelled": ì·¨ì†Œë¨
            #   - "order_failed": ì£¼ë¬¸ì‹¤íŒ¨
            #   - ...
            algo_state: str = str(algo_info.get("state", "")).lower()

            # ALGO ìƒíƒœ -> ccxt order.statusì— ë§¤í•‘ (í•„ìš”ì‹œ ì»¤ìŠ¤í…€)
            status: str = ""
            if algo_state in ["effective", "partially_filled", "filled"]:
                # OKX ë¬¸ì„œì— ë”°ë¼ ì‹¤ì œ "filled"ë¥¼ êµ¬ë¶„í•´ì•¼ í•¨
                # ì˜ˆ: partially_filled => ì¼ë¶€ì²´ê²°, fully_filled => ì „ì²´ì²´ê²°
                # ì—¬ê¸°ì„œëŠ” ì˜ˆì‹œë¡œ "effective"=open, "filled"=closed ì²˜ë¦¬
                # ì‹¤ì œë¡œëŠ” fillPx, fillSz ë“±ì„ í™•ì¸í•´ì•¼ ì •í™•í•´ì§
                status = "filled" if algo_state == "filled" else "open"
            elif algo_state in ["canceled", "cancelled"]:
                status = "canceled"
            elif algo_state in ["live", "order_pending"]:
                status = "open"
            else:
                status = "unknown"

            return {
                "status": status,
                "id": order_id,
                "info": algo_info
            }

    except ccxt.NetworkError as e:
        logger.error(f"get_order_info - NetworkError: {str(e)}")
        return {"status": "error", "id": order_id, "info": {"error": str(e)}}
    except ccxt.ExchangeError as e:
        logger.error(f"get_order_info - ExchangeError: {str(e)}")
        return {"status": "error", "id": order_id, "info": {"error": str(e)}}
    except Exception as e:
        traceback.print_exc()
        logger.error(f"get_order_info - UnknownError: {str(e)}")
        return {"status": "error", "id": order_id, "info": {"error": str(e)}}
    
    
