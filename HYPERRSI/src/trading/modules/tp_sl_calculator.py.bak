# HYPERRSI/src/trading/modules/tp_sl_calculator.py
"""
TP/SL Calculator

TP(익절)와 SL(손절) 가격 계산 및 업데이트 로직
"""

import traceback
from typing import Optional, List, Tuple

from HYPERRSI.src.core.database import TradingCache
from HYPERRSI.src.api.routes.order import update_stop_loss_order
from HYPERRSI.src.trading.models import UpdateStopLossRequest
from shared.utils import safe_float, round_to_tick_size, get_tick_size_from_redis
from shared.logging import get_logger

logger = get_logger(__name__)

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error


# Module-level attribute for backward compatibility
def __getattr__(name):
    if name == "redis_client":
        return _get_redis_client()
    raise AttributeError(f"module has no attribute {name}")


class TPSLCalculator:
    """TP/SL 가격 계산 및 관리 서비스"""

    def __init__(self, trading_service):
        """
        Args:
            trading_service: TradingService 인스턴스
        """
        self.trading_service = trading_service

    async def update_stop_loss(
        self,
        user_id: str,
        symbol: str,
        side: str,
        new_sl_price: float,
        old_order_id: Optional[str] = None
    ) -> bool:
        """
        스탑로스 가격 업데이트

        Args:
            user_id: 사용자 ID
            symbol: 거래 심볼
            side: 포지션의 사이드. "long" or "short"
            new_sl_price: 새로운 SL 가격

        Returns:
            bool: 업데이트 성공 여부

        Raises:
            ValueError: 유효하지 않은 SL 가격
        """
        print("update_stop_loss 호출")
        async with self.trading_service.position_lock(user_id, symbol):  # 포지션별 락 사용
            try:
                # 1. 현재 포지션 확인
                position = await self.trading_service.get_current_position(user_id, symbol, side)
                if not position or position.side != side or position.symbol != symbol:
                    logger.warning(f"[{user_id}] 업데이트할 {side} 포지션이 없습니다.")
                    await TradingCache.remove_position(str(user_id), symbol, side)
                    return False

                # 2. SL 가격 유효성 검사
                current_price = await self.trading_service.market_data.get_current_price(symbol)

                if side == "long":
                    if new_sl_price >= current_price:
                        raise ValueError("롱 포지션의 SL은 현재가보다 낮아야 합니다")

                else:  # short
                    if new_sl_price <= current_price:
                        raise ValueError("숏 포지션의 SL은 현재가보다 높아야 합니다")

                # 3. 거래소 API로 SL 주문 업데이트
                old_order_id = position.sl_order_id
                try:
                    new_order = await update_stop_loss_order(
                        sl_request=UpdateStopLossRequest(
                            new_sl_price=new_sl_price,
                            symbol=symbol,
                            side=side,
                            order_side="sell" if side == "long" else "buy",
                            size=position.size
                        ),
                        user_id=str(user_id)
                    )
                except Exception as e:
                    logger.error(f"SL 업데이트 실패: {str(e)}")
                    traceback.print_exc()
                    return False
                if not new_order.get('success', True):  # success가 False면
                    logger.info(f"SL update skipped: {new_order.get('message')}")
                    return False

                # 4. Redis 포지션 정보 업데이트
                position.sl_price = new_sl_price
                position.sl_order_id = new_order['id']

                position_key = f"user:{user_id}:position:{symbol}:{side}"
                async with _get_redis_client().pipeline() as pipe:
                    pipe.hset(
                        position_key,
                        mapping={
                            "symbol": position.symbol,
                            "side": position.side,
                            "size": str(position.size),
                            "entry_price": str(position.entry_price),
                            "leverage": str(position.leverage),
                            "sl_order_id": str(new_order['id']),
                            "sl_price": str(new_sl_price),
                            "order_id": str(new_order['id'])
                        }
                    )
                    await pipe.execute()

                logger.info(
                    f"SL 업데이트 성공: user={user_id}, symbol={symbol}, id={new_order['id']}, "
                    f"side={side}, new_sl={new_sl_price}"
                )
                return True

            except Exception as e:
                traceback.print_exc()
                logger.error(f"SL 업데이트 실패: {str(e)}")
                # 실패 시 롤백 시도
                if 'new_order' in locals():
                    try:
                        await self.trading_service.exchange.cancel_order(new_order['id'], symbol)
                    except Exception as cancel_error:
                        logger.error(f"롤백 실패: {str(cancel_error)}")
                raise Exception(f"스탑로스 업데이트 실패: {str(e)}")

    async def calculate_tp_prices(
        self,
        user_id: str,
        current_price: float,
        settings: dict,
        side: str,  # 'long' 또는 'short'
        atr_value: Optional[float] = None,
        symbol: Optional[str] = None,
        order_concept: Optional[str] = None
    ) -> List[float]:
        """
        TP 가격들을 계산합니다.
        Args:
            user_id: 사용자 ID
            current_price: 현재 가격
            settings: Redis에서 가져온 설정값
            side: 포지션 방향 ('long' 또는 'short')
            atr_value: ATR 값 (ATR 기준일 경우 필요)
            symbol: 거래 심볼 (옵션)
        Returns:
            List[float]: 계산된 TP 가격들의 리스트
        """
        if not settings:
            logger.error("Settings dictionary is empty")
            return []
        position_avg_price = None
        try:
            # OKX fetcher를 통해 포지션 평균가 조회
            position_avg_price = await self.trading_service.okx_fetcher.get_position_avg_price(user_id, symbol, side)
        except Exception as e:
            position_avg_price = current_price
        if not current_price or current_price <= 0:
            logger.error(f"Invalid current price: {current_price}")
            return []
        if position_avg_price is None or position_avg_price <= 0:
            position_avg_price = current_price
        try:
            tp_prices: list[float] = []
            if not any([settings.get(f'use_tp{i}') for i in range(1, 4)]):
                return tp_prices

            tp_option = settings.get('tp_option')
            # tp_option 유효성 검사
            if tp_option not in ['ATR 기준', '퍼센트 기준', '가격 기준']:
                logger.error(f"Invalid TP option: {tp_option}")
                return []
            multiplier = 1 if side == 'long' else -1  # 방향에 따른 승수
            logger.info(f"[TP 계산] side: {side}, multiplier: {multiplier}, position_avg_price: {position_avg_price}, current_price: {current_price}")

            for i in range(1, 4):
                tp_value = safe_float(settings.get(f'tp{i}_value', 0))
                if tp_value <= 0:
                    continue

                if tp_option == 'ATR 기준':
                    if not atr_value or atr_value <= current_price * 0.001:
                        atr_value = current_price * 0.01 * 0.1

                    raw_tp_price = position_avg_price + (multiplier * atr_value * tp_value)

                    if side == "long":
                        tp_price = max(raw_tp_price, position_avg_price * 1.0001, current_price * 1.0001)
                    else:
                        tp_price = min(raw_tp_price, position_avg_price * 0.9999, current_price * 0.9999)

                    original_tp_price = tp_price
                    tp_price = await round_to_tick_size(tp_price, position_avg_price, symbol)

                elif tp_option == '퍼센트 기준':
                    tp_percent = tp_value / 100

                    raw_tp_price = position_avg_price * (1 + (multiplier * tp_percent))

                    if side == "long":
                        tp_price = max(raw_tp_price, position_avg_price * 1.0001, current_price * 1.0001)
                    else:
                        tp_price = min(raw_tp_price, position_avg_price * 0.9999, current_price * 0.9999)
                        logger.info(f"[TP{i} 계산] Short TP: min({raw_tp_price}, {position_avg_price * 0.9999}, {current_price * 0.9999}) = {tp_price}")

                    original_tp_price = tp_price
                    tp_price = await round_to_tick_size(tp_price, position_avg_price, symbol)

                elif tp_option == '가격 기준':
                    raw_tp_price = position_avg_price + (multiplier * tp_value)

                    if side == "long":
                        tp_price = max(raw_tp_price, position_avg_price * 1.0001, current_price * 1.0001)
                    else:
                        tp_price = min(raw_tp_price, position_avg_price * 0.9999, current_price * 0.9999)

                    original_tp_price = tp_price
                    tp_price = await round_to_tick_size(tp_price, position_avg_price, symbol)
                else:
                    continue

                tp_prices.append(tp_price)

            logger.debug(f"=========\ntp_prices: {tp_prices}\n=========")
            # 롱은 오름차순, 숏은 내림차순으로 정렬
            return sorted(tp_prices, reverse=(side == 'short'))
        except Exception as e:
            logger.error(f"TP 가격 계산 실패: {str(e)}")
            traceback.print_exc()
            return []

    async def get_position_mode(self, user_id: str, symbol: str) -> Tuple[str, str]:
        """
        거래소 API를 통해 포지션 모드를 조회합니다.

        Args:
            user_id (int): 사용자 ID
            symbol (str): 심볼 (예: "BTC-USDT-SWAP")

        Returns:
            Tuple[str, str]: 포지션 모드 ("hedge" 또는 "one-way"), tdMode
        """
        try:
            # 거래소 API를 통해 포지션 모드 조회
            try:
                position_mode = await self.trading_service.client.fetch_position_mode(symbol=symbol)
            except Exception as e:
                traceback.print_exc()
                logger.error(f"2포지션 모드 조회 실패: {str(e)}")
                return "hedge", "cross"

            is_hedge_mode = position_mode.get('hedged', True)
            td_mode = position_mode.get('tdMode', 'cross')

            # Redis에 캐시 (bool을 문자열로 변환)
            await _get_redis_client().set(f"user:{user_id}:position:{symbol}:hedge_mode", str(is_hedge_mode).lower())
            await _get_redis_client().set(f"user:{user_id}:position:{symbol}:tdMode", td_mode)

            return str(is_hedge_mode).lower(), td_mode

        except Exception as e:
            logger.error(f"포지션 모드 조회 실패: {str(e)}")
            traceback.print_exc()
            # Redis에 캐시된 값이 있으면 사용
            cached_mode = await _get_redis_client().get(f"user:{user_id}:position:{symbol}:hedge_mode")
            cached_tdMode = await _get_redis_client().get(f"user:{user_id}:position:{symbol}:tdMode")
            return cached_mode if cached_mode else "true", cached_tdMode if cached_tdMode else "cross"

    async def calculate_sl_price(
        self,
        current_price: float,
        side: str,
        settings: dict,
        symbol: Optional[str] = None,
        atr_value: Optional[float] = None
    ) -> Optional[float]:
        """
        설정에 따른 SL 가격 계산

        Args:
            current_price: 현재 가격
            side: 포지션 방향 ("long" or "short")
            settings: SL 설정 딕셔너리
            symbol: 거래 심볼 (옵션)
        Returns:
            Optional[float]: 계산된 SL 가격 또는 None
        """
        if not settings.get('use_sl'):
            return None
        try:
            tick_size = await get_tick_size_from_redis(symbol)
        except Exception as e:
            logger.error(f"틱 사이즈 조회 실패: {str(e)}")
            return None

        sl_option = settings.get('sl_option')
        sl_value = safe_float(settings.get('sl_value', 0))
        if not sl_value or sl_value <= 0:
            return None

        if sl_option == '퍼센트 기준':
            sl_percent = sl_value / 100
            sl_price = (current_price * (1 - sl_percent) if side == "long"
                        else current_price * (1 + sl_percent))
            sl_price = await round_to_tick_size(sl_price, current_price, symbol)
            return float(sl_price) if sl_price else None
        elif sl_option == '가격 기준':
            sl_price = (current_price - sl_value if side == "long"
                        else current_price + sl_value)
            sl_price = await round_to_tick_size(sl_price, current_price, symbol)
            return float(sl_price) if sl_price else None
        elif sl_option == 'ATR 기준':
            if atr_value is None or atr_value <= current_price * 0.001:
                atr_value = current_price * 0.001  # ATR이 없을 경우 현재가의 0.1%를 사용
            sl_price = current_price - (atr_value * sl_value) if side == "long" else current_price + (atr_value * sl_value)
            sl_price = await round_to_tick_size(sl_price, current_price, symbol)
            return float(sl_price) if sl_price else None

        return None
