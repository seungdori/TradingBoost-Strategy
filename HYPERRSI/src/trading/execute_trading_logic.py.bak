# execute_trading_logic.py

import asyncio
import json
from os import error
import traceback
from datetime import datetime
from typing import Dict
from src.helpers.order_helper import contracts_to_qty
from src.trading.trading_service import TradingService
from src.trading.models import Position
from src.api.trading.Calculate_signal import TrendStateCalculator
from src.services.redis_service import RedisService
from src.bot.telegram_message import send_telegram_message
from src.core.database import redis_client
from src.trading.dual_side_entry import manage_dual_side_entry
from src.trading.stats import update_trading_stats, record_trade_entry
from src.trading.services.calc_utils import get_contract_size, round_to_qty
import telegram_message
from src.trading.error_message import map_exchange_error
from src.trading.position_manager import PositionStateManager
from src.core.logger import get_logger, setup_error_logger
from src.trading.tp_sl_monitor import monitor_tp_sl
from src.trading.services.get_current_price import get_current_price
from src.api.routes.position import open_position_endpoint
import time
from src.trading.models import tf_mapping
from src.api.routes.position import OpenPositionRequest
from src.core.event_loop_manager import EventLoopManager
from src.utils.status_utils import get_symbol_status

def ensure_async_loop():
    """
    현재 스레드에 사용 가능한 이벤트 루프를 반환하거나 새로 생성합니다.
    닫힌 루프나 다른 스레드의 루프는 사용하지 않습니다.
    """
    try:
        # 현재 실행 중인 루프가 있는지 확인
        loop = asyncio.get_running_loop()
        logger.debug("실행 중인 이벤트 루프를 사용합니다.")
        return loop
    except RuntimeError:
        # 현재 실행 중인 루프가 없는 경우
        pass
    
    try:
        # 기존 루프가 있는지 확인
        loop = asyncio.get_event_loop()
        
        # 루프가 닫혀있는지 확인
        if loop.is_closed():
            logger.info("기존 이벤트 루프가 닫혀 있어 새로 생성합니다")
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        return loop
    except RuntimeError as ex:
        # 루프가 아예 없는 경우
        if "There is no current event loop in thread" in str(ex):
            logger.info("이벤트 루프가 없어 새로 생성합니다")
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            return loop
        
        # 그 외 예상치 못한 오류
        logger.error(f"이벤트 루프 생성 중 오류 발생: {str(ex)}")
        raise

logger = get_logger(__name__)
error_logger = setup_error_logger()

# ─────────────────────────────────────────────────────────────────────────
# (A) 간단 유틸 함수
# ─────────────────────────────────────────────────────────────────────────

async def init_user_position_data(user_id: int, symbol: str, side: str):
    position_state_key = f"user:{user_id}:position:{symbol}:position_state"
    tp_data_key = f"user:{user_id}:position:{symbol}:{side}:tp_data"
    dca_count_key = f"user:{user_id}:position:{symbol}:{side}:dca_count"
    dca_levels_key = f"user:{user_id}:position:{symbol}:{side}:dca_levels"
    position_key = f"user:{user_id}:position:{symbol}:{side}"
    min_size_key = f"user:{user_id}:position:{symbol}:min_sustain_contract_size"
    #main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
    tp_state = f"user:{user_id}:position:{symbol}:{side}:tp_state"
    hedging_direction_key = f"user:{user_id}:position:{symbol}:hedging_direction"
    entry_fail_count_key = f"user:{user_id}:entry_fail_count"
    await redis_client.delete(position_state_key)
    await redis_client.delete(tp_data_key)
    await redis_client.delete(dca_count_key)
    await redis_client.delete(dca_levels_key)
    await redis_client.delete(position_key)
    await redis_client.delete(min_size_key)
    #await redis_client.delete(main_position_direction_key)
    await redis_client.delete(tp_state)
    await redis_client.delete(entry_fail_count_key)
    await redis_client.delete(hedging_direction_key)

class TPPrice:
    def __init__(self):
        self.prices: Dict[str, float] = {}  # price: ratio

# 2. 데이터 저장/조회 시 형식 강제
async def store_tp_prices(user_id: str, symbol: str, side: str, tp_prices: Dict[str, float]):
    tp_data_key = f"user:{user_id}:position:{symbol}:{side}:tp_data"
    await redis_client.set(tp_data_key, json.dumps(tp_prices))

async def get_tp_prices(user_id: str, symbol: str, side: str) -> Dict[str, float]:
    tp_data_key = f"user:{user_id}:position:{symbol}:{side}:tp_data"
    data = await redis_client.get(tp_data_key)
    return json.loads(data) if data else {}

async def is_trading_running(user_id: int) -> bool:
    """trading_status 확인 후 'running'이면 True, 아니면 False."""
    status = await redis_client.get(f"user:{user_id}:trading:status")
    return (status == "running")


# ─────────────────────────────────────────────────────────────────────────
# (C) DCA 계산/검사 관련 유틸
# ─────────────────────────────────────────────────────────────────────────
async def calculate_dca_levels(entry_price: float, settings: dict, side: str, atr_value: float, current_price: float) -> list:
    pyramiding_entry_type = settings.get('pyramiding_entry_type', '퍼센트 기준')
    pyramiding_value = settings.get('pyramiding_value', 3.0)
    pyramiding_limit = settings.get('pyramiding_limit', 3)
    entry_criterion = settings.get('entry_criterion', '평균 단가')


    if entry_criterion == "평균 단가":
        entry_price = entry_price
    else:
        entry_price = current_price
    dca_levels = []
    if pyramiding_entry_type == "퍼센트 기준":
        if side == "long":
            level = entry_price * (1 - (pyramiding_value/100))
        else:
            level = entry_price * (1 + (pyramiding_value/100))
    elif pyramiding_entry_type == "금액 기준":
        if side == "long":
            level = entry_price - (pyramiding_value)
        else:
            level = entry_price + (pyramiding_value)
    else:  # ATR 기준이라 가정
        #print("ATR 기준으로 계산") #<-- 문제 없음. 
        # 실제 ATR 계산 로직은 별도
        if side == "long":
            level = entry_price - (atr_value * (pyramiding_value))
        else:
            level = entry_price + (atr_value * (pyramiding_value))
    dca_levels.append(level)

    return dca_levels

async def update_dca_levels_redis(user_id: int, symbol: str, dca_levels: list, side: str):
    dca_key = f"user:{user_id}:position:{symbol}:{side}:dca_levels"
    await redis_client.delete(dca_key)
    if dca_levels:
        await redis_client.rpush(dca_key, *[str(level) for level in dca_levels])

async def check_dca_condition(current_price: float, dca_levels: list, side: str, use_check_DCA_with_price: bool) -> bool:
    if use_check_DCA_with_price:
        if not dca_levels:
            return False
        next_dca_level = float(dca_levels[0])
        if side == "long":
            return current_price <= next_dca_level
        else:
            return current_price >= next_dca_level
    else:
        return True



async def create_position_message(
    user_id: int,
    symbol: str,
    position_type: str,  # "long" or "short"
    position,
    settings: dict,
    tp_levels=None,
    stop_loss=None,
    contracts_amount=None, #contract size로 들어옴. 
    trading_service: TradingService = None,
    atr_value=None
):
    try:
        
        #여기로 들어오는 size가, contract size로 들어옴. 따라서 qty로 변환 필요.
        position_qty = await trading_service.contract_size_to_qty(user_id=user_id, symbol=symbol, contracts_amount=contracts_amount)
        
        # 기본 메시지 구성
        print(f"[{user_id}] position 정보 확인 : \n", position)
        emoji = "📈" if position_type == "long" else "📉"
        message_parts = [
            f"{emoji} {'롱' if position_type == 'long' else '숏'} 포지션 진입",
            "━━━━━━━━━━━━━━━",
            f"💎 심볼: {symbol}",
            f"💰 주문금액: {settings['investment']} USDT",
            f"🪜 레버리지: {settings['leverage']}x",
            f"💲 진입가격: {position.entry_price:.2f}",
            f"📊 포지션 크기: {position_qty:.4g}"
        ]

        # TP 정보가 있는 경우에만 추가
        if tp_levels:
            message_parts.extend([
                "",
                "🎯 목표가격"
            ])
            
            # tp_levels 형식에 따른 처리
            if isinstance(tp_levels, list):
                # 리스트인 경우 (가격만 있는 경우)
                for i, price in enumerate(tp_levels, 1):
                    message_parts.append(f"TP{i}: {float(price):,.2f} $")
            elif isinstance(tp_levels, dict):
                # 딕셔너리인 경우 (가격과 비율이 있는 경우)
                for i, (price, ratio) in enumerate(tp_levels.items(), 1):
                    message_parts.append(f"TP{i}: {float(price):.2f} ({float(ratio)*100:.0f}%)")
            else:
                # 기타 형식의 경우
                for i, tp_info in enumerate(tp_levels, 1):
                    if isinstance(tp_info, (list, tuple)):
                        price, ratio = tp_info
                        message_parts.append(f"TP{i}: {float(price):,.2f} $ ({float(ratio)*100:.0f}%)")
                    else:
                        message_parts.append(f"TP{i}: {float(tp_info):,.2f} $")

        # SL 정보가 있는 경우에만 추가
        if stop_loss:
            message_parts.extend([
                "",
                "🛑 손절가격",
                f"{float(stop_loss):,.2f} $"
            ])

        dca_key = f"user:{user_id}:position:{symbol}:{position_type}:dca_levels"
        current_price = await get_current_price(symbol)
        dca_levels = await calculate_dca_levels(position.entry_price, settings, position_type, atr_value, current_price)
        await update_dca_levels_redis(user_id, symbol, dca_levels, position_type)

        print(f"[{user_id}] 🖤dca_levels: {dca_levels}")
        if dca_levels and len(dca_levels) > 0:
            dca_levels = [float(level) for level in dca_levels]  # 문자열을 float로 변환
            next_level = max(dca_levels) if position_type == 'long' else min(dca_levels)
            message_parts.extend([
                "",
                f"📍 다음 진입가능 레벨\n {next_level:,.2f}$"
            ])


        return "\n".join(message_parts)
    except Exception as e:
        logger.error(f"포지션 메시지 생성 오류: {str(e)}")
        traceback.print_exc()
        return "포지션 정보를 가져오는 중 오류가 발생했습니다."

#def create_close_position_message(side: str, current_price: float, entry_price: float, size: float) -> str:
#    try:
#        direction = "롱" if side == "long" else "숏"
#        pnl = size * (current_price - entry_price) if side == "long" else size * (entry_price - current_price)
#        pnl_emoji = "🟢 +" if pnl > 0 else "🔴 " if pnl < 0 else "⚪"
        

#        return (
#            f"📊 포지션 청산 완료\n"
#            f"━━━━━━━━━━━━━━━\n"
#            f"📍 방향: {direction}\n"
#            f"💰 청산가: {current_price:.2f}\n"
#            f"📈 크기: {size:.4g}\n"
#            f"💵 손익: {pnl_emoji} {pnl:.2f} USDT\n"
#            f"\n"
#            f"📝 사유: 트랜드 반전 감지"
#        )
#    except Exception as e:
#        logger.error(f"포지션 청산 메시지 생성 오류: {str(e)}")
#        traceback.print_exc()
#        return "포지션 청산 정보를 가져오는 중 오류가 발생했습니다."



# ======== (A) 포지션이 없는 경우 ========
async def handle_no_position(
    user_id, 
    settings, 
    trading_service: TradingService, 
    calculator: TrendStateCalculator, 
    symbol: str, 
    timeframe: str, 
    current_rsi: float, 
    rsi_signals: dict, 
    current_state: int
):
    """
    포지션이 없을 때 롱/숏 진입 시도 -> 주문 발행
    """
    try:
        print(f"[{user_id}] ✅포지션이 없는 경우")
        position_manager = PositionStateManager(redis_client, trading_service)
        current_price = await get_current_price(symbol)
        
        # 계약 정보 조회
        contract_info = await trading_service.get_contract_info(
            user_id=user_id,
            symbol=symbol,
            size_usdt=settings['investment'],
            leverage=settings['leverage'],
            current_price=current_price
        )
        # 실제 계약 수량 계산
        contracts_amount = contract_info['contracts_amount']  # 이미 최소 주문 수량 등이 고려된 값
        min_sustain_contract_size = 0.0
        if (float(settings['tp1_ratio']) + float(settings['tp2_ratio']) + float(settings['tp3_ratio']) == 1) or (float(settings['tp1_ratio']) + float(settings['tp2_ratio']) + float(settings['tp3_ratio']) == 100):
            min_sustain_contract_size = max(float(contracts_amount)*0.01, 0.05)
        else:
            min_sustain_contract_size = max(float(contracts_amount)*0.0001, 0.05)
        min_size_key = f"user:{user_id}:position:{symbol}:min_sustain_contract_size"
        await redis_client.set(min_size_key, min_sustain_contract_size)
        print(f"[{user_id}] OKX 기준 주문 수량(콘트랙트 갯수): {contracts_amount}. 즉, 이게 주문이 들어가는 계약 수량.")
        timeframe_str = tf_mapping.get(timeframe, "1m")
        print(f"[{user_id}] 포지션 없는 경우의 디버깅 : {current_rsi}, rsi signals : {rsi_signals},current state : {current_state}")
        entry_fail_count_key = f"user:{user_id}:entry_fail_count"
        fail_count = int(await redis_client.get(entry_fail_count_key) or 0)
        main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
        if await redis_client.exists(main_position_direction_key):
            await redis_client.delete(main_position_direction_key)
        if fail_count >= 5:
            await send_telegram_message(
                "3회 연속 진입 실패로 트레이딩이 종료되었습니다.",
                user_id,
                debug=True
            )
            await redis_client.set(f"user:{user_id}:trading:status", "stopped")
            await redis_client.delete(entry_fail_count_key)
            return

        key = f"candles_with_indicators:{symbol}:{timeframe_str}"
        try:
            candle = await redis_client.lindex(key, -1)
            if candle:
                candle = json.loads(candle)
                atr_value = candle.get('atr14')
            else:
                logger.error(f"캔들 데이터를 찾을 수 없습니다: {key}")
        except Exception as e:
            logger.error(f"Redis에서 ATR 데이터 가져오기 실패: {str(e)}")

        entry_success = False
        
        # 롱 진입
        if settings['direction'] in ['롱숏', '롱']:
            should_check_trend = settings.get('use_trend_logic', True)
            trend_condition = (current_state != -2) if should_check_trend else True
            if rsi_signals['is_oversold'] and trend_condition:
                try:
                    request = OpenPositionRequest(
                        user_id=user_id,
                        symbol=symbol,
                        direction="long",
                        size=contracts_amount,  # 달러 금액 대신 실제 계약 수량 전달
                        leverage=settings['leverage'],
                        settings=settings,
                        order_concept="new_position"
                    )
                    
                    position = await open_position_endpoint(request)
                    print(f"﹗사이즈 점검! : position.size: {position.size},contracts_amount: {contracts_amount}")
                    dca_count_key = f"user:{user_id}:position:{symbol}:long:dca_count"
                    await redis_client.set(dca_count_key, "1")
                    short_dca_key = f"user:{user_id}:position:{symbol}:short:dca_levels"
                    await redis_client.delete(short_dca_key)
                    long_dca_key = f"user:{user_id}:position:{symbol}:long:dca_levels"
                    await redis_client.delete(long_dca_key)
                    
                    try:
                        await position_manager.update_position_state(
                            user_id=user_id,
                            symbol=symbol,
                            entry_price=position.entry_price,
                            contracts_amount_delta=contracts_amount,  # 계약 수량 사용
                            side="long",
                            operation_type="new_position"
                        )
                    except Exception as e:
                        logger.error(f"포지션 정보 업데이트 실패: {str(e)}")
                    
                    message = await create_position_message(
                        user_id=user_id,
                        symbol=symbol,
                        position_type="long",
                        position=position,
                        settings=settings,
                        tp_levels=position.tp_prices if position.tp_prices else None,
                        stop_loss=position.sl_price,
                        contracts_amount=contracts_amount,
                        trading_service=trading_service,
                        atr_value=atr_value
                    )
                    await send_telegram_message(message, user_id)
                    await redis_client.set(f"user:{user_id}:position:{symbol}:long:dca_count", 1)
                    await record_trade_entry(
                        user_id=user_id,
                        symbol=symbol,
                        entry_price=position.entry_price,
                        size=contracts_amount,  # 계약 수량 사용
                        side="long",
                        is_DCA=False
                    )
                    
                    tp_data_key = f"user:{user_id}:position:{symbol}:long:tp_data"
                    await redis_client.set(tp_data_key, json.dumps(position.tp_prices))
                    entry_success = True
                    await redis_client.delete(entry_fail_count_key)

                except Exception as e:
                    if "직전 주문 종료 후 쿨다운 시간이 지나지 않았습니다." in str(e):
                        pass
                    else:
                        error_logger.error("롱 포지션 진입 실패", exc_info=True)

                        traceback.print_exc()
                        error_msg = map_exchange_error(e)
                        if not entry_success:
                            fail_count += 1
                        await redis_client.set(entry_fail_count_key, fail_count)
                        
                        await send_telegram_message(
                            f"[{user_id}]⚠️ 롱 포지션 주문 실패\n"
                            f"━━━━━━━━━━━━━━━\n"
                            f"{error_msg}\n"
                            f"재시도 횟수: {fail_count}/3",
                            1709556958
                        )
            elif rsi_signals['is_oversold'] and not trend_condition:
                alert_key = f"user:{user_id}:trend_signal_alert"
                is_alerted = await redis_client.get(alert_key)
                if not is_alerted:
                    await send_telegram_message(
                        f"[{user_id}]⚠️ 롱 포지션 진입 조건 불충족\n"
                        f"━━━━━━━━━━━━━━━\n"
                    f"RSI가 과매수 상태이지만 트랜드 조건이 맞지 않아 진입을 유보합니다.",
                    user_id
                    )
                    await redis_client.set(alert_key, "true", ex=7200)

        # 숏 진입 로직도 동일하게 수정...
        if settings['direction'] in ['롱숏', '숏']:
            should_check_trend = settings.get('use_trend_logic', True)
            trend_condition = (current_state != 2) if should_check_trend else True
            if rsi_signals['is_overbought'] and trend_condition:
                try:
                    print("2번")
                    request = OpenPositionRequest(
                        user_id=user_id,
                        symbol=symbol,
                        direction="short",
                        size=contracts_amount,  # 달러 금액 대신 실제 계약 수량 전달
                        leverage=settings['leverage'],
                        settings=settings,
                        order_concept="new_position"
                    )
                    position = await open_position_endpoint(request)
                    
                    dca_long_key = f"user:{user_id}:position:{symbol}:long:dca_levels"
                    await redis_client.delete(dca_long_key)
                    dca_count_key = f"user:{user_id}:position:{symbol}:short:dca_count"
                    await redis_client.set(dca_count_key, 1)
                    message = await create_position_message(
                        user_id=user_id,
                        symbol=symbol,
                        position_type="short",
                        position=position,
                        settings=settings,
                        tp_levels=position.tp_prices if position.tp_prices else None,
                        stop_loss=position.sl_price,
                        contracts_amount=contracts_amount,
                        trading_service=trading_service,
                        atr_value=atr_value
                    )
                            

                    await send_telegram_message(message, user_id)
                    await position_manager.update_position_state(user_id, symbol, current_price, contracts_amount, "short", operation_type="new_position")
                    await redis_client.set(f"user:{user_id}:{symbol}:short:dca_count", 1)

                    tp_data_key = f"user:{user_id}:position:{symbol}:short:tp_data"
                    await redis_client.set(tp_data_key, json.dumps(position.tp_prices))
                    await record_trade_entry(
                        user_id=user_id,
                        symbol=symbol,
                        entry_price=position.entry_price,
                        size=contracts_amount,  # 계약 수량 사용
                        side="short"
                    )
                    entry_success = True
                    await redis_client.delete(entry_fail_count_key)  # 성공시 카운트 리셋

                except Exception as e:
                    if "직전 주문 종료 후 쿨다운 시간이 지나지 않았습니다." in str(e):
                        pass
                    else:
                        error_msg = map_exchange_error(e)
                        error_logger.error("숏 포지션 진입 실패", exc_info=True)

                        # 진입 실패 시 카운트 증가
                        if not entry_success:
                            fail_count += 1
                            await redis_client.set(entry_fail_count_key, fail_count)
                            
                        await send_telegram_message(
                            f"[{user_id}]⚠️ 숏 포지션 주문 실패\n"
                            f"━━━━━━━━━━━━━━━\n"
                            f"{error_msg}\n"
                            f"재시도 횟수: {fail_count}/5",
                            user_id, 
                            debug=True
                            )
            elif rsi_signals['is_overbought'] and not trend_condition:
                alert_key = f"user:{user_id}:trend_signal_alert"
                is_alerted = await redis_client.get(alert_key)
                if not is_alerted:
                    await send_telegram_message(
                        f"[{user_id}]⚠️ 숏 포지션 진입 조건 불충족\n"
                        f"━━━━━━━━━━━━━━━\n"
                        f"RSI가 과매수 상태이지만 트랜드 조건이 맞지 않아 진입을 유보합니다.",
                        user_id
                    )
                    await redis_client.set(alert_key, "true", ex=7200)

            if fail_count >= 3:
                await redis_client.set(f"user:{user_id}:trading:status", "stopped")
                await send_telegram_message(
                    "트레이딩 자동 종료\n"
                    "─────────────────────\n"
                    "3회 연속 진입 실패로 트레이딩이 종료되었습니다.",
                    user_id, 
                    debug=True
                )
                await redis_client.delete(entry_fail_count_key)

    except Exception as e:
        error_msg = map_exchange_error(e)
        error_logger.error(f"[{user_id}]:포지션 진입 오류", exc_info=True)
        await send_telegram_message(f"⚠️ 포지션 진입 오류:\n{error_msg}", user_id)


# ======== (B) 포지션이 있는 경우 ========
async def handle_existing_position(
    user_id: int,
    settings: dict,
    trading_service: TradingService,
    calculator: TrendStateCalculator,
    symbol: str,
    timeframe: str,
    current_position: Position,
    current_rsi: float,
    rsi_signals: dict,
    current_state: int,
    side: str,
    
):
    """
    이미 포지션이 있을 때:
    - DCA/피라미딩 추가 진입
    - TP/SL 모니터링
    - 브레이크이븐
    - 청산 조건
    """

    korean_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    position_manager = PositionStateManager(redis_client, trading_service)
    current_price = await get_current_price(symbol, timeframe)
    if side == "any":
        print("[⚠️] 포지션 방향이 없습니다. 포지션 방향을 찾아서 설정합니다.")
        main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
        side = await redis_client.get(main_position_direction_key)
        if side is None or side == "any":
            side = current_position.side
            await redis_client.set(main_position_direction_key, side)
    size = current_position.size
    entry_price = current_position.entry_price
    print(f"시간:{korean_time} ✅포지션이 있는 경우. 평단 : {entry_price}, 포지션 수량 : {size}, 포지션 방향 : {side}")
    key = f"candles_with_indicators:{symbol}:{timeframe}"
    candle = await redis_client.lindex(key, -1)
    if candle:
        candle = json.loads(candle)
        atr_value = max(candle.get('atr14'), current_price*0.1*0.01)
    else:
        atr_value = current_price*0.01*0.1
        logger.error(f"캔들 데이터를 찾을 수 없습니다: {key}")
    #if current_position:
        #print(f"current_position: {current_position}")
        #print(f"side: {side}")  # 디버깅을 위한 로깅 추가
    #print(f"2entry_price: {current_position.entry_price}, total_size: {current_position.size}, stored_side: {side}")
    trading_status = await redis_client.get(f"user:{user_id}:trading:status")
    main_position_direction = await redis_client.get(f"user:{user_id}:position:{symbol}:main_position_direction")
    await monitor_tp_sl(user_id, symbol, main_position_direction, current_price, redis_client, trading_service, settings)
    if trading_status != "running":
        print("💚trading_status4: ", trading_status)

    if not entry_price or not size:
        # 거래소 최신 정보로 재동기화
        exch_pos = await trading_service.get_current_position(user_id, symbol, side)
        if exch_pos is None:
            # mismatch => Redis 정리
            await position_manager.cleanup_position_data(user_id, symbol, side)
            await send_telegram_message(f"[{user_id}]❌ 포지션 정보 불일치: Redis 초기화", user_id, debug=True)
            return
        else:
            entry_price = exch_pos.entry_price
            size = exch_pos.size
            await position_manager.update_position_state(user_id, symbol, entry_price, size, side, operation_type="add_position")
            print("포지션 정보 동기화 완료")
            
    pyramiding_limit = settings.get('pyramiding_limit', 1)
    use_check_DCA_with_price = settings.get('use_check_DCA_with_price', True)
    #print(f"pyramiding limit", pyramiding_limit)
     # ─── (1) DCA/피라미딩 추가 진입  ─────────────────────────
    cooldown_key = f"user:{user_id}:cooldown:{symbol}"
    is_cooldown = await redis_client.get(cooldown_key)
    left_time = await redis_client.ttl(cooldown_key)
    if is_cooldown:
        print(f"[{user_id}] 쿨다운 중입니다. {symbol} 종목에 대해서는 진입을 하지 않습니다. 남은 시간: {left_time}초")
        return
    if pyramiding_limit > 1:
        position_key = f"user:{user_id}:position:{symbol}:{side}"
        position_info = await redis_client.hgetall(position_key)
        # DCA 레벨 가져오기 또는 새로 계산
        dca_key = f"user:{user_id}:position:{symbol}:{side}:dca_levels"
        dca_levels = await redis_client.lrange(dca_key, 0, -1)
        
        if True : #not dca_levels:  # DCA 레벨이 없으면 새로 계산 <-- 항상 계산이 되어야 맞다. 
            initial_entry_price = float(position_info.get('entry_price', current_price))
            dca_levels = await calculate_dca_levels(initial_entry_price, settings, side, atr_value, current_price)
            await update_dca_levels_redis(user_id, symbol, dca_levels, side)

        dca_levels = await redis_client.lrange(dca_key, 0, -1)
        current_price = float(current_price)
        # 첫 번째 DCA 레벨이 있는 경우에만 진행
        if dca_levels and len(dca_levels) > 0:
            first_dca_level = float(dca_levels[0])  # 첫 번째 DCA 레벨
            # DCA 조건 체크 (롱/숏에 따라 다른 조건 적용)
            if use_check_DCA_with_price:
                dca_condition = (current_price <= first_dca_level if side == "long" 
                                else current_price >= first_dca_level)
            else:
                dca_condition = True
            print(f"Current Price: {current_price}, First DCA Level: {first_dca_level}, Side: {side}, DCA Condition: {dca_condition}")

        
        if await check_dca_condition(current_price, dca_levels, side, use_check_DCA_with_price):
            dca_order_count_key = f"user:{user_id}:position:{symbol}:{side}:dca_count"
            dca_order_count = await redis_client.get(dca_order_count_key)
            print(f"dca_order_count: {dca_order_count}")
            if dca_order_count is None:
                dca_order_count = 1
                await redis_client.set(dca_order_count_key, 1)
            else:
                dca_order_count = int(dca_order_count)

            position_key = f"user:{user_id}:position:{symbol}:{side}"
            position_info = await redis_client.hgetall(position_key)
            position_size = float(position_info.get('size', 0))
            scale = settings.get('entry_multiplier', 0.5)
            
            new_position_entry_contract_size = position_size * float(scale)
            print(f"new_position_entry_contract_size : {new_position_entry_contract_size}, former position_size : {position_size}, scale : {scale}")
            if side == "long":
                should_check_trend = settings.get('use_trend_logic', True)
                trend_condition = True
                if should_check_trend and current_state == -2:
                    trend_condition = False
                    
                rsi_long_signals_condition = False
                if settings.get('use_rsi_with_pyramiding', True):
                    rsi_long_signals_condition = rsi_signals['is_oversold']
                else:
                    rsi_long_signals_condition = True
                print(f"rsi_signals['is_oversold'] : {rsi_signals['is_oversold']}, trend_condition : {trend_condition}, dca_order_count : {dca_order_count}, pyramiding_limit : {settings.get('pyramiding_limit', 1)}")
                if (rsi_long_signals_condition and trend_condition) and dca_order_count < settings.get('pyramiding_limit', 1):
                
                    try:
                        print("3번")
                        new_position_entry_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_entry_contract_size)
                        request = OpenPositionRequest(
                            user_id=user_id,
                            symbol=symbol,
                            direction="long",
                            size=new_position_entry_contract_size,
                            leverage=settings['leverage'],
                            settings=settings,
                            is_DCA=True,
                        )
                        try:
                            position = await open_position_endpoint(request)
                            dca_count_key = f"user:{user_id}:position:{symbol}:long:dca_count"
                            dca_order_count = await redis_client.get(dca_count_key)
                            dca_order_count = int(dca_order_count) + 1
                            await redis_client.set(dca_count_key, dca_order_count)
                        except Exception as e:
                            error_logger.error(f"[{user_id}]:DCA 롱 주문 실패", exc_info=True)
                            await send_telegram_message(
                                f"⚠️ DCA 추가진입 실패 (롱)\n"
                                f"━━━━━━━━━━━━━━━\n"
                                f"{e}\n", 
                                user_id=user_id,
                                debug=True)
                            return
                        
                        dca_key = f"user:{user_id}:position:{symbol}:long:dca_levels"
                        new_entry_price = position.entry_price
                        try:
                            new_position_contract_size = position.size
                            new_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_contract_size)
                        except Exception as e:
                            send_telegram_message(f"롱 추가진입 실패 오류: {e}", user_id, debug=True)
                            print("롱 추가진입 실패 오류: ", e)
                            return
                        new_avg, new_size = await position_manager.update_position_state(user_id, symbol, current_price, contracts_amount_delta=new_position_contract_size, position_qty_delta=new_position_qty, side = "long", operation_type="add_position", new_entry_exact_price=new_entry_price, new_exact_contract_size=new_position_contract_size)
                        new_total_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_contract_size)
                        print("총 포지션 수량 제대로 나오는지 꼭 확인!~!!!!!1", new_total_position_qty)
                        
                        new_position_qty_size_from_redis = await redis_client.hget(f"user:{user_id}:position:{symbol}:long", "position_qty")
                        position_avg_price = await trading_service.get_position_avg_price(user_id, symbol, side)
                        telegram_message = "🔼 추가진입 (롱)"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += "━━━━━━━━━━━━━━━\n"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += f"📊 롱 {dca_order_count}회차 진입\n"
                        telegram_message += f"📈 수량: +{new_position_entry_qty}\n"
                        telegram_message += f"💰 새 평균가: {position_avg_price:,.2f}\n"
                        telegram_message += f"📝 총 포지션: {float(new_position_qty_size_from_redis):.3f}\n"
                        telegram_message += "━━━━━━━━━━━━━━━"
                        await send_telegram_message(telegram_message, user_id)
                        await record_trade_entry(
                            user_id=user_id,
                            symbol=symbol,
                            entry_price=current_price,
                            size=new_position_contract_size,
                            side="long",
                            is_DCA=True,  # DCA 여부 표시
                            dca_count=dca_order_count
                        )
                        
                
                        
                        if settings.get('use_dual_side_entry', False):
                            print("4번")
                            try:
                                await manage_dual_side_entry(
                                    user_id=user_id,
                                    symbol=symbol,
                                    current_price=current_price,
                                    dca_order_count=dca_order_count,
                                    main_position_side=side,
                                    settings=settings,
                                    trading_service=trading_service,
                                    redis_client=redis_client,
                                    exchange=trading_service.client
                                    )
                            except Exception as e:
                                error_logger.error(f"[{user_id}]:DCA 롱 주문 실패", exc_info=True)
                                await send_telegram_message(
                                    f"⚠️ 추가진입 실패 (롱)\n"
                                    f"━━━━━━━━━━━━━━━\n"
                                    f"{e}\n", 
                                    user_id=user_id,
                                    debug=True)
                            await record_trade_entry(
                                user_id=user_id,
                                symbol=symbol,
                                entry_price=current_price,
                                size=new_position_contract_size,
                                side=side,
                                is_DCA=True,  # DCA 여부 표시
                                dca_count=dca_order_count
                            )
                    except Exception as e:
                        error_msg = map_exchange_error(e)
                        error_logger.error(f"[{user_id}]:롱 주문 실패", exc_info=True)
                        await send_telegram_message(
                            f"⚠️ 추가진입 실패 (롱)\n"
                            f"━━━━━━━━━━━━━━━\n"
                            f"현재가격: {current_price}\n"
                            f"시도한 추가물량: {new_position_qty}",
                            user_id
                        )
                        await send_telegram_message(
                            f"⚠️[{user_id}] 추가진입 실패 (롱)\n"
                            f"━━━━━━━━━━━━━━━\n"
                            f"{error_msg}\n"
                            f"현재가격: {current_price}\n"
                            f"시도한 추가물량: {new_position_qty}\n"
                            f"시도한 추가 계약: {new_position_contract_size}",
                            user_id, debug=True
                        )
            elif side == "short":
                should_check_trend = settings.get('use_trend_logic', True)
                trend_condition = True
                if should_check_trend and current_state == 2:
                    trend_condition = False
                rsi_short_signals_condition = False
                if settings.get('use_rsi_with_pyramiding', True):
                    rsi_short_signals_condition = rsi_signals['is_overbought']
                else:
                    rsi_short_signals_condition = True
                print(f"rsi short signals condition : {rsi_short_signals_condition}, trend_condition : {trend_condition}, dca_order_count : {dca_order_count}, pyramiding_limit : {settings.get('pyramiding_limit', 1)}")
                if (rsi_short_signals_condition and trend_condition) and dca_order_count < settings.get('pyramiding_limit', 1):
                    print("피라미딩 숏 진입 호출")
                    try:
                        
                        request = OpenPositionRequest(
                            user_id=user_id,
                            symbol=symbol,
                            direction="short",
                            size=new_position_entry_contract_size,
                            leverage=settings['leverage'],
                            settings=settings,
                            is_DCA=True,
                        )
                        try:
                            position = await open_position_endpoint(request)
                            dca_count_key = f"user:{user_id}:position:{symbol}:short:dca_count"
                            dca_order_count = await redis_client.get(dca_count_key)
                            dca_order_count = int(dca_order_count) + 1
                            await redis_client.set(dca_count_key, dca_order_count)
                        except Exception as e:
                            error_logger.error(f"[{user_id}]:DCA 숏 주문 실패1", exc_info=True)
                            await send_telegram_message(
                                f"⚠️ 추가진입 실패 (숏)\n"
                                f"━━━━━━━━━━━━━━━\n"
                                f"{e}\n", 
                                user_id=user_id,
                                debug=True)
                            return
                        
                        if settings.get('use_dual_side_entry', False):
                            print("4번")
                            try:
                                await manage_dual_side_entry(
                                    user_id=user_id,
                                    symbol=symbol,
                                    current_price=current_price,
                                    dca_order_count=dca_order_count,
                                    main_position_side=side,
                                    settings=settings,
                                    trading_service=trading_service,
                                    redis_client=redis_client,
                                    exchange=trading_service.client
                                    )
                            except Exception as e:
                                error_logger.error(f"[{user_id}]:DCA 숏 주문 실패2", exc_info=True)
                                await send_telegram_message(
                                    f"⚠️ 추가진입 실패 (숏)\n"
                                    f"━━━━━━━━━━━━━━━\n"
                                    f"{e}\n", 
                                    user_id=user_id,
                                    debug=True)
                        dca_key = f"user:{user_id}:position:{symbol}:short:dca_levels"
                        await redis_client.lpop(dca_key)
                        new_entry_price = position.entry_price
                        try:
                            new_total_contract_size = position.size
                            new_position_contract_size = position.size
                            new_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_entry_contract_size)
                        except Exception as e:
                            send_telegram_message(f"숏 추가진입 실패 오류: {e}", user_id, debug=True)
                            print("숏 추가진입 실패 오류: ", e)
                            return
                        
                        
                        new_total_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_total_contract_size)
                        new_avg, new_size = await position_manager.update_position_state(user_id, symbol, current_price, contracts_amount_delta=new_position_entry_contract_size, position_qty_delta=new_position_qty, side = "short", operation_type="add_position", new_entry_exact_price=new_entry_price, new_exact_contract_size=new_total_contract_size)
                        await record_trade_entry(
                                user_id=user_id,
                                symbol=symbol,
                                entry_price=current_price,
                                size=new_position_contract_size,
                                side=side,
                                is_DCA=True,  # DCA 여부 표시
                                dca_count=dca_order_count 
                            )             
                        total_position_qty = await redis_client.hget(f"user:{user_id}:position:{symbol}:{side}", "position_qty")
                        position_avg_price = await trading_service.get_position_avg_price(user_id, symbol, side)
                        telegram_message = "🔽 추가진입 (숏)"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += "━━━━━━━━━━━━━━━\n"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += f"숏 📊 {dca_order_count}회차 진입\n"
                        telegram_message += f"📈 수량: +{new_position_qty}\n"
                        telegram_message += f"💰 새 평균가: {position_avg_price:,.2f}\n"
                        telegram_message += f"📝 총 포지션: {float(total_position_qty):.3f}\n"
                        telegram_message += "━━━━━━━━━━━━━━━"
                        await send_telegram_message(telegram_message, user_id)
                    except Exception as e:
                        error_msg = map_exchange_error(e)
                        error_logger.error(f"[{user_id}]:DCA 숏 주문 실패3", exc_info=True)
                        await send_telegram_message(
                            f"숏 주문 실패(숏)\n"
                            f"━━━━━━━━━━━━━━━\n"
                            f"현재가격: {current_price}\n"
                            f"시도한 추가물량: {new_position_qty}",
                            user_id
                        )
                        await send_telegram_message(
                            f"⚠️ 추가진입 실패 (숏)\n"
                            f"━━━━━━━━━━━━━━━\n"
                            f"{error_msg}\n"
                            f"현재가격: {current_price}\n"
                            f"시도한 추가물량: {new_position_qty}\n"
                            f"시도한 추가 계약: {new_position_contract_size}",
                            user_id, debug=True
                        )
            else:
                print("side가 없습니다. side : ", side)
    position_key = f"user:{user_id}:position:{symbol}:{side}"
    position_info = await redis_client.hgetall(position_key)
    tp_data = json.loads(position_info.get('tp_data', '[]'))
 
    # (4) 청산 조건(트랜드 반전 등)
    should_close_with_trend = settings.get('use_trend_close', True)
    if should_close_with_trend:
        try:
            if (side == "long" and current_state == -2) or (side == "short" and current_state == 2):
                try:
                    print("청산 반전")
                    print("7번")
                    await trading_service.close_position(
                        user_id=user_id,
                        symbol=symbol,
                        percent = 100,
                        comment="트랜드 반전 포지션 종료",
                        side=side
                    )
                    pnl = size * (current_price - entry_price) if side == "long" else size * (entry_price - current_price)
                    
                    position_qty = await contracts_to_qty(symbol, size)

                    await update_trading_stats(
                    user_id=user_id,
                    symbol=symbol,
                    entry_price=entry_price,
                    exit_price=current_price,
                    position_size=position_qty,
                    pnl=pnl,
                    side=side,
                    entry_time=position_info.get("entry_time", str(datetime.now())),
                    exit_time=str(datetime.now()),
                    redis_client=redis_client
                    )
                                # Redis 포지션/평균가 등 초기화
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:entry_price")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:long:dca_count")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:short:dca_count")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:long:dca_levels")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:short:dca_levels")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:{side}")
                except Exception as e:
                    traceback.print_exc()
                    error_logger.error(f"[{user_id}]:트랜드 반전 청산 실패", exc_info=True)
                    await send_telegram_message(f"⚠️ 트랜드 반전 청산 실패: {str(e)}", user_id, debug=True) 
                

        except Exception as e:
            error_logger.error(f"[{user_id}]:포지션 청산 실패", exc_info=True)
            await send_telegram_message(f"⚠️ 포지션 청산 실패: {str(e)}", user_id, debug=True)
    return


# ======== (C) 메인 트레이딩 로직 ========ㅋㅈ
@EventLoopManager.with_event_loop
async def execute_trading_logic(user_id: str, symbol: str, timeframe: str, restart = False):
    """
    - 주기적으로:
      1) monitor_orders()를 통해 주문 체결 여부를 업데이트
      2) RSI/트랜드 체크 -> 포지션 분기처리
    """
    # 실행 전 올바른 이벤트 루프를 확보 <-- 이게 필요한가? 이미 상위에서 처리하는데?
    #loop = ensure_async_loop()
    trading_service = None
    
    try:
        # 트레이딩 서비스 초기화
        trading_service = await TradingService.create_for_user(user_id)
        okx_instance = trading_service.client
        calculator = TrendStateCalculator()
        redis_service = RedisService()

        # Redis 연결 확인
        await redis_client.ping()
        await redis_client.set(f"user:{user_id}:trading:status", "running")

    except Exception as e:
        error_msg = f"트레이딩 초기화 실패: {str(e)}"
        error_logger.error(error_msg)
        try:
            await send_telegram_message(f"⚠️ {error_msg}", user_id)
        except Exception as telegram_error:
            logger.error(f"텔레그램 메시지 전송 실패: {str(telegram_error)}")
        
        if trading_service:
            try:
                await trading_service.close()
            except Exception as close_error:
                logger.error(f"트레이딩 서비스 종료 실패: {str(close_error)}")
        return

    try:
        # 사용자 설정 가져오기
        user_settings = await redis_service.get_user_settings(user_id)
        if not user_settings:
            await send_telegram_message(
                "⚠️ 트레이딩 설정 오류\n"
                "─────────────────────\n"
                "사용자 설정을 찾을 수 없습니다.\n"
                "/settings 명령어로 설정을 확인해주세요.",
                user_id
            )
            return
        entry_fail_count_key = f"user:{user_id}:entry_fail_count"
        await redis_client.delete(entry_fail_count_key)
        active_key = f"user:{user_id}:preferences"
        
        # 매개변수로 전달된 symbol이 없는 경우에만 Redis에서 가져옴
        if symbol is None:
            symbol = await redis_client.hget(active_key, "symbol")
            if not symbol:
                symbol = 'BTC-USDT-SWAP'
                
        if timeframe is None:   
            timeframe = await redis_client.hget(active_key, "timeframe")
            if not timeframe:
                timeframe = '1m'
        if not symbol or not timeframe:
            await send_telegram_message(
                "⚠️ 트레이딩 설정 오류\n"
                "─────────────────────\n"
                "심볼 또는 타임프레임이 설정되지 않았습니다.\n"
                "설정을 확인하고 다시 시작해주세요.",
                user_id
            )
            return
        
        print(f"Active Symbol: {symbol}, Active Timeframe: {timeframe}")
        
        # 최소 주문 금액 검증
        investment = None
        min_notional = 200  # 최소 명목 가치 (USDT)
        if symbol == "BTC-USDT-SWAP":
            investment = float(user_settings.get('btc_investment', 20))
        elif symbol == "ETH-USDT-SWAP":
            investment = float(user_settings.get('eth_investment', 10))
        elif symbol == "SOL-USDT-SWAP":
            investment = float(user_settings.get('sol_investment', 10))
        else:
            investment = float(user_settings.get('investment', 0))  # 기본값
        leverage = float(user_settings.get('leverage', 10))
        actual_notional = investment * leverage
        print(f"[{user_id}] : symbol: {symbol}, investment: {investment}, leverage: {leverage}, actual_notional: {actual_notional}")
        
        if actual_notional < min_notional:
            await send_telegram_message(
                f"⚠️ 최소 주문 금액 오류\n"
                f"─────────────────────\n"
                f"현재 설정된 금액이 최소 주문 금액보다 작습니다.\n"
                f"• 현재: {actual_notional:.2f} USDT\n"
                f"• 필요: {min_notional:.2f} USDT\n"
                f"• 최소 투자금: {min_notional:.2f} USDT\n"
                f"• 현재 레버리지: {leverage}x\n\n"
                f"설정을 수정하고 다시 시작해주세요.",
                user_id
            )
            return
        print(f"[{user_id}] RESTART 여부 : {restart}")
        if restart:
            pass    
        else:
            # 트레이딩 시작 메시지
            trading_start_msg = f"🚀 자동 트레이딩을 시작합니다\n"
            trading_start_msg += f"─────────────────────\n"
            trading_start_msg += f"📊 트레이딩 설정 정보\n"
            trading_start_msg += f"─────────────────────\n"
            trading_start_msg += f"심볼: {symbol}\n"
            trading_start_msg += f"타임프레임: {timeframe}\n"
            trading_start_msg += f"투자금: {investment} USDT\n"
            trading_start_msg += f"레버리지: {leverage}x\n"
            trading_start_msg += f"명목 가치: {actual_notional:.2f} USDT"
            await send_telegram_message(trading_start_msg, user_id)
            await init_user_position_data(user_id, symbol, "long")
            await init_user_position_data(user_id, symbol, "short")
            # 기존 main_position_direction 키가 있으면 삭제
            main_position_key = f"user:{user_id}:position:{symbol}:main_position_direction"
            hedging_position_key = f"user:{user_id}:position:{symbol}:hedging_position_direction"
            if await redis_client.exists(main_position_key):
                await redis_client.delete(main_position_key)
            if await redis_client.exists(hedging_position_key):
                await redis_client.delete(hedging_position_key)



        position_info = await trading_service.fetch_okx_position(user_id, symbol)
        leverage = float(user_settings.get('leverage', 1.0))

        # position_info가 이제 {'long': {...}, 'short': {...}} 형태이므로
        # 현재 레버리지는 존재하는 포지션에서 가져옴
        current_leverage = None
        if position_info:
            # long 포지션이 있으면 우선 사용
            if 'long' in position_info:
                current_leverage = float(position_info['long'].get('leverage', leverage))
            # 없으면 short 포지션에서 가져옴
            elif 'short' in position_info:
                current_leverage = float(position_info['short'].get('leverage', leverage))
            else:
                current_leverage = leverage

        print(f"레버리지: {leverage}, 현재 레버리지: {current_leverage}")
        is_hedge_mode, tdMode = await trading_service.get_position_mode(user_id, symbol)
        is_running = await redis_client.get(f"user:{user_id}:trading:status")
        if not restart:
            try:
                if leverage > 1.0 and current_leverage != leverage:
                    # 열린 주문이 있는지 확인
                    try:
                        cancel_response = await trading_service.cancel_all_open_orders(exchange= okx_instance, symbol = symbol, user_id  = user_id)
                        if cancel_response:
                            print("레버리지 변경 전 주문 취소 성공")
                    except Exception as e:
                        traceback.print_exc()
                        logger.error(f"레버리지 변경 전 주문 취소 실패: {str(e)}")
                        await send_telegram_message(f"⚠️ 레버리지 변경 전 주문 취소 실패: {str(e)}", user_id)
                
                # 레버리지 설정 시도
                try:
                    if is_hedge_mode:
                        for pos_side in ['long', 'short']:
                            await okx_instance.set_leverage(leverage, symbol, {
                            'marginMode': 'cross',
                            'posSide': pos_side
                        })
                            print("레버리지 설정 성공")
                            await asyncio.sleep(0.5)
                    else:
                        await okx_instance.set_leverage(leverage, symbol, {
                            'marginMode': 'cross'
                        })
                        print("레버리지 설정 성공")
                        await asyncio.sleep(0.5)  # API 레이트 리밋 고려
                except Exception as e:
                    if "59000" in str(e):  # 열린 주문이나 포지션이 있는 경우
                        logger.warning("포지션이 있어 레버리지 변경이 불가능합니다.")
                        #traceback.print_exc()
                        await send_telegram_message(
                            f"⚠️ 포지션 혹은 열린 주문이 있어 레버리지 변경이 불가능합니다.\n"
                            "레버리지 변경을 직접 진행해주세요.",
                            user_id
                        )
                    else:
                        raise e
            except Exception as e:
                logger.error(f"레버리지 설정 오류: {str(e)}")
                await send_telegram_message(
                    f"⚠️ 레버리지 설정 실패\n"
                    f"에러: {str(e)}\n"
                    f"필요한 경우 직접 변경해주세요.",
                    user_id
                )
        if is_running:
            # 설정 업데이트
            #print("설정 업데이트 호출")
            current_price = await get_current_price(symbol, timeframe)
            settings_str = await redis_client.get(f"user:{user_id}:settings")
            candle_key = f"candles_with_indicators:{symbol}:{timeframe}"
            raw_data = await redis_client.lindex(candle_key, -1)
            if not raw_data:
                await send_telegram_message("⚠️ 캔들 데이터를 찾을 수 없습니다.", user_id)
                return
            candle_data = json.loads(raw_data)
            #print("atr_value: ", atr_value)
            if settings_str:
                try:
                    user_settings = json.loads(settings_str)
                except json.JSONDecodeError:
                    logger.error(f"설정 데이터 파싱 실패: user_id={user_id}")
                    return
            else:
                logger.error(f"설정을 찾을 수 없음: user_id={user_id}")
                return
            #print("설정 업데이트 완료")
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                await send_telegram_message(
                    "🛑 트레이딩 중지\n"
                    "─────────────────────\n"
                    "트레이딩이 중지되었습니다.",
                    user_id
                )
                return
            #=======================================
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                print(f"[{user_id}] 트레이딩 중지 상태: {trading_status}")
            #=======================================
            # --- (1) 주문 상태 모니터링(폴링) ---
            try:
                start_time = datetime.now()
                #print("=====================================")
                #print("주문 상태 모니터링 호출")
                await trading_service.monitor_orders(user_id)
                end_time = datetime.now()
                #print("주문 상태 모니터링 완료 시간 : ", end_time.strftime('%Y-%m-%d %H:%M:%S'))
                #print("주문 상태 모니터링 소요 시간 : ", end_time - start_time)
                #print("=====================================")
            except Exception as e:
                error_logger.error(f"[{user_id}]:monitor_orders 에러", exc_info=True)

            # --- (2) RSI / 트랜드 분석 ---
            trend_analysis_start = datetime.now()
            tf_str = tf_mapping.get(timeframe, "1m")
            redis_key = f"candles_with_indicators:{symbol}:{tf_str}"
            raw_data = await redis_client.lindex(redis_key, -1)
            if not raw_data:
                await send_telegram_message("⚠️ 캔들 데이터를 찾을 수 없습니다.", user_id)
                return
            #=======================================
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                print(f"[{user_id}] 트레이딩 중지 상태: {trading_status}")
            #=======================================
            candle_data = json.loads(raw_data)
            current_rsi = candle_data['rsi']
            #print("current_rsi: ", current_rsi)
            trend_timeframe = user_settings['trend_timeframe']
            if trend_timeframe is None:
                trend_timeframe = str(timeframe)
            trend_timeframe_str = tf_mapping.get(trend_timeframe, "1m")
            rsi_signals = await trading_service.check_rsi_signals(
                current_rsi,
                {
                    'rsi_oversold': user_settings['rsi_oversold'],
                    'rsi_overbought': user_settings['rsi_overbought']
                }
            )
            #print("rsi_signals: ", rsi_signals)
            analysis = await calculator.analyze_market_state_from_redis(symbol, str(timeframe), trend_timeframe_str)
            current_state = analysis['extreme_state']
            trend_analysis_end = datetime.now() 
            #print("=====================================")
            #print("anaylsis까지 완료 시간 : ", datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
            #print("트랜드 분석 소요 시간 : ", trend_analysis_end - trend_analysis_start)
            #print("=====================================")
            # --- (3) 포지션 분기 ---
            current_position = await trading_service.get_current_position(user_id, symbol)
            
            if current_position:  # 포지션이 있는 경우
                try:
                    min_size_key = f"user:{user_id}:position:{symbol}:min_sustain_contract_size"
                    min_sustain_contract_size = await redis_client.get(min_size_key)
            
                    if min_sustain_contract_size:  # min_size가 Redis에 저장되어 있는 경우만 체크
                        min_sustain_contract_size = max(float(min_sustain_contract_size), 0.05)
                        current_contracts_amount = float(current_position.contracts_amount)
                        #print("================================================")
                        #print(f"포지션 계약 수: {current_contracts_amount}, 최소 계약 수: {min_sustain_contract_size}")
                        #print("contracts_amount로 저장된 포지션 계약 수: ", current_position.contracts_amount)
                        #print("================================================")

                        if current_contracts_amount <= min_sustain_contract_size:
                            print(f"포지션 크기({current_contracts_amount})가 최소 크기({min_sustain_contract_size})보다 작아 청산 진행")
                            await trading_service.close_position(
                                user_id=user_id,
                                symbol=symbol,
                                percent=100,
                                comment="최소 수량 미만 포지션 청산",
                                side=current_position.side
                            )
                            current_position = None
                except Exception as e:  
                    traceback.print_exc()
                    logger.error(f"[{user_id}]:포지션 청산 오류", exc_info=True)
                    await send_telegram_message(f"⚠️ 포지션 청산 오류: {str(e)}", user_id, debug=True)
            # 마지막 포지션 출력 시간 체크
            last_print_key = f"user:{user_id}:last_position_print_time"
            last_print_time = await redis_client.get(last_print_key)
            current_time = int(time.time())
            
            if not last_print_time or (current_time - int(last_print_time)) >= 300:  # 300초 = 5분
                print("Current Position : ", current_position)
                await redis_client.set(last_print_key, str(current_time))
            
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                print("💚trading_status2: ", trading_status)
            if not current_position:
                print("포지션이 없다고 출력 됨.")
                await handle_no_position(
                    user_id, user_settings, trading_service, calculator,
                    symbol, timeframe,
                    current_rsi, rsi_signals, current_state
                )
                trading_status = await redis_client.get(f"user:{user_id}:trading:status")
                if trading_status != "running":
                    print("💚trading_status4: ", trading_status)
            else:
                try:
                    #print("포지션이 있다고 출력 됨.")
                    main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
                    direction = await redis_client.get(main_position_direction_key)
                    if direction is None:
                        direction = "any"
                    await handle_existing_position(
                        user_id, user_settings, trading_service, calculator,
                        symbol, timeframe,
                        current_position, current_rsi, rsi_signals, current_state, side = direction
                    )
                    trading_status = await redis_client.get(f"user:{user_id}:trading:status")
                    if trading_status != "running":
                        print("💚trading_status3: ", trading_status)
                except Exception as e:
                    error_logger.error(f"[{user_id}]:포지션 처리 오류", exc_info=True)
                    await send_telegram_message(f"⚠️ 포지션 처리 오류: {str(e)}", user_id)
            logger.info(f"[{user_id}] 트레이딩 로직 루프 완료. 현재 RSI: {current_rsi}, 현재 상태: {current_state}") # 디버깅용

            #=======================================
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            #print("🧡trading_status1: ", trading_status)
            #=======================================
        print(f"[{user_id}] 루프 끝. 시간 : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    except Exception as e:
        error_logger.error(f"[{user_id}]:execute_trading_logic 오류", exc_info=True)
        await send_telegram_message(f"[{user_id}]종료되었습니다. 잠시 후 다시 실행해주세요", user_id)
        await send_telegram_message(f"[{user_id}]종료되었습니다. 잠시 후 다시 실행해주세요: {str(e)}", user_id, debug=True)
        traceback.print_exc()

    finally:
        if await redis_client.get(f"user:{user_id}:trading:status") == "stopped":
            if trading_service:
                try:
                    await trading_service.close()
                except Exception as e:
                    logger.error(f"트레이딩 서비스 종료 오류: {str(e)}")
            await send_telegram_message("트레이딩이 종료되었습니다.", user_id)
            logger.info(f"[{user_id}] 트레이딩이 'stopped' 상태이므로 종료되었습니다.")
        else:
            # 현재 트레이딩 상태가 "running"인 경우에만 로깅
            curr_status = await redis_client.get(f"user:{user_id}:trading:status")
            if curr_status == "running":
                logger.info(f"[{user_id}] 트레이딩 로직 실행 종료. 다음 사이클을 기다립니다.")
            
            # 현재 trading_service 정리
            if trading_service:
                try:
                    await trading_service.close()
                except Exception as e:
                    logger.error(f"트레이딩 서비스 정리 오류: {str(e)}")
                    
        # 상태가 "stopped"로 변경되지 않도록 보장
        # 이 부분을 제거하여 트레이딩이 계속 진행되도록 함


# ======== (D) 실제 실행 예시 ========
async def main():
    test_user_id = 1709556958
    
    await execute_trading_logic(test_user_id,  restart = True)

if __name__ == "__main__":
    asyncio.run(main())