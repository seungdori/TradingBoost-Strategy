# execute_trading_logic.py

import asyncio
import json
from os import error
import traceback
from datetime import datetime
from typing import Dict
from src.helpers.order_helper import contracts_to_qty
from src.trading.trading_service import TradingService
from src.trading.models import Position
from src.api.trading.Calculate_signal import TrendStateCalculator
from src.services.redis_service import RedisService
from src.bot.telegram_message import send_telegram_message
from src.core.database import redis_client
from src.trading.dual_side_entry import manage_dual_side_entry
from src.trading.stats import update_trading_stats, record_trade_entry
from src.trading.services.calc_utils import get_contract_size, round_to_qty
import telegram_message
from src.trading.error_message import map_exchange_error
from src.trading.position_manager import PositionStateManager
from src.core.logger import get_logger, setup_error_logger
from src.trading.tp_sl_monitor import monitor_tp_sl
from src.trading.services.get_current_price import get_current_price
from src.api.routes.position import open_position_endpoint
import time
from src.trading.models import tf_mapping
from src.api.routes.position import OpenPositionRequest
from src.core.event_loop_manager import EventLoopManager
from src.utils.status_utils import get_symbol_status

def ensure_async_loop():
    """
    í˜„ì¬ ìŠ¤ë ˆë“œì— ì‚¬ìš© ê°€ëŠ¥í•œ ì´ë²¤íŠ¸ ë£¨í”„ë¥¼ ë°˜í™˜í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.
    ë‹«íŒ ë£¨í”„ë‚˜ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ë£¨í”„ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    """
    try:
        # í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ë£¨í”„ê°€ ìˆëŠ”ì§€ í™•ì¸
        loop = asyncio.get_running_loop()
        logger.debug("ì‹¤í–‰ ì¤‘ì¸ ì´ë²¤íŠ¸ ë£¨í”„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.")
        return loop
    except RuntimeError:
        # í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ë£¨í”„ê°€ ì—†ëŠ” ê²½ìš°
        pass
    
    try:
        # ê¸°ì¡´ ë£¨í”„ê°€ ìˆëŠ”ì§€ í™•ì¸
        loop = asyncio.get_event_loop()
        
        # ë£¨í”„ê°€ ë‹«í˜€ìˆëŠ”ì§€ í™•ì¸
        if loop.is_closed():
            logger.info("ê¸°ì¡´ ì´ë²¤íŠ¸ ë£¨í”„ê°€ ë‹«í˜€ ìˆì–´ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤")
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        return loop
    except RuntimeError as ex:
        # ë£¨í”„ê°€ ì•„ì˜ˆ ì—†ëŠ” ê²½ìš°
        if "There is no current event loop in thread" in str(ex):
            logger.info("ì´ë²¤íŠ¸ ë£¨í”„ê°€ ì—†ì–´ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤")
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            return loop
        
        # ê·¸ ì™¸ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜
        logger.error(f"ì´ë²¤íŠ¸ ë£¨í”„ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(ex)}")
        raise

logger = get_logger(__name__)
error_logger = setup_error_logger()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# (A) ê°„ë‹¨ ìœ í‹¸ í•¨ìˆ˜
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def init_user_position_data(user_id: int, symbol: str, side: str):
    position_state_key = f"user:{user_id}:position:{symbol}:position_state"
    tp_data_key = f"user:{user_id}:position:{symbol}:{side}:tp_data"
    dca_count_key = f"user:{user_id}:position:{symbol}:{side}:dca_count"
    dca_levels_key = f"user:{user_id}:position:{symbol}:{side}:dca_levels"
    position_key = f"user:{user_id}:position:{symbol}:{side}"
    min_size_key = f"user:{user_id}:position:{symbol}:min_sustain_contract_size"
    #main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
    tp_state = f"user:{user_id}:position:{symbol}:{side}:tp_state"
    hedging_direction_key = f"user:{user_id}:position:{symbol}:hedging_direction"
    entry_fail_count_key = f"user:{user_id}:entry_fail_count"
    await redis_client.delete(position_state_key)
    await redis_client.delete(tp_data_key)
    await redis_client.delete(dca_count_key)
    await redis_client.delete(dca_levels_key)
    await redis_client.delete(position_key)
    await redis_client.delete(min_size_key)
    #await redis_client.delete(main_position_direction_key)
    await redis_client.delete(tp_state)
    await redis_client.delete(entry_fail_count_key)
    await redis_client.delete(hedging_direction_key)

class TPPrice:
    def __init__(self):
        self.prices: Dict[str, float] = {}  # price: ratio

# 2. ë°ì´í„° ì €ì¥/ì¡°íšŒ ì‹œ í˜•ì‹ ê°•ì œ
async def store_tp_prices(user_id: str, symbol: str, side: str, tp_prices: Dict[str, float]):
    tp_data_key = f"user:{user_id}:position:{symbol}:{side}:tp_data"
    await redis_client.set(tp_data_key, json.dumps(tp_prices))

async def get_tp_prices(user_id: str, symbol: str, side: str) -> Dict[str, float]:
    tp_data_key = f"user:{user_id}:position:{symbol}:{side}:tp_data"
    data = await redis_client.get(tp_data_key)
    return json.loads(data) if data else {}

async def is_trading_running(user_id: int) -> bool:
    """trading_status í™•ì¸ í›„ 'running'ì´ë©´ True, ì•„ë‹ˆë©´ False."""
    status = await redis_client.get(f"user:{user_id}:trading:status")
    return (status == "running")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# (C) DCA ê³„ì‚°/ê²€ì‚¬ ê´€ë ¨ ìœ í‹¸
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def calculate_dca_levels(entry_price: float, settings: dict, side: str, atr_value: float, current_price: float) -> list:
    pyramiding_entry_type = settings.get('pyramiding_entry_type', 'í¼ì„¼íŠ¸ ê¸°ì¤€')
    pyramiding_value = settings.get('pyramiding_value', 3.0)
    pyramiding_limit = settings.get('pyramiding_limit', 3)
    entry_criterion = settings.get('entry_criterion', 'í‰ê·  ë‹¨ê°€')


    if entry_criterion == "í‰ê·  ë‹¨ê°€":
        entry_price = entry_price
    else:
        entry_price = current_price
    dca_levels = []
    if pyramiding_entry_type == "í¼ì„¼íŠ¸ ê¸°ì¤€":
        if side == "long":
            level = entry_price * (1 - (pyramiding_value/100))
        else:
            level = entry_price * (1 + (pyramiding_value/100))
    elif pyramiding_entry_type == "ê¸ˆì•¡ ê¸°ì¤€":
        if side == "long":
            level = entry_price - (pyramiding_value)
        else:
            level = entry_price + (pyramiding_value)
    else:  # ATR ê¸°ì¤€ì´ë¼ ê°€ì •
        #print("ATR ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°") #<-- ë¬¸ì œ ì—†ìŒ. 
        # ì‹¤ì œ ATR ê³„ì‚° ë¡œì§ì€ ë³„ë„
        if side == "long":
            level = entry_price - (atr_value * (pyramiding_value))
        else:
            level = entry_price + (atr_value * (pyramiding_value))
    dca_levels.append(level)

    return dca_levels

async def update_dca_levels_redis(user_id: int, symbol: str, dca_levels: list, side: str):
    dca_key = f"user:{user_id}:position:{symbol}:{side}:dca_levels"
    await redis_client.delete(dca_key)
    if dca_levels:
        await redis_client.rpush(dca_key, *[str(level) for level in dca_levels])

async def check_dca_condition(current_price: float, dca_levels: list, side: str, use_check_DCA_with_price: bool) -> bool:
    if use_check_DCA_with_price:
        if not dca_levels:
            return False
        next_dca_level = float(dca_levels[0])
        if side == "long":
            return current_price <= next_dca_level
        else:
            return current_price >= next_dca_level
    else:
        return True



async def create_position_message(
    user_id: int,
    symbol: str,
    position_type: str,  # "long" or "short"
    position,
    settings: dict,
    tp_levels=None,
    stop_loss=None,
    contracts_amount=None, #contract sizeë¡œ ë“¤ì–´ì˜´. 
    trading_service: TradingService = None,
    atr_value=None
):
    try:
        
        #ì—¬ê¸°ë¡œ ë“¤ì–´ì˜¤ëŠ” sizeê°€, contract sizeë¡œ ë“¤ì–´ì˜´. ë”°ë¼ì„œ qtyë¡œ ë³€í™˜ í•„ìš”.
        position_qty = await trading_service.contract_size_to_qty(user_id=user_id, symbol=symbol, contracts_amount=contracts_amount)
        
        # ê¸°ë³¸ ë©”ì‹œì§€ êµ¬ì„±
        print(f"[{user_id}] position ì •ë³´ í™•ì¸ : \n", position)
        emoji = "ğŸ“ˆ" if position_type == "long" else "ğŸ“‰"
        message_parts = [
            f"{emoji} {'ë¡±' if position_type == 'long' else 'ìˆ'} í¬ì§€ì…˜ ì§„ì…",
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            f"ğŸ’ ì‹¬ë³¼: {symbol}",
            f"ğŸ’° ì£¼ë¬¸ê¸ˆì•¡: {settings['investment']} USDT",
            f"ğŸªœ ë ˆë²„ë¦¬ì§€: {settings['leverage']}x",
            f"ğŸ’² ì§„ì…ê°€ê²©: {position.entry_price:.2f}",
            f"ğŸ“Š í¬ì§€ì…˜ í¬ê¸°: {position_qty:.4g}"
        ]

        # TP ì •ë³´ê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ ì¶”ê°€
        if tp_levels:
            message_parts.extend([
                "",
                "ğŸ¯ ëª©í‘œê°€ê²©"
            ])
            
            # tp_levels í˜•ì‹ì— ë”°ë¥¸ ì²˜ë¦¬
            if isinstance(tp_levels, list):
                # ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° (ê°€ê²©ë§Œ ìˆëŠ” ê²½ìš°)
                for i, price in enumerate(tp_levels, 1):
                    message_parts.append(f"TP{i}: {float(price):,.2f} $")
            elif isinstance(tp_levels, dict):
                # ë”•ì…”ë„ˆë¦¬ì¸ ê²½ìš° (ê°€ê²©ê³¼ ë¹„ìœ¨ì´ ìˆëŠ” ê²½ìš°)
                for i, (price, ratio) in enumerate(tp_levels.items(), 1):
                    message_parts.append(f"TP{i}: {float(price):.2f} ({float(ratio)*100:.0f}%)")
            else:
                # ê¸°íƒ€ í˜•ì‹ì˜ ê²½ìš°
                for i, tp_info in enumerate(tp_levels, 1):
                    if isinstance(tp_info, (list, tuple)):
                        price, ratio = tp_info
                        message_parts.append(f"TP{i}: {float(price):,.2f} $ ({float(ratio)*100:.0f}%)")
                    else:
                        message_parts.append(f"TP{i}: {float(tp_info):,.2f} $")

        # SL ì •ë³´ê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ ì¶”ê°€
        if stop_loss:
            message_parts.extend([
                "",
                "ğŸ›‘ ì†ì ˆê°€ê²©",
                f"{float(stop_loss):,.2f} $"
            ])

        dca_key = f"user:{user_id}:position:{symbol}:{position_type}:dca_levels"
        current_price = await get_current_price(symbol)
        dca_levels = await calculate_dca_levels(position.entry_price, settings, position_type, atr_value, current_price)
        await update_dca_levels_redis(user_id, symbol, dca_levels, position_type)

        print(f"[{user_id}] ğŸ–¤dca_levels: {dca_levels}")
        if dca_levels and len(dca_levels) > 0:
            dca_levels = [float(level) for level in dca_levels]  # ë¬¸ìì—´ì„ floatë¡œ ë³€í™˜
            next_level = max(dca_levels) if position_type == 'long' else min(dca_levels)
            message_parts.extend([
                "",
                f"ğŸ“ ë‹¤ìŒ ì§„ì…ê°€ëŠ¥ ë ˆë²¨\n {next_level:,.2f}$"
            ])


        return "\n".join(message_parts)
    except Exception as e:
        logger.error(f"í¬ì§€ì…˜ ë©”ì‹œì§€ ìƒì„± ì˜¤ë¥˜: {str(e)}")
        traceback.print_exc()
        return "í¬ì§€ì…˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."

#def create_close_position_message(side: str, current_price: float, entry_price: float, size: float) -> str:
#    try:
#        direction = "ë¡±" if side == "long" else "ìˆ"
#        pnl = size * (current_price - entry_price) if side == "long" else size * (entry_price - current_price)
#        pnl_emoji = "ğŸŸ¢ +" if pnl > 0 else "ğŸ”´ " if pnl < 0 else "âšª"
        

#        return (
#            f"ğŸ“Š í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ\n"
#            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
#            f"ğŸ“ ë°©í–¥: {direction}\n"
#            f"ğŸ’° ì²­ì‚°ê°€: {current_price:.2f}\n"
#            f"ğŸ“ˆ í¬ê¸°: {size:.4g}\n"
#            f"ğŸ’µ ì†ìµ: {pnl_emoji} {pnl:.2f} USDT\n"
#            f"\n"
#            f"ğŸ“ ì‚¬ìœ : íŠ¸ëœë“œ ë°˜ì „ ê°ì§€"
#        )
#    except Exception as e:
#        logger.error(f"í¬ì§€ì…˜ ì²­ì‚° ë©”ì‹œì§€ ìƒì„± ì˜¤ë¥˜: {str(e)}")
#        traceback.print_exc()
#        return "í¬ì§€ì…˜ ì²­ì‚° ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."



# ======== (A) í¬ì§€ì…˜ì´ ì—†ëŠ” ê²½ìš° ========
async def handle_no_position(
    user_id, 
    settings, 
    trading_service: TradingService, 
    calculator: TrendStateCalculator, 
    symbol: str, 
    timeframe: str, 
    current_rsi: float, 
    rsi_signals: dict, 
    current_state: int
):
    """
    í¬ì§€ì…˜ì´ ì—†ì„ ë•Œ ë¡±/ìˆ ì§„ì… ì‹œë„ -> ì£¼ë¬¸ ë°œí–‰
    """
    try:
        print(f"[{user_id}] âœ…í¬ì§€ì…˜ì´ ì—†ëŠ” ê²½ìš°")
        position_manager = PositionStateManager(redis_client, trading_service)
        current_price = await get_current_price(symbol)
        
        # ê³„ì•½ ì •ë³´ ì¡°íšŒ
        contract_info = await trading_service.get_contract_info(
            user_id=user_id,
            symbol=symbol,
            size_usdt=settings['investment'],
            leverage=settings['leverage'],
            current_price=current_price
        )
        # ì‹¤ì œ ê³„ì•½ ìˆ˜ëŸ‰ ê³„ì‚°
        contracts_amount = contract_info['contracts_amount']  # ì´ë¯¸ ìµœì†Œ ì£¼ë¬¸ ìˆ˜ëŸ‰ ë“±ì´ ê³ ë ¤ëœ ê°’
        min_sustain_contract_size = 0.0
        if (float(settings['tp1_ratio']) + float(settings['tp2_ratio']) + float(settings['tp3_ratio']) == 1) or (float(settings['tp1_ratio']) + float(settings['tp2_ratio']) + float(settings['tp3_ratio']) == 100):
            min_sustain_contract_size = max(float(contracts_amount)*0.01, 0.05)
        else:
            min_sustain_contract_size = max(float(contracts_amount)*0.0001, 0.05)
        min_size_key = f"user:{user_id}:position:{symbol}:min_sustain_contract_size"
        await redis_client.set(min_size_key, min_sustain_contract_size)
        print(f"[{user_id}] OKX ê¸°ì¤€ ì£¼ë¬¸ ìˆ˜ëŸ‰(ì½˜íŠ¸ë™íŠ¸ ê°¯ìˆ˜): {contracts_amount}. ì¦‰, ì´ê²Œ ì£¼ë¬¸ì´ ë“¤ì–´ê°€ëŠ” ê³„ì•½ ìˆ˜ëŸ‰.")
        timeframe_str = tf_mapping.get(timeframe, "1m")
        print(f"[{user_id}] í¬ì§€ì…˜ ì—†ëŠ” ê²½ìš°ì˜ ë””ë²„ê¹… : {current_rsi}, rsi signals : {rsi_signals},current state : {current_state}")
        entry_fail_count_key = f"user:{user_id}:entry_fail_count"
        fail_count = int(await redis_client.get(entry_fail_count_key) or 0)
        main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
        if await redis_client.exists(main_position_direction_key):
            await redis_client.delete(main_position_direction_key)
        if fail_count >= 5:
            await send_telegram_message(
                "3íšŒ ì—°ì† ì§„ì… ì‹¤íŒ¨ë¡œ íŠ¸ë ˆì´ë”©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
                user_id,
                debug=True
            )
            await redis_client.set(f"user:{user_id}:trading:status", "stopped")
            await redis_client.delete(entry_fail_count_key)
            return

        key = f"candles_with_indicators:{symbol}:{timeframe_str}"
        try:
            candle = await redis_client.lindex(key, -1)
            if candle:
                candle = json.loads(candle)
                atr_value = candle.get('atr14')
            else:
                logger.error(f"ìº”ë“¤ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {key}")
        except Exception as e:
            logger.error(f"Redisì—ì„œ ATR ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: {str(e)}")

        entry_success = False
        
        # ë¡± ì§„ì…
        if settings['direction'] in ['ë¡±ìˆ', 'ë¡±']:
            should_check_trend = settings.get('use_trend_logic', True)
            trend_condition = (current_state != -2) if should_check_trend else True
            if rsi_signals['is_oversold'] and trend_condition:
                try:
                    request = OpenPositionRequest(
                        user_id=user_id,
                        symbol=symbol,
                        direction="long",
                        size=contracts_amount,  # ë‹¬ëŸ¬ ê¸ˆì•¡ ëŒ€ì‹  ì‹¤ì œ ê³„ì•½ ìˆ˜ëŸ‰ ì „ë‹¬
                        leverage=settings['leverage'],
                        settings=settings,
                        order_concept="new_position"
                    )
                    
                    position = await open_position_endpoint(request)
                    print(f"ï¹—ì‚¬ì´ì¦ˆ ì ê²€! : position.size: {position.size},contracts_amount: {contracts_amount}")
                    dca_count_key = f"user:{user_id}:position:{symbol}:long:dca_count"
                    await redis_client.set(dca_count_key, "1")
                    short_dca_key = f"user:{user_id}:position:{symbol}:short:dca_levels"
                    await redis_client.delete(short_dca_key)
                    long_dca_key = f"user:{user_id}:position:{symbol}:long:dca_levels"
                    await redis_client.delete(long_dca_key)
                    
                    try:
                        await position_manager.update_position_state(
                            user_id=user_id,
                            symbol=symbol,
                            entry_price=position.entry_price,
                            contracts_amount_delta=contracts_amount,  # ê³„ì•½ ìˆ˜ëŸ‰ ì‚¬ìš©
                            side="long",
                            operation_type="new_position"
                        )
                    except Exception as e:
                        logger.error(f"í¬ì§€ì…˜ ì •ë³´ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")
                    
                    message = await create_position_message(
                        user_id=user_id,
                        symbol=symbol,
                        position_type="long",
                        position=position,
                        settings=settings,
                        tp_levels=position.tp_prices if position.tp_prices else None,
                        stop_loss=position.sl_price,
                        contracts_amount=contracts_amount,
                        trading_service=trading_service,
                        atr_value=atr_value
                    )
                    await send_telegram_message(message, user_id)
                    await redis_client.set(f"user:{user_id}:position:{symbol}:long:dca_count", 1)
                    await record_trade_entry(
                        user_id=user_id,
                        symbol=symbol,
                        entry_price=position.entry_price,
                        size=contracts_amount,  # ê³„ì•½ ìˆ˜ëŸ‰ ì‚¬ìš©
                        side="long",
                        is_DCA=False
                    )
                    
                    tp_data_key = f"user:{user_id}:position:{symbol}:long:tp_data"
                    await redis_client.set(tp_data_key, json.dumps(position.tp_prices))
                    entry_success = True
                    await redis_client.delete(entry_fail_count_key)

                except Exception as e:
                    if "ì§ì „ ì£¼ë¬¸ ì¢…ë£Œ í›„ ì¿¨ë‹¤ìš´ ì‹œê°„ì´ ì§€ë‚˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤." in str(e):
                        pass
                    else:
                        error_logger.error("ë¡± í¬ì§€ì…˜ ì§„ì… ì‹¤íŒ¨", exc_info=True)

                        traceback.print_exc()
                        error_msg = map_exchange_error(e)
                        if not entry_success:
                            fail_count += 1
                        await redis_client.set(entry_fail_count_key, fail_count)
                        
                        await send_telegram_message(
                            f"[{user_id}]âš ï¸ ë¡± í¬ì§€ì…˜ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            f"{error_msg}\n"
                            f"ì¬ì‹œë„ íšŸìˆ˜: {fail_count}/3",
                            1709556958
                        )
            elif rsi_signals['is_oversold'] and not trend_condition:
                alert_key = f"user:{user_id}:trend_signal_alert"
                is_alerted = await redis_client.get(alert_key)
                if not is_alerted:
                    await send_telegram_message(
                        f"[{user_id}]âš ï¸ ë¡± í¬ì§€ì…˜ ì§„ì… ì¡°ê±´ ë¶ˆì¶©ì¡±\n"
                        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    f"RSIê°€ ê³¼ë§¤ìˆ˜ ìƒíƒœì´ì§€ë§Œ íŠ¸ëœë“œ ì¡°ê±´ì´ ë§ì§€ ì•Šì•„ ì§„ì…ì„ ìœ ë³´í•©ë‹ˆë‹¤.",
                    user_id
                    )
                    await redis_client.set(alert_key, "true", ex=7200)

        # ìˆ ì§„ì… ë¡œì§ë„ ë™ì¼í•˜ê²Œ ìˆ˜ì •...
        if settings['direction'] in ['ë¡±ìˆ', 'ìˆ']:
            should_check_trend = settings.get('use_trend_logic', True)
            trend_condition = (current_state != 2) if should_check_trend else True
            if rsi_signals['is_overbought'] and trend_condition:
                try:
                    print("2ë²ˆ")
                    request = OpenPositionRequest(
                        user_id=user_id,
                        symbol=symbol,
                        direction="short",
                        size=contracts_amount,  # ë‹¬ëŸ¬ ê¸ˆì•¡ ëŒ€ì‹  ì‹¤ì œ ê³„ì•½ ìˆ˜ëŸ‰ ì „ë‹¬
                        leverage=settings['leverage'],
                        settings=settings,
                        order_concept="new_position"
                    )
                    position = await open_position_endpoint(request)
                    
                    dca_long_key = f"user:{user_id}:position:{symbol}:long:dca_levels"
                    await redis_client.delete(dca_long_key)
                    dca_count_key = f"user:{user_id}:position:{symbol}:short:dca_count"
                    await redis_client.set(dca_count_key, 1)
                    message = await create_position_message(
                        user_id=user_id,
                        symbol=symbol,
                        position_type="short",
                        position=position,
                        settings=settings,
                        tp_levels=position.tp_prices if position.tp_prices else None,
                        stop_loss=position.sl_price,
                        contracts_amount=contracts_amount,
                        trading_service=trading_service,
                        atr_value=atr_value
                    )
                            

                    await send_telegram_message(message, user_id)
                    await position_manager.update_position_state(user_id, symbol, current_price, contracts_amount, "short", operation_type="new_position")
                    await redis_client.set(f"user:{user_id}:{symbol}:short:dca_count", 1)

                    tp_data_key = f"user:{user_id}:position:{symbol}:short:tp_data"
                    await redis_client.set(tp_data_key, json.dumps(position.tp_prices))
                    await record_trade_entry(
                        user_id=user_id,
                        symbol=symbol,
                        entry_price=position.entry_price,
                        size=contracts_amount,  # ê³„ì•½ ìˆ˜ëŸ‰ ì‚¬ìš©
                        side="short"
                    )
                    entry_success = True
                    await redis_client.delete(entry_fail_count_key)  # ì„±ê³µì‹œ ì¹´ìš´íŠ¸ ë¦¬ì…‹

                except Exception as e:
                    if "ì§ì „ ì£¼ë¬¸ ì¢…ë£Œ í›„ ì¿¨ë‹¤ìš´ ì‹œê°„ì´ ì§€ë‚˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤." in str(e):
                        pass
                    else:
                        error_msg = map_exchange_error(e)
                        error_logger.error("ìˆ í¬ì§€ì…˜ ì§„ì… ì‹¤íŒ¨", exc_info=True)

                        # ì§„ì… ì‹¤íŒ¨ ì‹œ ì¹´ìš´íŠ¸ ì¦ê°€
                        if not entry_success:
                            fail_count += 1
                            await redis_client.set(entry_fail_count_key, fail_count)
                            
                        await send_telegram_message(
                            f"[{user_id}]âš ï¸ ìˆ í¬ì§€ì…˜ ì£¼ë¬¸ ì‹¤íŒ¨\n"
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            f"{error_msg}\n"
                            f"ì¬ì‹œë„ íšŸìˆ˜: {fail_count}/5",
                            user_id, 
                            debug=True
                            )
            elif rsi_signals['is_overbought'] and not trend_condition:
                alert_key = f"user:{user_id}:trend_signal_alert"
                is_alerted = await redis_client.get(alert_key)
                if not is_alerted:
                    await send_telegram_message(
                        f"[{user_id}]âš ï¸ ìˆ í¬ì§€ì…˜ ì§„ì… ì¡°ê±´ ë¶ˆì¶©ì¡±\n"
                        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        f"RSIê°€ ê³¼ë§¤ìˆ˜ ìƒíƒœì´ì§€ë§Œ íŠ¸ëœë“œ ì¡°ê±´ì´ ë§ì§€ ì•Šì•„ ì§„ì…ì„ ìœ ë³´í•©ë‹ˆë‹¤.",
                        user_id
                    )
                    await redis_client.set(alert_key, "true", ex=7200)

            if fail_count >= 3:
                await redis_client.set(f"user:{user_id}:trading:status", "stopped")
                await send_telegram_message(
                    "íŠ¸ë ˆì´ë”© ìë™ ì¢…ë£Œ\n"
                    "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                    "3íšŒ ì—°ì† ì§„ì… ì‹¤íŒ¨ë¡œ íŠ¸ë ˆì´ë”©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
                    user_id, 
                    debug=True
                )
                await redis_client.delete(entry_fail_count_key)

    except Exception as e:
        error_msg = map_exchange_error(e)
        error_logger.error(f"[{user_id}]:í¬ì§€ì…˜ ì§„ì… ì˜¤ë¥˜", exc_info=True)
        await send_telegram_message(f"âš ï¸ í¬ì§€ì…˜ ì§„ì… ì˜¤ë¥˜:\n{error_msg}", user_id)


# ======== (B) í¬ì§€ì…˜ì´ ìˆëŠ” ê²½ìš° ========
async def handle_existing_position(
    user_id: int,
    settings: dict,
    trading_service: TradingService,
    calculator: TrendStateCalculator,
    symbol: str,
    timeframe: str,
    current_position: Position,
    current_rsi: float,
    rsi_signals: dict,
    current_state: int,
    side: str,
    
):
    """
    ì´ë¯¸ í¬ì§€ì…˜ì´ ìˆì„ ë•Œ:
    - DCA/í”¼ë¼ë¯¸ë”© ì¶”ê°€ ì§„ì…
    - TP/SL ëª¨ë‹ˆí„°ë§
    - ë¸Œë ˆì´í¬ì´ë¸
    - ì²­ì‚° ì¡°ê±´
    """

    korean_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    position_manager = PositionStateManager(redis_client, trading_service)
    current_price = await get_current_price(symbol, timeframe)
    if side == "any":
        print("[âš ï¸] í¬ì§€ì…˜ ë°©í–¥ì´ ì—†ìŠµë‹ˆë‹¤. í¬ì§€ì…˜ ë°©í–¥ì„ ì°¾ì•„ì„œ ì„¤ì •í•©ë‹ˆë‹¤.")
        main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
        side = await redis_client.get(main_position_direction_key)
        if side is None or side == "any":
            side = current_position.side
            await redis_client.set(main_position_direction_key, side)
    size = current_position.size
    entry_price = current_position.entry_price
    print(f"ì‹œê°„:{korean_time} âœ…í¬ì§€ì…˜ì´ ìˆëŠ” ê²½ìš°. í‰ë‹¨ : {entry_price}, í¬ì§€ì…˜ ìˆ˜ëŸ‰ : {size}, í¬ì§€ì…˜ ë°©í–¥ : {side}")
    key = f"candles_with_indicators:{symbol}:{timeframe}"
    candle = await redis_client.lindex(key, -1)
    if candle:
        candle = json.loads(candle)
        atr_value = max(candle.get('atr14'), current_price*0.1*0.01)
    else:
        atr_value = current_price*0.01*0.1
        logger.error(f"ìº”ë“¤ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {key}")
    #if current_position:
        #print(f"current_position: {current_position}")
        #print(f"side: {side}")  # ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê¹… ì¶”ê°€
    #print(f"2entry_price: {current_position.entry_price}, total_size: {current_position.size}, stored_side: {side}")
    trading_status = await redis_client.get(f"user:{user_id}:trading:status")
    main_position_direction = await redis_client.get(f"user:{user_id}:position:{symbol}:main_position_direction")
    await monitor_tp_sl(user_id, symbol, main_position_direction, current_price, redis_client, trading_service, settings)
    if trading_status != "running":
        print("ğŸ’štrading_status4: ", trading_status)

    if not entry_price or not size:
        # ê±°ë˜ì†Œ ìµœì‹  ì •ë³´ë¡œ ì¬ë™ê¸°í™”
        exch_pos = await trading_service.get_current_position(user_id, symbol, side)
        if exch_pos is None:
            # mismatch => Redis ì •ë¦¬
            await position_manager.cleanup_position_data(user_id, symbol, side)
            await send_telegram_message(f"[{user_id}]âŒ í¬ì§€ì…˜ ì •ë³´ ë¶ˆì¼ì¹˜: Redis ì´ˆê¸°í™”", user_id, debug=True)
            return
        else:
            entry_price = exch_pos.entry_price
            size = exch_pos.size
            await position_manager.update_position_state(user_id, symbol, entry_price, size, side, operation_type="add_position")
            print("í¬ì§€ì…˜ ì •ë³´ ë™ê¸°í™” ì™„ë£Œ")
            
    pyramiding_limit = settings.get('pyramiding_limit', 1)
    use_check_DCA_with_price = settings.get('use_check_DCA_with_price', True)
    #print(f"pyramiding limit", pyramiding_limit)
     # â”€â”€â”€ (1) DCA/í”¼ë¼ë¯¸ë”© ì¶”ê°€ ì§„ì…  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cooldown_key = f"user:{user_id}:cooldown:{symbol}"
    is_cooldown = await redis_client.get(cooldown_key)
    left_time = await redis_client.ttl(cooldown_key)
    if is_cooldown:
        print(f"[{user_id}] ì¿¨ë‹¤ìš´ ì¤‘ì…ë‹ˆë‹¤. {symbol} ì¢…ëª©ì— ëŒ€í•´ì„œëŠ” ì§„ì…ì„ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‚¨ì€ ì‹œê°„: {left_time}ì´ˆ")
        return
    if pyramiding_limit > 1:
        position_key = f"user:{user_id}:position:{symbol}:{side}"
        position_info = await redis_client.hgetall(position_key)
        # DCA ë ˆë²¨ ê°€ì ¸ì˜¤ê¸° ë˜ëŠ” ìƒˆë¡œ ê³„ì‚°
        dca_key = f"user:{user_id}:position:{symbol}:{side}:dca_levels"
        dca_levels = await redis_client.lrange(dca_key, 0, -1)
        
        if True : #not dca_levels:  # DCA ë ˆë²¨ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ê³„ì‚° <-- í•­ìƒ ê³„ì‚°ì´ ë˜ì–´ì•¼ ë§ë‹¤. 
            initial_entry_price = float(position_info.get('entry_price', current_price))
            dca_levels = await calculate_dca_levels(initial_entry_price, settings, side, atr_value, current_price)
            await update_dca_levels_redis(user_id, symbol, dca_levels, side)

        dca_levels = await redis_client.lrange(dca_key, 0, -1)
        current_price = float(current_price)
        # ì²« ë²ˆì§¸ DCA ë ˆë²¨ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ì§„í–‰
        if dca_levels and len(dca_levels) > 0:
            first_dca_level = float(dca_levels[0])  # ì²« ë²ˆì§¸ DCA ë ˆë²¨
            # DCA ì¡°ê±´ ì²´í¬ (ë¡±/ìˆì— ë”°ë¼ ë‹¤ë¥¸ ì¡°ê±´ ì ìš©)
            if use_check_DCA_with_price:
                dca_condition = (current_price <= first_dca_level if side == "long" 
                                else current_price >= first_dca_level)
            else:
                dca_condition = True
            print(f"Current Price: {current_price}, First DCA Level: {first_dca_level}, Side: {side}, DCA Condition: {dca_condition}")

        
        if await check_dca_condition(current_price, dca_levels, side, use_check_DCA_with_price):
            dca_order_count_key = f"user:{user_id}:position:{symbol}:{side}:dca_count"
            dca_order_count = await redis_client.get(dca_order_count_key)
            print(f"dca_order_count: {dca_order_count}")
            if dca_order_count is None:
                dca_order_count = 1
                await redis_client.set(dca_order_count_key, 1)
            else:
                dca_order_count = int(dca_order_count)

            position_key = f"user:{user_id}:position:{symbol}:{side}"
            position_info = await redis_client.hgetall(position_key)
            position_size = float(position_info.get('size', 0))
            scale = settings.get('entry_multiplier', 0.5)
            
            new_position_entry_contract_size = position_size * float(scale)
            print(f"new_position_entry_contract_size : {new_position_entry_contract_size}, former position_size : {position_size}, scale : {scale}")
            if side == "long":
                should_check_trend = settings.get('use_trend_logic', True)
                trend_condition = True
                if should_check_trend and current_state == -2:
                    trend_condition = False
                    
                rsi_long_signals_condition = False
                if settings.get('use_rsi_with_pyramiding', True):
                    rsi_long_signals_condition = rsi_signals['is_oversold']
                else:
                    rsi_long_signals_condition = True
                print(f"rsi_signals['is_oversold'] : {rsi_signals['is_oversold']}, trend_condition : {trend_condition}, dca_order_count : {dca_order_count}, pyramiding_limit : {settings.get('pyramiding_limit', 1)}")
                if (rsi_long_signals_condition and trend_condition) and dca_order_count < settings.get('pyramiding_limit', 1):
                
                    try:
                        print("3ë²ˆ")
                        new_position_entry_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_entry_contract_size)
                        request = OpenPositionRequest(
                            user_id=user_id,
                            symbol=symbol,
                            direction="long",
                            size=new_position_entry_contract_size,
                            leverage=settings['leverage'],
                            settings=settings,
                            is_DCA=True,
                        )
                        try:
                            position = await open_position_endpoint(request)
                            dca_count_key = f"user:{user_id}:position:{symbol}:long:dca_count"
                            dca_order_count = await redis_client.get(dca_count_key)
                            dca_order_count = int(dca_order_count) + 1
                            await redis_client.set(dca_count_key, dca_order_count)
                        except Exception as e:
                            error_logger.error(f"[{user_id}]:DCA ë¡± ì£¼ë¬¸ ì‹¤íŒ¨", exc_info=True)
                            await send_telegram_message(
                                f"âš ï¸ DCA ì¶”ê°€ì§„ì… ì‹¤íŒ¨ (ë¡±)\n"
                                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                                f"{e}\n", 
                                user_id=user_id,
                                debug=True)
                            return
                        
                        dca_key = f"user:{user_id}:position:{symbol}:long:dca_levels"
                        new_entry_price = position.entry_price
                        try:
                            new_position_contract_size = position.size
                            new_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_contract_size)
                        except Exception as e:
                            send_telegram_message(f"ë¡± ì¶”ê°€ì§„ì… ì‹¤íŒ¨ ì˜¤ë¥˜: {e}", user_id, debug=True)
                            print("ë¡± ì¶”ê°€ì§„ì… ì‹¤íŒ¨ ì˜¤ë¥˜: ", e)
                            return
                        new_avg, new_size = await position_manager.update_position_state(user_id, symbol, current_price, contracts_amount_delta=new_position_contract_size, position_qty_delta=new_position_qty, side = "long", operation_type="add_position", new_entry_exact_price=new_entry_price, new_exact_contract_size=new_position_contract_size)
                        new_total_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_contract_size)
                        print("ì´ í¬ì§€ì…˜ ìˆ˜ëŸ‰ ì œëŒ€ë¡œ ë‚˜ì˜¤ëŠ”ì§€ ê¼­ í™•ì¸!~!!!!!1", new_total_position_qty)
                        
                        new_position_qty_size_from_redis = await redis_client.hget(f"user:{user_id}:position:{symbol}:long", "position_qty")
                        position_avg_price = await trading_service.get_position_avg_price(user_id, symbol, side)
                        telegram_message = "ğŸ”¼ ì¶”ê°€ì§„ì… (ë¡±)"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += f"ğŸ“Š ë¡± {dca_order_count}íšŒì°¨ ì§„ì…\n"
                        telegram_message += f"ğŸ“ˆ ìˆ˜ëŸ‰: +{new_position_entry_qty}\n"
                        telegram_message += f"ğŸ’° ìƒˆ í‰ê· ê°€: {position_avg_price:,.2f}\n"
                        telegram_message += f"ğŸ“ ì´ í¬ì§€ì…˜: {float(new_position_qty_size_from_redis):.3f}\n"
                        telegram_message += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        await send_telegram_message(telegram_message, user_id)
                        await record_trade_entry(
                            user_id=user_id,
                            symbol=symbol,
                            entry_price=current_price,
                            size=new_position_contract_size,
                            side="long",
                            is_DCA=True,  # DCA ì—¬ë¶€ í‘œì‹œ
                            dca_count=dca_order_count
                        )
                        
                
                        
                        if settings.get('use_dual_side_entry', False):
                            print("4ë²ˆ")
                            try:
                                await manage_dual_side_entry(
                                    user_id=user_id,
                                    symbol=symbol,
                                    current_price=current_price,
                                    dca_order_count=dca_order_count,
                                    main_position_side=side,
                                    settings=settings,
                                    trading_service=trading_service,
                                    redis_client=redis_client,
                                    exchange=trading_service.client
                                    )
                            except Exception as e:
                                error_logger.error(f"[{user_id}]:DCA ë¡± ì£¼ë¬¸ ì‹¤íŒ¨", exc_info=True)
                                await send_telegram_message(
                                    f"âš ï¸ ì¶”ê°€ì§„ì… ì‹¤íŒ¨ (ë¡±)\n"
                                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                                    f"{e}\n", 
                                    user_id=user_id,
                                    debug=True)
                            await record_trade_entry(
                                user_id=user_id,
                                symbol=symbol,
                                entry_price=current_price,
                                size=new_position_contract_size,
                                side=side,
                                is_DCA=True,  # DCA ì—¬ë¶€ í‘œì‹œ
                                dca_count=dca_order_count
                            )
                    except Exception as e:
                        error_msg = map_exchange_error(e)
                        error_logger.error(f"[{user_id}]:ë¡± ì£¼ë¬¸ ì‹¤íŒ¨", exc_info=True)
                        await send_telegram_message(
                            f"âš ï¸ ì¶”ê°€ì§„ì… ì‹¤íŒ¨ (ë¡±)\n"
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            f"í˜„ì¬ê°€ê²©: {current_price}\n"
                            f"ì‹œë„í•œ ì¶”ê°€ë¬¼ëŸ‰: {new_position_qty}",
                            user_id
                        )
                        await send_telegram_message(
                            f"âš ï¸[{user_id}] ì¶”ê°€ì§„ì… ì‹¤íŒ¨ (ë¡±)\n"
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            f"{error_msg}\n"
                            f"í˜„ì¬ê°€ê²©: {current_price}\n"
                            f"ì‹œë„í•œ ì¶”ê°€ë¬¼ëŸ‰: {new_position_qty}\n"
                            f"ì‹œë„í•œ ì¶”ê°€ ê³„ì•½: {new_position_contract_size}",
                            user_id, debug=True
                        )
            elif side == "short":
                should_check_trend = settings.get('use_trend_logic', True)
                trend_condition = True
                if should_check_trend and current_state == 2:
                    trend_condition = False
                rsi_short_signals_condition = False
                if settings.get('use_rsi_with_pyramiding', True):
                    rsi_short_signals_condition = rsi_signals['is_overbought']
                else:
                    rsi_short_signals_condition = True
                print(f"rsi short signals condition : {rsi_short_signals_condition}, trend_condition : {trend_condition}, dca_order_count : {dca_order_count}, pyramiding_limit : {settings.get('pyramiding_limit', 1)}")
                if (rsi_short_signals_condition and trend_condition) and dca_order_count < settings.get('pyramiding_limit', 1):
                    print("í”¼ë¼ë¯¸ë”© ìˆ ì§„ì… í˜¸ì¶œ")
                    try:
                        
                        request = OpenPositionRequest(
                            user_id=user_id,
                            symbol=symbol,
                            direction="short",
                            size=new_position_entry_contract_size,
                            leverage=settings['leverage'],
                            settings=settings,
                            is_DCA=True,
                        )
                        try:
                            position = await open_position_endpoint(request)
                            dca_count_key = f"user:{user_id}:position:{symbol}:short:dca_count"
                            dca_order_count = await redis_client.get(dca_count_key)
                            dca_order_count = int(dca_order_count) + 1
                            await redis_client.set(dca_count_key, dca_order_count)
                        except Exception as e:
                            error_logger.error(f"[{user_id}]:DCA ìˆ ì£¼ë¬¸ ì‹¤íŒ¨1", exc_info=True)
                            await send_telegram_message(
                                f"âš ï¸ ì¶”ê°€ì§„ì… ì‹¤íŒ¨ (ìˆ)\n"
                                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                                f"{e}\n", 
                                user_id=user_id,
                                debug=True)
                            return
                        
                        if settings.get('use_dual_side_entry', False):
                            print("4ë²ˆ")
                            try:
                                await manage_dual_side_entry(
                                    user_id=user_id,
                                    symbol=symbol,
                                    current_price=current_price,
                                    dca_order_count=dca_order_count,
                                    main_position_side=side,
                                    settings=settings,
                                    trading_service=trading_service,
                                    redis_client=redis_client,
                                    exchange=trading_service.client
                                    )
                            except Exception as e:
                                error_logger.error(f"[{user_id}]:DCA ìˆ ì£¼ë¬¸ ì‹¤íŒ¨2", exc_info=True)
                                await send_telegram_message(
                                    f"âš ï¸ ì¶”ê°€ì§„ì… ì‹¤íŒ¨ (ìˆ)\n"
                                    f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                                    f"{e}\n", 
                                    user_id=user_id,
                                    debug=True)
                        dca_key = f"user:{user_id}:position:{symbol}:short:dca_levels"
                        await redis_client.lpop(dca_key)
                        new_entry_price = position.entry_price
                        try:
                            new_total_contract_size = position.size
                            new_position_contract_size = position.size
                            new_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_position_entry_contract_size)
                        except Exception as e:
                            send_telegram_message(f"ìˆ ì¶”ê°€ì§„ì… ì‹¤íŒ¨ ì˜¤ë¥˜: {e}", user_id, debug=True)
                            print("ìˆ ì¶”ê°€ì§„ì… ì‹¤íŒ¨ ì˜¤ë¥˜: ", e)
                            return
                        
                        
                        new_total_position_qty = await trading_service.contract_size_to_qty(user_id, symbol, new_total_contract_size)
                        new_avg, new_size = await position_manager.update_position_state(user_id, symbol, current_price, contracts_amount_delta=new_position_entry_contract_size, position_qty_delta=new_position_qty, side = "short", operation_type="add_position", new_entry_exact_price=new_entry_price, new_exact_contract_size=new_total_contract_size)
                        await record_trade_entry(
                                user_id=user_id,
                                symbol=symbol,
                                entry_price=current_price,
                                size=new_position_contract_size,
                                side=side,
                                is_DCA=True,  # DCA ì—¬ë¶€ í‘œì‹œ
                                dca_count=dca_order_count 
                            )             
                        total_position_qty = await redis_client.hget(f"user:{user_id}:position:{symbol}:{side}", "position_qty")
                        position_avg_price = await trading_service.get_position_avg_price(user_id, symbol, side)
                        telegram_message = "ğŸ”½ ì¶”ê°€ì§„ì… (ìˆ)"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        telegram_message += f"[{symbol}]\n"
                        telegram_message += f"ìˆ ğŸ“Š {dca_order_count}íšŒì°¨ ì§„ì…\n"
                        telegram_message += f"ğŸ“ˆ ìˆ˜ëŸ‰: +{new_position_qty}\n"
                        telegram_message += f"ğŸ’° ìƒˆ í‰ê· ê°€: {position_avg_price:,.2f}\n"
                        telegram_message += f"ğŸ“ ì´ í¬ì§€ì…˜: {float(total_position_qty):.3f}\n"
                        telegram_message += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        await send_telegram_message(telegram_message, user_id)
                    except Exception as e:
                        error_msg = map_exchange_error(e)
                        error_logger.error(f"[{user_id}]:DCA ìˆ ì£¼ë¬¸ ì‹¤íŒ¨3", exc_info=True)
                        await send_telegram_message(
                            f"ìˆ ì£¼ë¬¸ ì‹¤íŒ¨(ìˆ)\n"
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            f"í˜„ì¬ê°€ê²©: {current_price}\n"
                            f"ì‹œë„í•œ ì¶”ê°€ë¬¼ëŸ‰: {new_position_qty}",
                            user_id
                        )
                        await send_telegram_message(
                            f"âš ï¸ ì¶”ê°€ì§„ì… ì‹¤íŒ¨ (ìˆ)\n"
                            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                            f"{error_msg}\n"
                            f"í˜„ì¬ê°€ê²©: {current_price}\n"
                            f"ì‹œë„í•œ ì¶”ê°€ë¬¼ëŸ‰: {new_position_qty}\n"
                            f"ì‹œë„í•œ ì¶”ê°€ ê³„ì•½: {new_position_contract_size}",
                            user_id, debug=True
                        )
            else:
                print("sideê°€ ì—†ìŠµë‹ˆë‹¤. side : ", side)
    position_key = f"user:{user_id}:position:{symbol}:{side}"
    position_info = await redis_client.hgetall(position_key)
    tp_data = json.loads(position_info.get('tp_data', '[]'))
 
    # (4) ì²­ì‚° ì¡°ê±´(íŠ¸ëœë“œ ë°˜ì „ ë“±)
    should_close_with_trend = settings.get('use_trend_close', True)
    if should_close_with_trend:
        try:
            if (side == "long" and current_state == -2) or (side == "short" and current_state == 2):
                try:
                    print("ì²­ì‚° ë°˜ì „")
                    print("7ë²ˆ")
                    await trading_service.close_position(
                        user_id=user_id,
                        symbol=symbol,
                        percent = 100,
                        comment="íŠ¸ëœë“œ ë°˜ì „ í¬ì§€ì…˜ ì¢…ë£Œ",
                        side=side
                    )
                    pnl = size * (current_price - entry_price) if side == "long" else size * (entry_price - current_price)
                    
                    position_qty = await contracts_to_qty(symbol, size)

                    await update_trading_stats(
                    user_id=user_id,
                    symbol=symbol,
                    entry_price=entry_price,
                    exit_price=current_price,
                    position_size=position_qty,
                    pnl=pnl,
                    side=side,
                    entry_time=position_info.get("entry_time", str(datetime.now())),
                    exit_time=str(datetime.now()),
                    redis_client=redis_client
                    )
                                # Redis í¬ì§€ì…˜/í‰ê· ê°€ ë“± ì´ˆê¸°í™”
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:entry_price")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:long:dca_count")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:short:dca_count")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:long:dca_levels")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:short:dca_levels")
                    await redis_client.delete(f"user:{user_id}:position:{symbol}:{side}")
                except Exception as e:
                    traceback.print_exc()
                    error_logger.error(f"[{user_id}]:íŠ¸ëœë“œ ë°˜ì „ ì²­ì‚° ì‹¤íŒ¨", exc_info=True)
                    await send_telegram_message(f"âš ï¸ íŠ¸ëœë“œ ë°˜ì „ ì²­ì‚° ì‹¤íŒ¨: {str(e)}", user_id, debug=True) 
                

        except Exception as e:
            error_logger.error(f"[{user_id}]:í¬ì§€ì…˜ ì²­ì‚° ì‹¤íŒ¨", exc_info=True)
            await send_telegram_message(f"âš ï¸ í¬ì§€ì…˜ ì²­ì‚° ì‹¤íŒ¨: {str(e)}", user_id, debug=True)
    return


# ======== (C) ë©”ì¸ íŠ¸ë ˆì´ë”© ë¡œì§ ========ã…‹ã…ˆ
@EventLoopManager.with_event_loop
async def execute_trading_logic(user_id: str, symbol: str, timeframe: str, restart = False):
    """
    - ì£¼ê¸°ì ìœ¼ë¡œ:
      1) monitor_orders()ë¥¼ í†µí•´ ì£¼ë¬¸ ì²´ê²° ì—¬ë¶€ë¥¼ ì—…ë°ì´íŠ¸
      2) RSI/íŠ¸ëœë“œ ì²´í¬ -> í¬ì§€ì…˜ ë¶„ê¸°ì²˜ë¦¬
    """
    # ì‹¤í–‰ ì „ ì˜¬ë°”ë¥¸ ì´ë²¤íŠ¸ ë£¨í”„ë¥¼ í™•ë³´ <-- ì´ê²Œ í•„ìš”í•œê°€? ì´ë¯¸ ìƒìœ„ì—ì„œ ì²˜ë¦¬í•˜ëŠ”ë°?
    #loop = ensure_async_loop()
    trading_service = None
    
    try:
        # íŠ¸ë ˆì´ë”© ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        trading_service = await TradingService.create_for_user(user_id)
        okx_instance = trading_service.client
        calculator = TrendStateCalculator()
        redis_service = RedisService()

        # Redis ì—°ê²° í™•ì¸
        await redis_client.ping()
        await redis_client.set(f"user:{user_id}:trading:status", "running")

    except Exception as e:
        error_msg = f"íŠ¸ë ˆì´ë”© ì´ˆê¸°í™” ì‹¤íŒ¨: {str(e)}"
        error_logger.error(error_msg)
        try:
            await send_telegram_message(f"âš ï¸ {error_msg}", user_id)
        except Exception as telegram_error:
            logger.error(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: {str(telegram_error)}")
        
        if trading_service:
            try:
                await trading_service.close()
            except Exception as close_error:
                logger.error(f"íŠ¸ë ˆì´ë”© ì„œë¹„ìŠ¤ ì¢…ë£Œ ì‹¤íŒ¨: {str(close_error)}")
        return

    try:
        # ì‚¬ìš©ì ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        user_settings = await redis_service.get_user_settings(user_id)
        if not user_settings:
            await send_telegram_message(
                "âš ï¸ íŠ¸ë ˆì´ë”© ì„¤ì • ì˜¤ë¥˜\n"
                "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                "ì‚¬ìš©ì ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
                "/settings ëª…ë ¹ì–´ë¡œ ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.",
                user_id
            )
            return
        entry_fail_count_key = f"user:{user_id}:entry_fail_count"
        await redis_client.delete(entry_fail_count_key)
        active_key = f"user:{user_id}:preferences"
        
        # ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬ëœ symbolì´ ì—†ëŠ” ê²½ìš°ì—ë§Œ Redisì—ì„œ ê°€ì ¸ì˜´
        if symbol is None:
            symbol = await redis_client.hget(active_key, "symbol")
            if not symbol:
                symbol = 'BTC-USDT-SWAP'
                
        if timeframe is None:   
            timeframe = await redis_client.hget(active_key, "timeframe")
            if not timeframe:
                timeframe = '1m'
        if not symbol or not timeframe:
            await send_telegram_message(
                "âš ï¸ íŠ¸ë ˆì´ë”© ì„¤ì • ì˜¤ë¥˜\n"
                "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                "ì‹¬ë³¼ ë˜ëŠ” íƒ€ì„í”„ë ˆì„ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
                "ì„¤ì •ì„ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œì‘í•´ì£¼ì„¸ìš”.",
                user_id
            )
            return
        
        print(f"Active Symbol: {symbol}, Active Timeframe: {timeframe}")
        
        # ìµœì†Œ ì£¼ë¬¸ ê¸ˆì•¡ ê²€ì¦
        investment = None
        min_notional = 200  # ìµœì†Œ ëª…ëª© ê°€ì¹˜ (USDT)
        if symbol == "BTC-USDT-SWAP":
            investment = float(user_settings.get('btc_investment', 20))
        elif symbol == "ETH-USDT-SWAP":
            investment = float(user_settings.get('eth_investment', 10))
        elif symbol == "SOL-USDT-SWAP":
            investment = float(user_settings.get('sol_investment', 10))
        else:
            investment = float(user_settings.get('investment', 0))  # ê¸°ë³¸ê°’
        leverage = float(user_settings.get('leverage', 10))
        actual_notional = investment * leverage
        print(f"[{user_id}] : symbol: {symbol}, investment: {investment}, leverage: {leverage}, actual_notional: {actual_notional}")
        
        if actual_notional < min_notional:
            await send_telegram_message(
                f"âš ï¸ ìµœì†Œ ì£¼ë¬¸ ê¸ˆì•¡ ì˜¤ë¥˜\n"
                f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                f"í˜„ì¬ ì„¤ì •ëœ ê¸ˆì•¡ì´ ìµœì†Œ ì£¼ë¬¸ ê¸ˆì•¡ë³´ë‹¤ ì‘ìŠµë‹ˆë‹¤.\n"
                f"â€¢ í˜„ì¬: {actual_notional:.2f} USDT\n"
                f"â€¢ í•„ìš”: {min_notional:.2f} USDT\n"
                f"â€¢ ìµœì†Œ íˆ¬ìê¸ˆ: {min_notional:.2f} USDT\n"
                f"â€¢ í˜„ì¬ ë ˆë²„ë¦¬ì§€: {leverage}x\n\n"
                f"ì„¤ì •ì„ ìˆ˜ì •í•˜ê³  ë‹¤ì‹œ ì‹œì‘í•´ì£¼ì„¸ìš”.",
                user_id
            )
            return
        print(f"[{user_id}] RESTART ì—¬ë¶€ : {restart}")
        if restart:
            pass    
        else:
            # íŠ¸ë ˆì´ë”© ì‹œì‘ ë©”ì‹œì§€
            trading_start_msg = f"ğŸš€ ìë™ íŠ¸ë ˆì´ë”©ì„ ì‹œì‘í•©ë‹ˆë‹¤\n"
            trading_start_msg += f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            trading_start_msg += f"ğŸ“Š íŠ¸ë ˆì´ë”© ì„¤ì • ì •ë³´\n"
            trading_start_msg += f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            trading_start_msg += f"ì‹¬ë³¼: {symbol}\n"
            trading_start_msg += f"íƒ€ì„í”„ë ˆì„: {timeframe}\n"
            trading_start_msg += f"íˆ¬ìê¸ˆ: {investment} USDT\n"
            trading_start_msg += f"ë ˆë²„ë¦¬ì§€: {leverage}x\n"
            trading_start_msg += f"ëª…ëª© ê°€ì¹˜: {actual_notional:.2f} USDT"
            await send_telegram_message(trading_start_msg, user_id)
            await init_user_position_data(user_id, symbol, "long")
            await init_user_position_data(user_id, symbol, "short")
            # ê¸°ì¡´ main_position_direction í‚¤ê°€ ìˆìœ¼ë©´ ì‚­ì œ
            main_position_key = f"user:{user_id}:position:{symbol}:main_position_direction"
            hedging_position_key = f"user:{user_id}:position:{symbol}:hedging_position_direction"
            if await redis_client.exists(main_position_key):
                await redis_client.delete(main_position_key)
            if await redis_client.exists(hedging_position_key):
                await redis_client.delete(hedging_position_key)



        position_info = await trading_service.fetch_okx_position(user_id, symbol)
        leverage = float(user_settings.get('leverage', 1.0))

        # position_infoê°€ ì´ì œ {'long': {...}, 'short': {...}} í˜•íƒœì´ë¯€ë¡œ
        # í˜„ì¬ ë ˆë²„ë¦¬ì§€ëŠ” ì¡´ì¬í•˜ëŠ” í¬ì§€ì…˜ì—ì„œ ê°€ì ¸ì˜´
        current_leverage = None
        if position_info:
            # long í¬ì§€ì…˜ì´ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
            if 'long' in position_info:
                current_leverage = float(position_info['long'].get('leverage', leverage))
            # ì—†ìœ¼ë©´ short í¬ì§€ì…˜ì—ì„œ ê°€ì ¸ì˜´
            elif 'short' in position_info:
                current_leverage = float(position_info['short'].get('leverage', leverage))
            else:
                current_leverage = leverage

        print(f"ë ˆë²„ë¦¬ì§€: {leverage}, í˜„ì¬ ë ˆë²„ë¦¬ì§€: {current_leverage}")
        is_hedge_mode, tdMode = await trading_service.get_position_mode(user_id, symbol)
        is_running = await redis_client.get(f"user:{user_id}:trading:status")
        if not restart:
            try:
                if leverage > 1.0 and current_leverage != leverage:
                    # ì—´ë¦° ì£¼ë¬¸ì´ ìˆëŠ”ì§€ í™•ì¸
                    try:
                        cancel_response = await trading_service.cancel_all_open_orders(exchange= okx_instance, symbol = symbol, user_id  = user_id)
                        if cancel_response:
                            print("ë ˆë²„ë¦¬ì§€ ë³€ê²½ ì „ ì£¼ë¬¸ ì·¨ì†Œ ì„±ê³µ")
                    except Exception as e:
                        traceback.print_exc()
                        logger.error(f"ë ˆë²„ë¦¬ì§€ ë³€ê²½ ì „ ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨: {str(e)}")
                        await send_telegram_message(f"âš ï¸ ë ˆë²„ë¦¬ì§€ ë³€ê²½ ì „ ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨: {str(e)}", user_id)
                
                # ë ˆë²„ë¦¬ì§€ ì„¤ì • ì‹œë„
                try:
                    if is_hedge_mode:
                        for pos_side in ['long', 'short']:
                            await okx_instance.set_leverage(leverage, symbol, {
                            'marginMode': 'cross',
                            'posSide': pos_side
                        })
                            print("ë ˆë²„ë¦¬ì§€ ì„¤ì • ì„±ê³µ")
                            await asyncio.sleep(0.5)
                    else:
                        await okx_instance.set_leverage(leverage, symbol, {
                            'marginMode': 'cross'
                        })
                        print("ë ˆë²„ë¦¬ì§€ ì„¤ì • ì„±ê³µ")
                        await asyncio.sleep(0.5)  # API ë ˆì´íŠ¸ ë¦¬ë°‹ ê³ ë ¤
                except Exception as e:
                    if "59000" in str(e):  # ì—´ë¦° ì£¼ë¬¸ì´ë‚˜ í¬ì§€ì…˜ì´ ìˆëŠ” ê²½ìš°
                        logger.warning("í¬ì§€ì…˜ì´ ìˆì–´ ë ˆë²„ë¦¬ì§€ ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.")
                        #traceback.print_exc()
                        await send_telegram_message(
                            f"âš ï¸ í¬ì§€ì…˜ í˜¹ì€ ì—´ë¦° ì£¼ë¬¸ì´ ìˆì–´ ë ˆë²„ë¦¬ì§€ ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.\n"
                            "ë ˆë²„ë¦¬ì§€ ë³€ê²½ì„ ì§ì ‘ ì§„í–‰í•´ì£¼ì„¸ìš”.",
                            user_id
                        )
                    else:
                        raise e
            except Exception as e:
                logger.error(f"ë ˆë²„ë¦¬ì§€ ì„¤ì • ì˜¤ë¥˜: {str(e)}")
                await send_telegram_message(
                    f"âš ï¸ ë ˆë²„ë¦¬ì§€ ì„¤ì • ì‹¤íŒ¨\n"
                    f"ì—ëŸ¬: {str(e)}\n"
                    f"í•„ìš”í•œ ê²½ìš° ì§ì ‘ ë³€ê²½í•´ì£¼ì„¸ìš”.",
                    user_id
                )
        if is_running:
            # ì„¤ì • ì—…ë°ì´íŠ¸
            #print("ì„¤ì • ì—…ë°ì´íŠ¸ í˜¸ì¶œ")
            current_price = await get_current_price(symbol, timeframe)
            settings_str = await redis_client.get(f"user:{user_id}:settings")
            candle_key = f"candles_with_indicators:{symbol}:{timeframe}"
            raw_data = await redis_client.lindex(candle_key, -1)
            if not raw_data:
                await send_telegram_message("âš ï¸ ìº”ë“¤ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", user_id)
                return
            candle_data = json.loads(raw_data)
            #print("atr_value: ", atr_value)
            if settings_str:
                try:
                    user_settings = json.loads(settings_str)
                except json.JSONDecodeError:
                    logger.error(f"ì„¤ì • ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨: user_id={user_id}")
                    return
            else:
                logger.error(f"ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: user_id={user_id}")
                return
            #print("ì„¤ì • ì—…ë°ì´íŠ¸ ì™„ë£Œ")
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                await send_telegram_message(
                    "ğŸ›‘ íŠ¸ë ˆì´ë”© ì¤‘ì§€\n"
                    "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                    "íŠ¸ë ˆì´ë”©ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.",
                    user_id
                )
                return
            #=======================================
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                print(f"[{user_id}] íŠ¸ë ˆì´ë”© ì¤‘ì§€ ìƒíƒœ: {trading_status}")
            #=======================================
            # --- (1) ì£¼ë¬¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§(í´ë§) ---
            try:
                start_time = datetime.now()
                #print("=====================================")
                #print("ì£¼ë¬¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§ í˜¸ì¶œ")
                await trading_service.monitor_orders(user_id)
                end_time = datetime.now()
                #print("ì£¼ë¬¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì™„ë£Œ ì‹œê°„ : ", end_time.strftime('%Y-%m-%d %H:%M:%S'))
                #print("ì£¼ë¬¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì†Œìš” ì‹œê°„ : ", end_time - start_time)
                #print("=====================================")
            except Exception as e:
                error_logger.error(f"[{user_id}]:monitor_orders ì—ëŸ¬", exc_info=True)

            # --- (2) RSI / íŠ¸ëœë“œ ë¶„ì„ ---
            trend_analysis_start = datetime.now()
            tf_str = tf_mapping.get(timeframe, "1m")
            redis_key = f"candles_with_indicators:{symbol}:{tf_str}"
            raw_data = await redis_client.lindex(redis_key, -1)
            if not raw_data:
                await send_telegram_message("âš ï¸ ìº”ë“¤ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", user_id)
                return
            #=======================================
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                print(f"[{user_id}] íŠ¸ë ˆì´ë”© ì¤‘ì§€ ìƒíƒœ: {trading_status}")
            #=======================================
            candle_data = json.loads(raw_data)
            current_rsi = candle_data['rsi']
            #print("current_rsi: ", current_rsi)
            trend_timeframe = user_settings['trend_timeframe']
            if trend_timeframe is None:
                trend_timeframe = str(timeframe)
            trend_timeframe_str = tf_mapping.get(trend_timeframe, "1m")
            rsi_signals = await trading_service.check_rsi_signals(
                current_rsi,
                {
                    'rsi_oversold': user_settings['rsi_oversold'],
                    'rsi_overbought': user_settings['rsi_overbought']
                }
            )
            #print("rsi_signals: ", rsi_signals)
            analysis = await calculator.analyze_market_state_from_redis(symbol, str(timeframe), trend_timeframe_str)
            current_state = analysis['extreme_state']
            trend_analysis_end = datetime.now() 
            #print("=====================================")
            #print("anaylsisê¹Œì§€ ì™„ë£Œ ì‹œê°„ : ", datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
            #print("íŠ¸ëœë“œ ë¶„ì„ ì†Œìš” ì‹œê°„ : ", trend_analysis_end - trend_analysis_start)
            #print("=====================================")
            # --- (3) í¬ì§€ì…˜ ë¶„ê¸° ---
            current_position = await trading_service.get_current_position(user_id, symbol)
            
            if current_position:  # í¬ì§€ì…˜ì´ ìˆëŠ” ê²½ìš°
                try:
                    min_size_key = f"user:{user_id}:position:{symbol}:min_sustain_contract_size"
                    min_sustain_contract_size = await redis_client.get(min_size_key)
            
                    if min_sustain_contract_size:  # min_sizeê°€ Redisì— ì €ì¥ë˜ì–´ ìˆëŠ” ê²½ìš°ë§Œ ì²´í¬
                        min_sustain_contract_size = max(float(min_sustain_contract_size), 0.05)
                        current_contracts_amount = float(current_position.contracts_amount)
                        #print("================================================")
                        #print(f"í¬ì§€ì…˜ ê³„ì•½ ìˆ˜: {current_contracts_amount}, ìµœì†Œ ê³„ì•½ ìˆ˜: {min_sustain_contract_size}")
                        #print("contracts_amountë¡œ ì €ì¥ëœ í¬ì§€ì…˜ ê³„ì•½ ìˆ˜: ", current_position.contracts_amount)
                        #print("================================================")

                        if current_contracts_amount <= min_sustain_contract_size:
                            print(f"í¬ì§€ì…˜ í¬ê¸°({current_contracts_amount})ê°€ ìµœì†Œ í¬ê¸°({min_sustain_contract_size})ë³´ë‹¤ ì‘ì•„ ì²­ì‚° ì§„í–‰")
                            await trading_service.close_position(
                                user_id=user_id,
                                symbol=symbol,
                                percent=100,
                                comment="ìµœì†Œ ìˆ˜ëŸ‰ ë¯¸ë§Œ í¬ì§€ì…˜ ì²­ì‚°",
                                side=current_position.side
                            )
                            current_position = None
                except Exception as e:  
                    traceback.print_exc()
                    logger.error(f"[{user_id}]:í¬ì§€ì…˜ ì²­ì‚° ì˜¤ë¥˜", exc_info=True)
                    await send_telegram_message(f"âš ï¸ í¬ì§€ì…˜ ì²­ì‚° ì˜¤ë¥˜: {str(e)}", user_id, debug=True)
            # ë§ˆì§€ë§‰ í¬ì§€ì…˜ ì¶œë ¥ ì‹œê°„ ì²´í¬
            last_print_key = f"user:{user_id}:last_position_print_time"
            last_print_time = await redis_client.get(last_print_key)
            current_time = int(time.time())
            
            if not last_print_time or (current_time - int(last_print_time)) >= 300:  # 300ì´ˆ = 5ë¶„
                print("Current Position : ", current_position)
                await redis_client.set(last_print_key, str(current_time))
            
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            if trading_status != "running":
                print("ğŸ’štrading_status2: ", trading_status)
            if not current_position:
                print("í¬ì§€ì…˜ì´ ì—†ë‹¤ê³  ì¶œë ¥ ë¨.")
                await handle_no_position(
                    user_id, user_settings, trading_service, calculator,
                    symbol, timeframe,
                    current_rsi, rsi_signals, current_state
                )
                trading_status = await redis_client.get(f"user:{user_id}:trading:status")
                if trading_status != "running":
                    print("ğŸ’štrading_status4: ", trading_status)
            else:
                try:
                    #print("í¬ì§€ì…˜ì´ ìˆë‹¤ê³  ì¶œë ¥ ë¨.")
                    main_position_direction_key = f"user:{user_id}:position:{symbol}:main_position_direction"
                    direction = await redis_client.get(main_position_direction_key)
                    if direction is None:
                        direction = "any"
                    await handle_existing_position(
                        user_id, user_settings, trading_service, calculator,
                        symbol, timeframe,
                        current_position, current_rsi, rsi_signals, current_state, side = direction
                    )
                    trading_status = await redis_client.get(f"user:{user_id}:trading:status")
                    if trading_status != "running":
                        print("ğŸ’štrading_status3: ", trading_status)
                except Exception as e:
                    error_logger.error(f"[{user_id}]:í¬ì§€ì…˜ ì²˜ë¦¬ ì˜¤ë¥˜", exc_info=True)
                    await send_telegram_message(f"âš ï¸ í¬ì§€ì…˜ ì²˜ë¦¬ ì˜¤ë¥˜: {str(e)}", user_id)
            logger.info(f"[{user_id}] íŠ¸ë ˆì´ë”© ë¡œì§ ë£¨í”„ ì™„ë£Œ. í˜„ì¬ RSI: {current_rsi}, í˜„ì¬ ìƒíƒœ: {current_state}") # ë””ë²„ê¹…ìš©

            #=======================================
            trading_status = await redis_client.get(f"user:{user_id}:trading:status")
            #print("ğŸ§¡trading_status1: ", trading_status)
            #=======================================
        print(f"[{user_id}] ë£¨í”„ ë. ì‹œê°„ : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    except Exception as e:
        error_logger.error(f"[{user_id}]:execute_trading_logic ì˜¤ë¥˜", exc_info=True)
        await send_telegram_message(f"[{user_id}]ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”", user_id)
        await send_telegram_message(f"[{user_id}]ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”: {str(e)}", user_id, debug=True)
        traceback.print_exc()

    finally:
        if await redis_client.get(f"user:{user_id}:trading:status") == "stopped":
            if trading_service:
                try:
                    await trading_service.close()
                except Exception as e:
                    logger.error(f"íŠ¸ë ˆì´ë”© ì„œë¹„ìŠ¤ ì¢…ë£Œ ì˜¤ë¥˜: {str(e)}")
            await send_telegram_message("íŠ¸ë ˆì´ë”©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", user_id)
            logger.info(f"[{user_id}] íŠ¸ë ˆì´ë”©ì´ 'stopped' ìƒíƒœì´ë¯€ë¡œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        else:
            # í˜„ì¬ íŠ¸ë ˆì´ë”© ìƒíƒœê°€ "running"ì¸ ê²½ìš°ì—ë§Œ ë¡œê¹…
            curr_status = await redis_client.get(f"user:{user_id}:trading:status")
            if curr_status == "running":
                logger.info(f"[{user_id}] íŠ¸ë ˆì´ë”© ë¡œì§ ì‹¤í–‰ ì¢…ë£Œ. ë‹¤ìŒ ì‚¬ì´í´ì„ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.")
            
            # í˜„ì¬ trading_service ì •ë¦¬
            if trading_service:
                try:
                    await trading_service.close()
                except Exception as e:
                    logger.error(f"íŠ¸ë ˆì´ë”© ì„œë¹„ìŠ¤ ì •ë¦¬ ì˜¤ë¥˜: {str(e)}")
                    
        # ìƒíƒœê°€ "stopped"ë¡œ ë³€ê²½ë˜ì§€ ì•Šë„ë¡ ë³´ì¥
        # ì´ ë¶€ë¶„ì„ ì œê±°í•˜ì—¬ íŠ¸ë ˆì´ë”©ì´ ê³„ì† ì§„í–‰ë˜ë„ë¡ í•¨


# ======== (D) ì‹¤ì œ ì‹¤í–‰ ì˜ˆì‹œ ========
async def main():
    test_user_id = 1709556958
    
    await execute_trading_logic(test_user_id,  restart = True)

if __name__ == "__main__":
    asyncio.run(main())