#src/api/routes/account.py

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel
from typing import List, Optional
import logging

from datetime import datetime, timedelta, date
from HYPERRSI.src.api.dependencies import get_exchange_client
from contextlib import asynccontextmanager
import ccxt.async_support as ccxt

import os
import time
import hmac

from fastapi import APIRouter, HTTPException




import json
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/account", tags=["Account Management"])


SYMBOL_INFO_PREFIX = "symbol_info:"


@asynccontextmanager
async def get_exchange_context(user_id: str):
    """컨텍스트 매니저로 exchange client 관리"""
    exchange = await get_exchange_client(user_id)
    try:
        yield exchange
    finally:
        print("Closing exchange client...!")
        await exchange.close()


class Position(BaseModel):
    """
    단일 포지션 정보를 담는 모델
    """
    instrument: str           # instId
    size: float               # pos
    side: str                 # posSide
    entry_price: float        # avgPx
    mark_price: float         # markPx
    unrealized_pnl: float     # upl
    margin_ratio: float       # mgnRatio
    leverage: float           # lever
    liquidation_price: float  # liqPx
    margin: float             # imr
    

class Balance(BaseModel):
    """
    사용자 계정의 잔고 정보 모델
    """
    total_equity: float
    available_margin: float
    used_margin: float
    currency: str
    margin_ratio: float
    update_time: datetime
    positions: List[Position]


class SimplePosition(BaseModel):
    """간소화된 포지션 정보 모델"""
    symbol: str                # 거래 심볼 (예: XRP-USDT-SWAP)
    direction: str            # 'long' 또는 'short'
    size: float               # 포지션 크기(qty형식)
    entry_price: float        # 진입가
    mark_price: float         # 현재가
    unrealized_pnl: float     # 미실현 손익
    leverage: float             # 레버리지
    margin: float             # 사용 중인 증거금
    liquidation_price: float  # 청산가

class PositionsResponse(BaseModel):
    """
    복수 포지션 정보를 요약해 응답하는 모델
    """
    positions: List[SimplePosition]
    total_unrealized_pnl: float
    update_time: datetime



class TradeHistory(BaseModel):
    timestamp: str
    side: str
    size: float
    entry_price: float
    exit_price: float
    pnl: float
    pnl_percent: float
    
    model_config = {
        "json_schema_extra": {
            "examples": [{
                "timestamp": "2024-03-15 10:30:00",
                "side": "long",
                "size": 0.01,
                "entry_price": 50000.0,
                "exit_price": 51000.0,
                "pnl": 10.0,
                "pnl_percent": 2.0
            }]
        }
    }

class TradeVolume(BaseModel):
    """거래량 정보 모델"""
    total_volume: float
    total_fee: float
    currency: str
    start_date: str
    end_date: str
    total_contracts: float
    
    model_config = {
        "json_schema_extra": {
            "examples": [{
                "total_volume": 1000.0,
                "total_fee": 2.5,
                "currency": "USDT",
                "start_date": "2024-05-01",
                "end_date": "2024-05-31",
                "total_contracts": 0.1
            }]
        }
    }

# --- 헬퍼 함수: Redis 키 생성 ---
def get_redis_keys(user_id: str):
    return {
        'history': f"user:{user_id}:trade_history",
        'api_keys': f"user:{user_id}:api:keys"
    }



router = APIRouter(prefix="/account", tags=["Account Management"])

# 환경 변수나 별도의 설정 파일에서 가져오는 방식을 권장합니다.
from HYPERRSI.src.config import OKX_API_KEY as API_KEY, OKX_SECRET_KEY as API_SECRET, OKX_PASSPHRASE as API_PASSPHRASE

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error

BASE_URL = "https://www.okx.com"


async def update_contract_specifications(user_id: str):
    """
    계약 사양을 업데이트하는 헬퍼 함수
    마지막 업데이트가 24시간 이전이면 새로 조회합니다
    """
    try:
        # 마지막 업데이트 시간 확인
        last_update = await _get_redis_client().get("symbol_info:contract_specs_last_update")
        current_time = int(time.time())
        
        if not last_update or (current_time - int(last_update)) > 86400:
            async with get_exchange_context(user_id) as exchange:
                response = await exchange.publicGetPublicInstruments(params={'instType': 'SWAP'})
                
                # 모든 계약 사양 저장
                specs_dict = {}
                for instrument in response['data']:
                    specs_dict[instrument['instId']] = {
                        'contractSize': float(instrument['ctVal']),
                        'tickSize': float(instrument['tickSz']),
                        'minSize': float(instrument['minSz']),
                        'ctType': instrument['ctType'],
                        'quoteCcy': instrument['quoteCcy'],
                        'baseCcy': instrument['baseCcy'],
                        'settleCcy': instrument['settleCcy'],
                        'maxLeverage': float(instrument.get('maxLever', '100')),
                        'update_time': current_time
                    }
                
                # Redis에 저장 (만료시간 없이)
                await _get_redis_client().set("symbol_info:contract_specifications", json.dumps(specs_dict))
                await _get_redis_client().set("symbol_info:contract_specs_last_update", str(current_time))
                
                return specs_dict
        
        # 기존 데이터 반환
        specs = await _get_redis_client().get("symbol_info:contract_specifications")
        return json.loads(specs) if specs else {}
        
    except Exception as e:
        logger.error(f"Failed to update contract specifications: {str(e)}", exc_info=True)
        return {}

@router.get(
    "/contract-specs",
    summary="계약 사양 조회",
    description="모든 선물 계약의 사양(계약 크기 등)을 조회합니다. 24시간마다 자동 업데이트됩니다.",
)
async def get_contract_specifications(
    user_id: str = Query(..., description="사용자 ID(문자열)"),
    force_update: bool = Query(False, description="강제 업데이트 여부")
):
    """
    계약 사양 조회 API
    - 마지막 업데이트가 24시간 이전이면 자동으로 새로 조회
    - force_update=true로 요청하면 강제로 새로 조회
    """
    try:
        if force_update:
            # Redis 데이터 삭제 후 새로 조회
            await _get_redis_client().delete("symbol_info:contract_specifications")
            await _get_redis_client().delete("symbol_info:contract_specs_last_update")
            
        specs_dict = await update_contract_specifications(user_id)
        return {
            "success": True,
            "data": specs_dict,
            "last_update": await _get_redis_client().get("symbol_info:contract_specs_last_update")
        }
    
    except Exception as e:
        logger.error(f"Failed to fetch contract specifications: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail="계약 사양 조회 중 오류가 발생했습니다"
        )


@router.get(
    "/balance",
    response_model=Balance,
    summary="사용자 잔고 조회",
    description="현재 사용자 계정의 잔고(총자산, 가용 마진, 사용 중인 마진, 마진 비율)와 보유 포지션을 조회합니다.",
    responses={
        200: {
            "description": "성공적으로 잔고 정보를 조회했습니다.",
            "content": {
                "application/json": {
                    "example": {
                        "total_equity": 1000.0,
                        "available_margin": 900.0,
                        "used_margin": 100.0,
                        "currency": "USDT",
                        "margin_ratio": 0.1,
                        "update_time": "2025-01-01T12:00:00Z",
                        "positions": [
                            {
                                "instrument": "BTC-USDT-SWAP",
                                "size": 0.001,
                                "side": "long",
                                "entry_price": 30000.0,
                                "mark_price": 31000.0,
                                "unrealized_pnl": 10.0,
                                "margin_ratio": 0.02,
                                "leverage": 10.0,
                                "liquidation_price": 25000.0,
                                "margin": 30.0,
                            }
                        ]
                    }
                }
            },
        },
        400: {
            "description": "잘못된 요청(거래소 오류 등)",
        },
        401: {
            "description": "인증 오류(각종 Key 문제)",
        },
        503: {
            "description": "거래소 연결 오류",
        },
        500: {
            "description": "잔고 조회 중 서버 오류",
        },
    }
)
async def get_balance(
    user_id: str = Query(..., description="사용자 ID(문자열)")
):
    """
    # 사용자 잔고 및 포지션 조회 API

    - **user_id**: 사용자 식별자
    - **반환 정보**:
        - `total_equity`: 총자산
        - `available_margin`: 가용 마진
        - `used_margin`: 사용 중인 마진
        - `currency`: 기축통화 (예: USDT)
        - `margin_ratio`: 마진 비율
        - `update_time`: 조회 시점의 UTC 시간
        - `positions`: 현재 보유 중인 선물 포지션 목록
    """
    start_time = time.time()
    async with get_exchange_context(user_id) as exchange:
        try:
            balance = await exchange.fetch_balance()
 
            positions_response = await exchange.private_get_account_positions({'instType': 'SWAP'})
            # USDT 잔고 정보
            usdt_details = next(
                (detail for detail in balance['info']['data'][0]['details'] 
                 if detail['ccy'] == 'USDT'), {}
            )
            specs_dict = await update_contract_specifications(user_id)
            end_time = time.time()
            print(f"get_balance2 소요시간: {end_time - start_time}초")
            print("================================================")
            # 포지션 정보 파싱
            def safe_float(value, default=0.0):
                try:
                    if value is None or value == '':
                        return default
                    return float(value)
                except (ValueError, TypeError):
                    return default
            positions = []
            if positions_response.get('data'):
                for pos in positions_response['data']:
                    if safe_float(pos.get('pos', 0)) != 0:  # 실제 포지션이 있는 경우만
                        contract_spec = specs_dict.get(pos['instId'], {})
                        contract_size = contract_spec.get('contractSize', 1)
                        positions.append(Position(
                            instrument=pos['instId'],
                            size=safe_float(pos['pos']) * contract_size,
                            side=pos['posSide'],
                            entry_price=safe_float(pos['avgPx']),
                            mark_price=safe_float(pos['markPx']),
                            unrealized_pnl=safe_float(pos['upl']),
                            margin_ratio=safe_float(pos['mgnRatio']),
                            leverage=safe_float(pos['lever']),
                            liquidation_price=safe_float(pos['liqPx']),
                            margin=safe_float(pos['imr'])
                        ))
            end_time = time.time()
            print("================================================")
            print(f"get_balance3 소요시간: {end_time - start_time}초")
            print("================================================")

            return Balance(
                total_equity=safe_float(usdt_details.get('eq', 0)),
                available_margin=safe_float(usdt_details.get('availEq', 0)),
                used_margin=safe_float(usdt_details.get('imr', 0)),
                currency='USDT',
                margin_ratio = safe_float(usdt_details.get('mgnRatio', '0') or '0'),
                update_time=datetime.utcnow(),
                positions=positions
            )
            
        except HTTPException as e:
            # API 키가 없는 경우 적절한 에러 반환
            if e.status_code == 404 and "API keys not found" in str(e.detail):
                logger.info(f"사용자 {user_id}의 API 키가 등록되지 않음")
                raise HTTPException(
                    status_code=404,
                    detail="API 키가 등록되지 않았습니다. API 키를 먼저 등록해주세요."
                )
            raise e
        except Exception as e:
            logger.error(f"Failed to fetch balance for user {user_id}: {str(e)}", exc_info=True)
            if isinstance(e, ccxt.NetworkError):
                raise HTTPException(status_code=503, detail="거래소 연결 오류가 발생했습니다")
            elif isinstance(e, ccxt.AuthenticationError):
                raise HTTPException(status_code=401, detail="인증 오류가 발생했습니다")
            elif isinstance(e, ccxt.ExchangeError):
                raise HTTPException(status_code=400, detail=f"거래소 오류: {str(e)}")
            else:
                raise HTTPException(status_code=500, detail="잔고 조회 중 오류가 발생했습니다")
        

@router.get(
    "/positions",
    summary="현재 보유 포지션(원본) 조회",
    description="현재 보유 중인 포지션 목록을 raw 데이터 형태로 조회합니다. ccxt의 fetch_positions() 응답 그대로 반환합니다.",
    responses={
        200: {
            "description": "성공적으로 포지션 정보를 조회했습니다."
        },
        500: {
            "description": "포지션 조회 중 서버 오류",
        },
    }
)
async def get_positions(
    user_id: str = Query(..., description="사용자 ID(문자열)")
):
    """
    # 사용자의 모든 포지션(raw) 조회 API

    이 엔드포인트는 fetch_positions()로부터 받은 **원본 포지션 데이터**를 반환합니다.
    """
    async with get_exchange_context(user_id) as exchange:
        try:
            positions = await exchange.fetch_positions()
            return positions
        except Exception as e:
            logger.error(f"Failed to fetch positions: {str(e)}", exc_info=True)
            raise HTTPException(status_code=500, detail=str(e))


@router.get(
    "/history",
    response_model=List[TradeHistory],
    summary="거래 내역 조회",
    description="특정 사용자 ID의 최근 10개 거래 내역을 조회합니다. 실시간 거래소 데이터와 함께 제공됩니다.",
    responses={
        200: {
            "description": "성공적으로 거래 내역을 조회했습니다.",
            "content": {
                "application/json": {
                    "examples": [{
                        "timestamp": "2024-03-15 10:30:00",
                        "symbol": "BTC-USDT-SWAP",
                        "side": "long",
                        "size": 0.01,
                        "leverage": 10,
                        "entry_price": 50000.0,
                        "exit_price": 51000.0,
                        "pnl": 10.0,
                        "pnl_percent": 2.0,
                        "status": "closed",
                        "close_type": "TP",
                        "fee": {"cost": 0.1, "currency": "USDT"}
                    }]
                }
            }
        },
        400: {"description": "등록되지 않은 사용자 (API 키 없음)"},
        500: {"description": "거래 내역 조회 중 서버 오류"},
    }
)
async def get_history(
    user_id: str = Query(..., description="사용자 ID(문자열). 예 : 1709556985"),
    limit: int = Query(10, description="조회할 거래 내역 수"),
    
):
    """
    사용자의 거래 내역을 조회하고 실시간 정보로 업데이트합니다.
    
    - 거래소에서 실시간 주문 상태 확인
    - PNL 및 수수료 정보 포함
    - 청산 유형(TP/SL/Manual) 구분
    """
    keys = get_redis_keys(user_id)
    api_keys = await _get_redis_client().hgetall(keys['api_keys'])
    
    if not api_keys:
        raise HTTPException(status_code=400, detail="등록되지 않은 사용자입니다.")
        
    try:
        async with get_exchange_context(str(user_id)) as exchange:
            history_list = await _get_redis_client().lrange(keys['history'], 0, limit - 1)
            if not history_list:
                return []
                
            results = []
            for trade_data in history_list:
                trade_info = json.loads(trade_data)
                
                # 주문 상태 업데이트
                if trade_info.get('order_id') and trade_info.get('symbol'):
                    try:
                        print("fetch_order 호출", trade_info['order_id'], trade_info['symbol'])
                        order = await exchange.fetch_order(
                            trade_info['order_id'], 
                            trade_info['symbol']
                        )
                        
                        if order['status'] in ['closed', 'canceled', 'expired']:
                            # 체결 정보 업데이트
                            trade_info['status'] = 'closed'
                            trade_info['exit_price'] = float(order['average']) if order.get('average') else float(order['price'])
                            trade_info['exit_timestamp'] = datetime.fromtimestamp(
                                order.get('lastTradeTimestamp', order['timestamp']) / 1000
                            ).strftime('%Y-%m-%d %H:%M:%S')
                            
                            # PNL 계산
                            entry_price = float(trade_info['entry_price'])
                            exit_price = float(trade_info['exit_price'])
                            size = float(trade_info['size'])
                            is_long = trade_info['side'] == 'long'
                            
                            if entry_price > 0 and size > 0:
                                pnl = (exit_price - entry_price) * size if is_long else (entry_price - exit_price) * size
                                trade_info['pnl'] = pnl
                                trade_info['pnl_percent'] = (pnl / (entry_price * size)) * 100
                            
                            # 수수료 정보
                            if order.get('fee'):
                                trade_info['fee'] = {
                                    'cost': float(order['fee']['cost']),
                                    'currency': order['fee']['currency']
                                }
                            
                            # 청산 유형 확인
                            info = order.get('info', {})
                            if info.get('tpTriggerPx'):
                                trade_info['close_type'] = 'TP'
                            elif info.get('slTriggerPx'):
                                trade_info['close_type'] = 'SL'
                            else:
                                trade_info['close_type'] = 'Manual'
                            
                            # Redis 업데이트
                            await _get_redis_client().lset(
                                keys['history'],
                                history_list.index(trade_data),
                                json.dumps(trade_info)
                            )
                            
                    except Exception as e:
                        logger.error(f"주문 정보 업데이트 실패 - order_id: {trade_info.get('order_id')}, error: {str(e)}")
                
                results.append(TradeHistory(**trade_info))
                
            return results
            
    except Exception as e:
        logger.error(f"[get_history] Error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="거래 내역 조회 중 오류가 발생했습니다.")
                            
@router.get(
    "/positions/summary",
    response_model=PositionsResponse,
    summary="활성 포지션 요약 조회",
    description="현재 보유 중인 선물 포지션의 요약 정보를 조회합니다. 사용자마다 instId, 포지션 방향, 미실현손익 등을 반환합니다.",
    responses={
        200: {
            "description": "성공적으로 포지션 요약을 조회했습니다.",
            "content": {
                "application/json": {
                    "example": {
                        "positions": [
                            {
                                "symbol": "XRP-USDT-SWAP",
                                "direction": "long",
                                "size": 100.0,
                                "entry_price": 0.5,
                                "mark_price": 0.51,
                                "unrealized_pnl": 1.0,
                                "leverage": 10,
                                "margin": 5.0,
                                "liquidation_price": 0.4
                            }
                        ],
                        "total_unrealized_pnl": 1.0,
                        "update_time": "2025-01-01T12:00:00Z"
                    }
                }
            },
        },
        400: {
            "description": "거래소 오류",
        },
        401: {
            "description": "인증 오류",
        },
        503: {
            "description": "거래소 연결 오류",
        },
        500: {
            "description": "포지션 조회 중 서버 오류",
        },
    }
)
async def get_positions_summary(
    user_id: str = Query(..., description="사용자 ID(문자열)")
):
    """
    # 활성 포지션 요약 조회 API

    - **user_id**: 사용자 식별자
    - **반환 정보**: 
        - `positions`: 활성화된 선물 포지션 목록(간소화된 형태)
        - `total_unrealized_pnl`: 모든 포지션의 미실현 손익 합계
        - `update_time`: 조회 시점의 UTC 시간
    """
    async with get_exchange_context(user_id) as exchange:
        try:
            positions_data = await exchange.private_get_account_positions({'instType': 'SWAP'})
            specs_dict = await update_contract_specifications(user_id)
            positions = []
            total_pnl = 0.0
            
            # safe_float 함수 정의 (get_balance와 동일한 함수 사용)
            def safe_float(value, default=0.0):
                try:
                    if value is None or value == '':
                        return default
                    return float(value)
                except (ValueError, TypeError):
                    return default
            
            for pos in positions_data.get('data', []):
                if safe_float(pos.get('pos', 0)) != 0:  # 실제 포지션이 있는 경우만
                    contract_spec = specs_dict.get(pos['instId'], {})
                    contract_size = contract_spec.get('contractSize', 1)
                    position_qty = safe_float(pos['pos']) * contract_size
                    
                    positions.append(SimplePosition(
                        symbol=pos['instId'],
                        direction='long' if safe_float(pos['pos']) > 0 else 'short',
                        size=abs(position_qty),
                        entry_price=safe_float(pos['avgPx']),
                        mark_price=safe_float(pos['markPx']),
                        unrealized_pnl=safe_float(pos['upl']),
                        leverage=int(safe_float(pos['lever'])),
                        margin=safe_float(pos['imr']),
                        liquidation_price=safe_float(pos['liqPx'])
                    ))
                    total_pnl += safe_float(pos['upl'])

            return PositionsResponse(
                positions=positions,
                total_unrealized_pnl=total_pnl,
                update_time=datetime.utcnow()
            )

        except Exception as e:
            logger.error(f"Failed to fetch positions for user {user_id}: {str(e)}", exc_info=True)
            if isinstance(e, ccxt.NetworkError):
                raise HTTPException(status_code=503, detail="거래소 연결 오류가 발생했습니다")
            elif isinstance(e, ccxt.AuthenticationError):
                raise HTTPException(status_code=401, detail="인증 오류가 발생했습니다")
            elif isinstance(e, ccxt.ExchangeError):
                raise HTTPException(status_code=400, detail=f"거래소 오류: {str(e)}")
            else:
                raise HTTPException(status_code=500, detail="포지션 조회 중 오류가 발생했습니다")

@router.get(
    "/volume/month",
    response_model=TradeVolume,
    summary="이번달 거래량 조회",
    description="사용자의 이번달 총 거래량(거래금액)과 수수료를 조회합니다. bills API를 사용합니다.",
    responses={
        200: {
            "description": "성공적으로 거래량 정보를 조회했습니다.",
            "content": {
                "application/json": {
                    "example": {
                        "total_volume": 1000.0,
                        "total_fee": 2.5,
                        "currency": "USDT",
                        "start_date": "2024-05-01",
                        "end_date": "2024-05-31",
                        "total_contracts": 0.1
                    }
                }
            }
        },
        400: {"description": "거래소 오류"},
        401: {"description": "인증 오류"},
        503: {"description": "거래소 연결 오류"},
        500: {"description": "거래량 조회 중 서버 오류"}
    }
)
async def get_monthly_volume(
    user_id: str = Query(..., description="사용자 ID(문자열)")
):
    """
    # 이번달 거래량 조회 API
    
    - **user_id**: 사용자 식별자
    - **반환 정보**:
        - `total_volume`: 이번달 총 거래량 (거래금액, USDT 기준)
        - `total_fee`: 이번달 총 수수료
        - `currency`: 기축통화 (예: USDT)
        - `start_date`: 조회 시작일 (이번달 1일)
        - `end_date`: 조회 종료일 (오늘)
        - `total_contracts`: 이번달 총 계약 수량
    """
    async with get_exchange_context(user_id) as exchange:
        try:
            # 이번달 시작일과 종료일 설정
            today = date.today()
            start_date = date(today.year, today.month, 1)
            end_date = today
            
            # 시작일과 종료일을 ISO 형식으로 변환
            start_ts = int(datetime.combine(start_date, datetime.min.time()).timestamp() * 1000)
            end_ts = int(datetime.combine(end_date, datetime.max.time()).timestamp() * 1000)
            
            # OKX API 매개변수 설정
            params = {
                'instType': 'SWAP',  # 선물만 조회
                'begin': start_ts,
                'end': end_ts
            }
            
            # 거래 내역 조회
            bills = await exchange.private_get_account_bills(params)
            print(bills)
            total_volume = 0.0
            total_fee = 0.0
            total_contracts = 0.0
            
            if bills.get('data'):
                for bill in bills['data']:
                    # OKX에서 거래 타입은 '2'이며, subType으로 거래 종류가 구분됨
                    if bill.get('type') == '2' and bill.get('subType') in ['3', '4', '5', '6']:
                        # 거래량 합산
                        if bill.get('sz') and bill.get('px'):
                            size = abs(float(bill['sz']))
                            price = float(bill['px'])
                            total_volume += size * price
                            total_contracts += size
                        
                        # 수수료 합산 (수수료는 음수로 표시되므로 절대값 사용)
                        if bill.get('fee'):
                            total_fee += abs(float(bill['fee']))
            
            return TradeVolume(
                total_volume=total_volume,
                total_fee=total_fee,
                currency='USDT',
                start_date=start_date.strftime('%Y-%m-%d'),
                end_date=end_date.strftime('%Y-%m-%d'),
                total_contracts=total_contracts
            )
            
        except Exception as e:
            logger.error(f"Failed to fetch monthly volume for user {user_id}: {str(e)}", exc_info=True)
            if isinstance(e, ccxt.NetworkError):
                raise HTTPException(status_code=503, detail="거래소 연결 오류가 발생했습니다")
            elif isinstance(e, ccxt.AuthenticationError):
                raise HTTPException(status_code=401, detail="인증 오류가 발생했습니다")
            elif isinstance(e, ccxt.ExchangeError):
                raise HTTPException(status_code=400, detail=f"거래소 오류: {str(e)}")
            else:
                raise HTTPException(status_code=500, detail="거래량 조회 중 오류가 발생했습니다")

@router.get(
    "/volume/month/orders",
    response_model=TradeVolume,
    summary="이번달 거래량 조회 (주문 내역 기준)",
    description="사용자의 이번달 총 거래량(거래금액)과 수수료를 주문 내역 기준으로 조회합니다.",
    responses={
        200: {
            "description": "성공적으로 거래량 정보를 조회했습니다.",
            "content": {
                "application/json": {
                    "example": {
                        "total_volume": 1000.0,
                        "total_fee": 2.5,
                        "currency": "USDT",
                        "start_date": "2024-05-01",
                        "end_date": "2024-05-31",
                        "total_contracts": 0.1
                    }
                }
            }
        },
        400: {"description": "거래소 오류"},
        401: {"description": "인증 오류"},
        503: {"description": "거래소 연결 오류"},
        500: {"description": "거래량 조회 중 서버 오류"}
    }
)
async def get_monthly_volume_from_orders(
    user_id: str = Query(..., description="사용자 ID(문자열)")
):
    """
    # 이번달 거래량 조회 API (주문 내역 기준)
    
    - **user_id**: 사용자 식별자
    - **반환 정보**:
        - `total_volume`: 이번달 총 거래량 (거래금액, USDT 기준)
        - `total_fee`: 이번달 총 수수료
        - `currency`: 기축통화 (예: USDT)
        - `start_date`: 조회 시작일 (이번달 1일)
        - `end_date`: 조회 종료일 (오늘)
        - `total_contracts`: 이번달 총 계약 수량
    """
    async with get_exchange_context(user_id) as exchange:
        try:
            # 이번달 시작일과 종료일 설정
            today = date.today()
            start_date = date(today.year, today.month, 1)
            end_date = today
            
            # 시작일과 종료일을 ISO 형식으로 변환
            start_ts = int(datetime.combine(start_date, datetime.min.time()).timestamp() * 1000)
            end_ts = int(datetime.combine(end_date, datetime.max.time()).timestamp() * 1000)
            
            # 주문 내역 조회 API 매개변수 설정
            params = {
                'instType': 'SWAP',  # 선물만 조회
                'begin': start_ts,
                'end': end_ts,
                'state': 'filled'    # 체결된 주문만 조회
            }
            
            # 주문 내역 조회 (최근 주문부터 조회)
            orders = await exchange.private_get_trade_fills(params)
            
            total_volume = 0.0
            total_fee = 0.0
            total_contracts = 0.0
            
            if orders.get('data'):
                for order in orders['data']:
                    # 실제 체결된 거래만 처리
                    if order.get('fillSz') and order.get('fillPx'):
                        size = abs(float(order['fillSz']))
                        price = float(order['fillPx'])
                        total_volume += size * price
                        total_contracts += size
                    
                    # 수수료 합산
                    if order.get('fee'):
                        total_fee += abs(float(order['fee']))
            
            return TradeVolume(
                total_volume=total_volume,
                total_fee=total_fee,
                currency='USDT',
                start_date=start_date.strftime('%Y-%m-%d'),
                end_date=end_date.strftime('%Y-%m-%d'),
                total_contracts=total_contracts
            )
            ㅋ
        except Exception as e:
            logger.error(f"Failed to fetch monthly volume from orders for user {user_id}: {str(e)}", exc_info=True)
            if isinstance(e, ccxt.NetworkError):
                raise HTTPException(status_code=503, detail="거래소 연결 오류가 발생했습니다")
            elif isinstance(e, ccxt.AuthenticationError):
                raise HTTPException(status_code=401, detail="인증 오류가 발생했습니다")
            elif isinstance(e, ccxt.ExchangeError):
                raise HTTPException(status_code=400, detail=f"거래소 오류: {str(e)}")
            else:
                raise HTTPException(status_code=500, detail="거래량 조회 중 오류가 발생했습니다")