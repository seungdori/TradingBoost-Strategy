from fastapi import APIRouter, HTTPException, Query, Request
from typing import List, Optional, Dict, Any
from pydantic import BaseModel
import asyncio
import datetime as dt
import logging
import json

from HYPERRSI.src.trading.trading_service import TradingService, get_okx_client
from shared.logging import get_logger

from HYPERRSI.src.core.celery_task import celery_app
from HYPERRSI.src.bot.telegram_message import send_telegram_message
from HYPERRSI.src.utils.check_invitee import get_okx_uid_from_telegram
from shared.helpers.user_id_converter import get_telegram_id_from_uid
from HYPERRSI.src.api.routes.settings import get_api_keys_from_timescale, ApiKeyService
from HYPERRSI.src.services.timescale_service import TimescaleUserService
from HYPERRSI.src.core.error_handler import handle_critical_error, ErrorCategory

# ë¡œê±° ì„¤ì •
logger = get_logger(__name__)

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error

router = APIRouter(prefix="/trading", tags=["trading"])

allowed_uid = ["518796558012178692", "549641376070615063", "587662504768345929", "510436564820701267"]

# okx_uidë¥¼ ì‚¬ìš©í•˜ë„ë¡ ëª¨ë¸ ë³€ê²½
class TradingTaskRequest(BaseModel):
    user_id: str
    symbol: Optional[str] = "SOL-USDT-SWAP"
    timeframe: str = "1m"

    model_config = {
        "json_schema_extra": {
            "example": {
                "user_id": "1709556958", # user_id -> okx_uid
                "symbol": "SOL-USDT-SWAP",
                "timeframe": "1m",
            }
        }
    }

@router.post("/start",
    summary="íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì‹œì‘ (OKX UID ê¸°ì¤€)",
    description="íŠ¹ì • ì‚¬ìš©ìì˜ ìë™ íŠ¸ë ˆì´ë”©ì„ ì‹œì‘í•©ë‹ˆë‹¤ (OKX UID ê¸°ì¤€).",
    responses={
        200: {
            "description": "íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì‹œì‘ ì„±ê³µ",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "message": "íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.",
                        "task_id": "abc123xyz"
                    }
                }
            }
        },
        400: {"description": "íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì‹œì‘ ì‹¤íŒ¨"}
    })
async def start_trading(request: TradingTaskRequest, restart: bool = False):
    try:
        okx_uid = request.user_id # okx_uid ì‚¬ìš©
        telegram_id = None
        

        # Redis ì—°ê²° í™•ì¸
        try:
            ping_result = await asyncio.wait_for(_get_redis_client().ping(), timeout=2.0)
            if not ping_result:
                raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹¤íŒ¨")
        except asyncio.TimeoutError:
            logger.error("Redis ping timeout (2s)")
            raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹œê°„ ì´ˆê³¼")
        except Exception as redis_error:
            logger.error(f"Redis ì—°ê²° ì˜¤ë¥˜: {str(redis_error)}")
            await handle_critical_error(
                error=redis_error,
                category=ErrorCategory.REDIS_CONNECTION,
                context={"endpoint": "start_trading", "okx_uid": okx_uid},
                okx_uid=okx_uid
            )
            raise HTTPException(status_code=500, detail=f"Redis ì—°ê²° ì˜¤ë¥˜: {str(redis_error)}")

        # telegram_idì¸ì§€ okx_uidì¸ì§€ í™•ì¸
        is_telegram_id = not okx_uid.isdigit() or len(okx_uid) < 10
        telegram_id = okx_uid if is_telegram_id else None

        # telegram_idì¸ ê²½ìš° okx_uidë¡œ ë³€í™˜ ì‹œë„
        if is_telegram_id:
            okx_uid_from_telegram = await get_okx_uid_from_telegram(okx_uid)
            if okx_uid_from_telegram:
                okx_uid = okx_uid_from_telegram
                is_telegram_id = False

    
        telegram_id = await get_telegram_id_from_uid(okx_uid, TimescaleUserService)

        # API í‚¤ í™•ì¸ ë° ì—…ë°ì´íŠ¸
        api_keys = await _get_redis_client().hgetall(f"user:{okx_uid}:api:keys")
        
        # API í‚¤ê°€ ê¸°ë³¸ê°’ì¸ì§€ í™•ì¸
        is_default_api_key = False
        if api_keys:
            api_key = api_keys.get('api_key', '')
            api_secret = api_keys.get('api_secret', '')
            passphrase = api_keys.get('passphrase', '')
            
            # ê¸°ë³¸ê°’ í™•ì¸
            if api_key == "default_api_key" or api_secret == "default_api_secret" or passphrase == "default_passphrase":
                is_default_api_key = True
                logger.info(f"ì‚¬ìš©ì {okx_uid}ì˜ API í‚¤ê°€ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤. TimescaleDBì—ì„œ ì •ë³´ ì¡°íšŒë¥¼ ì‹œë„í•©ë‹ˆë‹¤.")

        # API í‚¤ê°€ ì—†ê±°ë‚˜ ê¸°ë³¸ê°’ì¸ ê²½ìš° TimescaleDBì—ì„œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        if not api_keys or is_default_api_key:
            # TimescaleDBì—ì„œ API í‚¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            timescale_api_keys = await get_api_keys_from_timescale(int(okx_uid))
            
            if timescale_api_keys:
                # TimescaleDBì—ì„œ ê°€ì ¸ì˜¨ API í‚¤ë¡œ ì‚¬ìš©ì ìƒì„±/ì—…ë°ì´íŠ¸
                await ApiKeyService.set_user_api_keys(
                    str(okx_uid), 
                    timescale_api_keys['api_key'], 
                    timescale_api_keys['api_secret'], 
                    timescale_api_keys['passphrase']
                )
                logger.info(f"ì‚¬ìš©ì {okx_uid}ì˜ API í‚¤ë¥¼ TimescaleDB ì •ë³´ë¡œ ì—…ë°ì´íŠ¸í–ˆìŠµë‹ˆë‹¤.")
        
        #if okx_uid not in allowed_uid:
        #    await send_telegram_message(f"âš ï¸[{okx_uid}] ê¶Œí•œì´ ì—†ëŠ” ì‚¬ìš©ìì…ë‹ˆë‹¤.", okx_uid, debug=True)
        #    await send_telegram_message(f"âš ï¸[{okx_uid}] ê¶Œí•œì´ ì—†ëŠ” ì‚¬ìš©ìì…ë‹ˆë‹¤. \nê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.", okx_uid)
        #    await redis_client.set(f"user:{okx_uid}:trading:status", "stopped")
        #    raise HTTPException(status_code=403, detail="ê¶Œí•œì´ ì—†ëŠ” ì‚¬ìš©ìì…ë‹ˆë‹¤.")
            
        
        # ì‹¬ë³¼ê³¼ íƒ€ì„í”„ë ˆì„ ê°€ì ¸ì˜¤ê¸°
        symbol = request.symbol
        timeframe = request.timeframe
        
        # í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ task í™•ì¸ (telegram_idì™€ okx_uid ëª¨ë‘ í™•ì¸)
        is_running = False
        telegram_status = None
        okx_status = None

        # Redis pipelineìœ¼ë¡œ ë°°ì¹˜ ì¡°íšŒ
        if telegram_id:
            telegram_status_key = f"user:{telegram_id}:trading:status"
            okx_status_key = f"user:{okx_uid}:trading:status"

            # Pipelineìœ¼ë¡œ ë‘ í‚¤ë¥¼ í•œ ë²ˆì— ì¡°íšŒ
            async with _get_redis_client().pipeline() as pipe:
                pipe.get(telegram_status_key)
                pipe.get(okx_status_key)
                results = await pipe.execute()
                telegram_status, okx_status = results
        else:
            # telegram_idê°€ ì—†ìœ¼ë©´ okx_uidë§Œ ì¡°íšŒ
            okx_status_key = f"user:{okx_uid}:trading:status"
            okx_status = await _get_redis_client().get(okx_status_key)

        # telegram_id ìƒíƒœ ì²˜ë¦¬
        if telegram_status:
            # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
            if isinstance(telegram_status, bytes):
                print(f"ì›ë³¸ telegram_statusëŠ” ë°”ì´íŠ¸ ë¬¸ìì—´ì…ë‹ˆë‹¤: {repr(telegram_status)}")
                telegram_status = telegram_status.decode('utf-8')

            # ë¬¸ìì—´ ì •ê·œí™” (ê³µë°± ì œê±° ë° ë”°ì˜´í‘œ ì œê±°)
            telegram_status = telegram_status.strip().strip('"\'')

            if telegram_status == "running":
                is_running = True
                logger.info(f"í…”ë ˆê·¸ë¨ ID {telegram_id}ì˜ íŠ¸ë ˆì´ë”©ì´ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.")

        # okx_uid ìƒíƒœ ì²˜ë¦¬
        print(f"okx_status_key: {okx_status_key}")
        print(f"okx_status: {okx_status}")
        
        # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
        if isinstance(okx_status, bytes):
            print(f"ì›ë³¸ okx_statusëŠ” ë°”ì´íŠ¸ ë¬¸ìì—´ì…ë‹ˆë‹¤: {repr(okx_status)}")
            okx_status = okx_status.decode('utf-8')
            
        # ë¬¸ìì—´ ì •ê·œí™” (ê³µë°± ì œê±° ë° ë”°ì˜´í‘œ ì œê±°)
        if okx_status:
            okx_status = okx_status.strip().strip('"\'')
            
        if okx_status == "running":
            is_running = True
            logger.info(f"OKX UID {okx_uid}ì˜ íŠ¸ë ˆì´ë”©ì´ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.")

        # ì‹¤í–‰ ì¤‘ì¸ ìƒíƒœì—ì„œ restart=Falseì´ë©´ ì˜¤ë¥˜ ë°˜í™˜ (ê¸°ì¡´ ë¡œì§ ë³µì›)
        if is_running and not restart:
            logger.warning(f"[{okx_uid}] ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ íŠ¸ë ˆì´ë”©ì´ ìˆê³  restart=Falseì„. ì‹œì‘ ê±°ë¶€.")
            raise HTTPException(status_code=400, detail="ì´ë¯¸ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.")

        # íƒœìŠ¤í¬ ID íŒŒì•… (ì¬ì‹œì‘ ì‹œì—ë§Œ í•„ìš”)
        task_id = None
        
        # ì¬ì‹œì‘ ëª¨ë“œê±°ë‚˜ ì‹¤í–‰ ì¤‘ì¸ íƒœìŠ¤í¬ê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ ê¸°ì¡´ íƒœìŠ¤í¬ ì •ë¦¬
        if restart or is_running:
            # telegram_idì˜ task_id í™•ì¸
            
            if telegram_id and telegram_id != "":
                telegram_task_id_key = f"user:{telegram_id}:task_id"
                task_id = await _get_redis_client().get(telegram_task_id_key)
            
            # okx_uidì˜ task_id í™•ì¸
            if not task_id:
                okx_task_id_key = f"user:{okx_uid}:task_id"
                task_id = await _get_redis_client().get(okx_task_id_key)
            
            # ê¸°ì¡´ íƒœìŠ¤í¬ ì¢…ë£Œ ì‹œë„
            if task_id:
                logger.info(f"ê¸°ì¡´ íƒœìŠ¤í¬ ì¢…ë£Œ ì‹œë„: {task_id} (okx_uid: {okx_uid}, telegram_id: {telegram_id})")
                try:
                    celery_app.control.revoke(task_id, terminate=True)
                    
                    # telegram_idì˜ task_id í‚¤ ì‚­ì œ
                    if telegram_id:
                        await _get_redis_client().delete(f"user:{telegram_id}:task_id")
                    
                    # okx_uidì˜ task_id í‚¤ ì‚­ì œ
                    await _get_redis_client().delete(f"user:{okx_uid}:task_id")
                    
                    # íƒœìŠ¤í¬ê°€ ì™„ì „íˆ ì¢…ë£Œë  ë•Œê¹Œì§€ ì§§ì€ ì§€ì—° ì¶”ê°€
                    await asyncio.sleep(2)
                except Exception as revoke_error:
                    logger.error(f"íƒœìŠ¤í¬ ì·¨ì†Œ ì˜¤ë¥˜: {str(revoke_error)}")
        
        # ë½ ë° ì¿¨ë‹¤ìš´ ì •ë¦¬ (í•­ìƒ ì‹¤í–‰)
        # 1. íŠ¸ë ˆì´ë”© ì‹œì‘ ì „ ì‚¬ìš©ì ë½(lock) ì‚­ì œ
        if okx_uid:
            lock_key = f"lock:user:{okx_uid}:{symbol}:{timeframe}"
            try:
            # ë½ ì¡´ì¬ í™•ì¸ í›„ ì‚­ì œ
                lock_exists = await _get_redis_client().exists(lock_key)
                if lock_exists:
                    logger.info(f"[{okx_uid}] ê¸°ì¡´ ë½ ì‚­ì œ: {symbol}/{timeframe}")
                    await _get_redis_client().delete(lock_key)
            except Exception as lock_err:
                logger.warning(f"[{okx_uid}] ë½ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {str(lock_err)}")
        
        # 2. ì¿¨ë‹¤ìš´ ì œí•œ í•´ì œ (long/short ëª¨ë‘)
        for direction in ["long", "short"]:
            cooldown_key = f"user:{okx_uid}:cooldown:{symbol}:{direction}"
            try:
                cooldown_exists = await _get_redis_client().exists(cooldown_key)
                if cooldown_exists:
                    logger.info(f"[{okx_uid}] ê¸°ì¡´ ì¿¨ë‹¤ìš´ ì‚­ì œ: {symbol}/{direction}")
                    await _get_redis_client().delete(cooldown_key)
            except Exception as cooldown_err:
                logger.warning(f"[{okx_uid}] ì¿¨ë‹¤ìš´ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {str(cooldown_err)}")
                
        # 3. íƒœìŠ¤í¬ ì‹¤í–‰ ìƒíƒœ ì´ˆê¸°í™” (ì´ì „ì— ë¹„ì •ìƒ ì¢…ë£Œëœ íƒœìŠ¤í¬ê°€ ìˆì„ ê²½ìš°)
        task_running_key = f"user:{okx_uid}:task_running"
        try:
            task_running_exists = await _get_redis_client().exists(task_running_key)
            if task_running_exists:
                logger.info(f"[{okx_uid}] ê¸°ì¡´ íƒœìŠ¤í¬ ì‹¤í–‰ ìƒíƒœ ì´ˆê¸°í™”")
                await _get_redis_client().delete(task_running_key)
        except Exception as task_err:
            logger.warning(f"[{okx_uid}] íƒœìŠ¤í¬ ìƒíƒœ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {str(task_err)}")

        try:
            # Redis ìƒíƒœ ì €ì¥ (telegram_idì™€ okx_uid ëª¨ë‘)
            if telegram_id:
                #await redis_client.set(f"user:{telegram_id}:trading:status", "running")
                await _get_redis_client().hset(
                    f"user:{telegram_id}:preferences",
                    mapping={"symbol": request.symbol, "timeframe": request.timeframe}
                )

            # ìƒíƒœë¥¼ 'running'ìœ¼ë¡œ ëª…ì‹œì  ì„¤ì •
            await _get_redis_client().set(okx_status_key, "running")
            await _get_redis_client().hset(
                f"user:{okx_uid}:preferences",
                mapping={"symbol": request.symbol, "timeframe": request.timeframe}
            )

            symbol = request.symbol
            timeframe = request.timeframe

            # Celery íƒœìŠ¤í¬ ì‹¤í–‰ (okx_uid ì „ë‹¬)
            task = celery_app.send_task(
                'trading_tasks.execute_trading_cycle',
                args=[okx_uid, symbol, timeframe, restart]
            )
            logger.info(f"[{okx_uid}] ìƒˆ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì‹œì‘: {task.id} (symbol: {symbol}, timeframe: {timeframe})")

            # task_id ì €ì¥ (telegram_idì™€ okx_uid ëª¨ë‘)
            if telegram_id:
                await _get_redis_client().set(f"user:{telegram_id}:task_id", task.id)
            await _get_redis_client().set(f"user:{okx_uid}:task_id", task.id)

            return {
                "status": "success",
                "message": "íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.",
                "task_id": task.id
            }
        except Exception as task_error:
            logger.error(f"íƒœìŠ¤í¬ ì‹œì‘ ì˜¤ë¥˜ (okx_uid: {okx_uid}): {str(task_error)}", exc_info=True)
            await handle_critical_error(
                error=task_error,
                category=ErrorCategory.CELERY_TASK,
                context={"endpoint": "start_trading", "okx_uid": okx_uid, "symbol": symbol, "timeframe": timeframe},
                okx_uid=okx_uid
            )
            # Redis ìƒíƒœ ì´ˆê¸°í™”
            if telegram_id:
                await _get_redis_client().set(f"user:{telegram_id}:trading:status", "error")
            await _get_redis_client().set(okx_status_key, "error")
            raise HTTPException(status_code=500, detail=f"íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì‹œì‘ ì‹¤íŒ¨: {str(task_error)}")
            
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"íŠ¸ë ˆì´ë”© ì‹œì‘ ì¤‘ ì˜¤ë¥˜ (okx_uid: {okx_uid}): {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"íŠ¸ë ˆì´ë”© ì‹œì‘ ì‹¤íŒ¨: {str(e)}")



@router.post("/start_all_users",
    summary="ëª¨ë“  ì‹¤í–‰ ì¤‘ì¸ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì¬ì‹œì‘ (OKX UID ê¸°ì¤€)",
    description="ì„œë²„ ì¬ì‹œì‘ ë“±ìœ¼ë¡œ ë‹¤ìš´ í›„, ê¸°ì¡´ì— ì‹¤í–‰ ì¤‘ì´ë˜ ëª¨ë“  ì‚¬ìš©ìì˜ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ë¥¼ ì¬ì‹œì‘í•©ë‹ˆë‹¤ (OKX UID ê¸°ì¤€).",
    responses={
        200: {
            "description": "ëª¨ë“  ì‹¤í–‰ ì¤‘ì¸ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì¬ì‹œì‘ ì„±ê³µ",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "message": "ëª¨ë“  ì‹¤í–‰ ì¤‘ì¸ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ì— ì¬ì‹œì‘ ëª…ë ¹ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.",
                        "restarted_users": [
                            {"okx_uid": "UID1", "task_id": "new_task_id_1"},
                            {"okx_uid": "UID2", "task_id": "new_task_id_2"}
                        ]
                    }
                }
            }
        },
        500: {"description": "íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì¬ì‹œì‘ ì‹¤íŒ¨"}
    })
async def start_all_users():
    try:
        # Redis ì—°ê²° í™•ì¸
        if not await _get_redis_client().ping():
            await handle_critical_error(
                error=Exception("Redis ping ì‹¤íŒ¨"),
                category=ErrorCategory.REDIS_CONNECTION,
                context={"endpoint": "start_all_users"},
                okx_uid="system"
            )
            raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹¤íŒ¨")
            
        # íŒ¨í„´ ë³€ê²½: user:*:trading:status
        status_keys = await _get_redis_client().keys("user:*:trading:status")
        restarted_users = []
        errors = []
        
        logger.debug(f"ì´ {len(status_keys)}ê°œì˜ íŠ¸ë ˆì´ë”© ìƒíƒœ í‚¤ ë°œê²¬")
        
        for key in status_keys:
            okx_uid = None # ë£¨í”„ ì‹œì‘ ì‹œ ì´ˆê¸°í™”
            status = await _get_redis_client().get(key)
            
            # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
            if isinstance(status, bytes):
                status = status.decode('utf-8')
                
            # statusê°€ 'running'ì¸ ê²½ìš°ë§Œ ì¬ì‹œì‘ ì²˜ë¦¬
            if status == "running":
                try:
                    # key êµ¬ì¡°: user:{okx_uid}:trading:status
                    parts = key.split(":")
                    if len(parts) >= 2 and parts[0] == 'user':
                        okx_uid = parts[1]
                    else:
                        logger.warning(f"ì˜ëª»ëœ í‚¤ í˜•ì‹ ë°œê²¬: {key}")
                        continue
                    
                    logger.info(f"ì‚¬ìš©ì {okx_uid} ì¬ì‹œì‘ ì‹œë„ ì¤‘")
                    
                    task_id_key = f"user:{okx_uid}:task_id"
                    current_task_id = await _get_redis_client().get(task_id_key)
                    
                    # ê¸°ì¡´ íƒœìŠ¤í¬ê°€ ì¡´ì¬í•˜ë©´ ì¢…ë£Œ
                    if current_task_id:
                        logger.info(f"ê¸°ì¡´ íƒœìŠ¤í¬ ì¢…ë£Œ: {current_task_id} (okx_uid: {okx_uid})")
                        celery_app.control.revoke(current_task_id, terminate=True)
                        await _get_redis_client().delete(task_id_key)
                        # ìƒíƒœëŠ” ì„ì‹œë¡œ 'restarting'ìœ¼ë¡œ ì„¤ì •
                        await _get_redis_client().set(key, "restarting")
                        
                        # íƒœìŠ¤í¬ê°€ ì™„ì „íˆ ì¢…ë£Œë  ë•Œê¹Œì§€ ì§§ì€ ì§€ì—° ì¶”ê°€
                        await asyncio.sleep(1)
                    
                    try:
                        preference_key = f"user:{okx_uid}:preferences"
                        symbol = await _get_redis_client().hget(preference_key, "symbol")
                        timeframe = await _get_redis_client().hget(preference_key, "timeframe")
                        # restart ì˜µì…˜ì„ Trueë¡œ í•´ì„œ ìƒˆ íƒœìŠ¤í¬ ì‹¤í–‰ (okx_uid ì „ë‹¬)
                        task = celery_app.send_task(
                            'trading_tasks.execute_trading_cycle',
                            args=[okx_uid, symbol, timeframe, True]
                        )
                        
                        logger.info(f"[{okx_uid}] ìƒˆ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì‹œì‘: {task.id} (symbol: {symbol}, timeframe: {timeframe})")
                        
                        # Redisì— ìƒˆ íƒœìŠ¤í¬ ì •ë³´ ì—…ë°ì´íŠ¸
                        await _get_redis_client().set(key, "running") # ìƒíƒœ í‚¤ ì‚¬ìš©
                        await _get_redis_client().set(task_id_key, task.id) # íƒœìŠ¤í¬ ID í‚¤ ì‚¬ìš©
                        
                        restarted_users.append({"okx_uid": okx_uid, "task_id": task.id}) # user_id -> okx_uid
                    except Exception as task_error:
                        logger.error(f"íƒœìŠ¤í¬ ì‹œì‘ ì˜¤ë¥˜ (okx_uid: {okx_uid}): {str(task_error)}", exc_info=True)
                        await handle_critical_error(
                            error=task_error,
                            category=ErrorCategory.CELERY_TASK,
                            context={"endpoint": "start_all_users", "okx_uid": okx_uid, "symbol": symbol, "timeframe": timeframe},
                            okx_uid=okx_uid
                        )
                        errors.append({"okx_uid": okx_uid, "error": f"íƒœìŠ¤í¬ ì‹œì‘ ì‹¤íŒ¨: {str(task_error)}"}) # user_id -> okx_uid
                        # ìƒíƒœë¥¼ 'error'ë¡œ ì„¤ì •
                        await _get_redis_client().set(key, "error") # ìƒíƒœ í‚¤ ì‚¬ìš©
                        
                except Exception as user_err:
                    error_id = okx_uid if okx_uid else key # okx_uid ì¶”ì¶œ ì‹¤íŒ¨ ì‹œ í‚¤ ìì²´ë¥¼ IDë¡œ ì‚¬ìš©
                    logger.error(f"ì‚¬ìš©ì {error_id} ì¬ì‹œì‘ ì¤‘ ì—ëŸ¬: {str(user_err)}", exc_info=True)
                    await handle_critical_error(
                        error=user_err,
                        category=ErrorCategory.MASS_OPERATION,
                        context={"endpoint": "start_all_users", "error_id": error_id, "operation": "restart"},
                        okx_uid=okx_uid if okx_uid else "system"
                    )
                    errors.append({"identifier": error_id, "error": str(user_err)})
                    
        logger.info(f"ì¬ì‹œì‘ ì™„ë£Œ: {len(restarted_users)}ê°œ ì„±ê³µ, {len(errors)}ê°œ ì‹¤íŒ¨")
                    
        response = {
            "status": "success",
            "message": "ëª¨ë“  ì‹¤í–‰ ì¤‘ì¸ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ì— ì¬ì‹œì‘ ëª…ë ¹ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.",
            "restarted_users": restarted_users
        }
        if errors:
            response["errors"] = errors
        
        return response

    except Exception as e:
        logger.error(f"start_all_users ì‹¤íŒ¨: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"start_all_users ì‹¤íŒ¨: {str(e)}")


@router.post("/stop",
    summary="íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì¤‘ì§€ (OKX UID ê¸°ì¤€)",
    description="íŠ¹ì • ì‚¬ìš©ìì˜ ìë™ íŠ¸ë ˆì´ë”©ì„ ì¤‘ì§€í•©ë‹ˆë‹¤ (OKX UID ê¸°ì¤€).",
    responses={
        200: {
            "description": "íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì¤‘ì§€ ì„±ê³µ",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "message": "íŠ¸ë ˆì´ë”©ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤."
                    }
                }
            }
        },
        400: {"description": "íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì¤‘ì§€ ì‹¤íŒ¨"}
    })
async def stop_trading(request: Request, user_id: Optional[str] = Query(None, description="ì‚¬ìš©ì ID (OKX UID ë˜ëŠ” í…”ë ˆê·¸ë¨ ID)")):
    try:
        symbol = None
        okx_uid = None
        
        # 1. ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ì—ì„œ user_id í™•ì¸
        if user_id:
            okx_uid = user_id
        else:
            # 2. JSON ë³¸ë¬¸ì—ì„œ okx_uid í™•ì¸ (ê¸°ì¡´ ë°©ì‹)
            try:
                request_body = await request.json()
                if "okx_uid" in request_body:
                    okx_uid = request_body["okx_uid"]
            except (json.JSONDecodeError, ValueError, AttributeError):
                pass
        
        # 3. í•„ìˆ˜ íŒŒë¼ë¯¸í„° í™•ì¸
        if not okx_uid:
            raise HTTPException(status_code=400, detail="user_id ë˜ëŠ” okx_uidê°€ í•„ìš”í•©ë‹ˆë‹¤.")
            
        logger.info(f"ì‚¬ìš©ì {okx_uid}ì˜ íŠ¸ë ˆì´ë”© íƒœìŠ¤í¬ ì¤‘ì§€ ì‹œë„")
        
        # í…”ë ˆê·¸ë¨ IDì¸ì§€ OKX UIDì¸ì§€ í™•ì¸
        is_telegram_id = not okx_uid.isdigit() or len(okx_uid) < 10
        
        # í…”ë ˆê·¸ë¨ IDì¸ ê²½ìš° OKX UIDë¡œ ë³€í™˜ ì‹œë„
        telegram_id = okx_uid if is_telegram_id else None
        if is_telegram_id:
            okx_uid_from_telegram = await get_okx_uid_from_telegram(okx_uid)
            if okx_uid_from_telegram:
                okx_uid = okx_uid_from_telegram
                is_telegram_id = False
        else:
            # OKX UIDì¸ ê²½ìš° í…”ë ˆê·¸ë¨ ID ì°¾ê¸° (ì„ íƒ ì‚¬í•­)
            try:
                telegram_id = await get_telegram_id_from_uid(okx_uid, TimescaleUserService)
            except Exception as e:
                logger.debug(f"í…”ë ˆê·¸ë¨ ID ì¡°íšŒ ì‹¤íŒ¨ (ë¬´ì‹œë¨): {str(e)}")
        
        # í…”ë ˆê·¸ë¨ IDë¡œ ëœ í‚¤ í™•ì¸ (ì›ë˜ IDê°€ í…”ë ˆê·¸ë¨ IDì¸ ê²½ìš°)
        if telegram_id:
            telegram_status_key = f"user:{telegram_id}:trading:status"
            telegram_status = await _get_redis_client().get(telegram_status_key)
            
            # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
            if isinstance(telegram_status, bytes):
                telegram_status = telegram_status.decode('utf-8')
                
            # ë¬¸ìì—´ ì •ê·œí™” (ê³µë°± ì œê±° ë° ë”°ì˜´í‘œ ì œê±°)
            if telegram_status:
                telegram_status = telegram_status.strip().strip('"\'')
                
            if telegram_status == "running":
                await _get_redis_client().set(telegram_status_key, "stopped")
                logger.info(f"í…”ë ˆê·¸ë¨ ID {telegram_id}ì˜ íŠ¸ë ˆì´ë”© ìƒíƒœë¥¼ stoppedë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.")
        
        # OKX UIDë¡œ ëœ í‚¤ í™•ì¸
        okx_status_key = f"user:{okx_uid}:trading:status"
        okx_status = await _get_redis_client().get(okx_status_key)
        
        # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
        if isinstance(okx_status, bytes):
            okx_status = okx_status.decode('utf-8')
            
        # ë¬¸ìì—´ ì •ê·œí™” (ê³µë°± ì œê±° ë° ë”°ì˜´í‘œ ì œê±°)
        if okx_status:
            okx_status = okx_status.strip().strip('"\'')
            
        if okx_status == "running":
            await _get_redis_client().set(okx_status_key, "stopped")
            logger.info(f"OKX UID {okx_uid}ì˜ íŠ¸ë ˆì´ë”© ìƒíƒœë¥¼ stoppedë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.")
        
        # ë‘˜ ë‹¤ runningì´ ì•„ë‹Œ ê²½ìš°
        if (not telegram_id or telegram_status != "running") and okx_status != "running":
            logger.warning(f"ì‚¬ìš©ì {okx_uid}ì˜ íŠ¸ë ˆì´ë”© ìƒíƒœê°€ 'running'ì´ ì•„ë‹™ë‹ˆë‹¤.")
            # ì´ë¯¸ ë©ˆì¶°ìˆëŠ” ê²½ìš° ë°”ë¡œ ì„±ê³µ ë°˜í™˜
            if (telegram_id and telegram_status == "stopped") or okx_status == "stopped":
                return {
                    "status": "success",
                    "message": "íŠ¸ë ˆì´ë”©ì´ ì´ë¯¸ ì¤‘ì§€ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
                }
        
        # ì¢…ë£Œ ì‹ í˜¸ ì„¤ì •
        if telegram_id:
            await _get_redis_client().set(f"user:{telegram_id}:stop_signal", "true")
        await _get_redis_client().set(f"user:{okx_uid}:stop_signal", "true")
            
        logger.info(f"ì‚¬ìš©ì {okx_uid}ì—ê²Œ ì¢…ë£Œ ì‹ í˜¸ë¥¼ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.")
        
        # íƒœìŠ¤í¬ ID í™•ì¸
        task_id = None
        if telegram_id:
            task_id_key = f"user:{telegram_id}:task_id"
            task_id = await _get_redis_client().get(task_id_key)
        
        if not task_id:
            task_id_key = f"user:{okx_uid}:task_id"
            task_id = await _get_redis_client().get(task_id_key)
            
        # í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ íƒœìŠ¤í¬ ì·¨ì†Œ ì‹œë„
        if task_id:
            try:
                logger.info(f"Celery íƒœìŠ¤í¬ ì·¨ì†Œ ì‹œë„ (task_id: {task_id}, user_id: {okx_uid})")
                celery_app.control.revoke(task_id, terminate=True)
                logger.info(f"Celery íƒœìŠ¤í¬ ì·¨ì†Œ ëª…ë ¹ ì „ì†¡ ì™„ë£Œ (task_id: {task_id})")
                
                # Celery íƒœìŠ¤í¬ ì¢…ë£Œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì‹œê°„ ì¦ê°€ (2ì´ˆ)
                await asyncio.sleep(2)
            except Exception as revoke_err:
                logger.error(f"íƒœìŠ¤í¬ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (task_id: {task_id}): {str(revoke_err)}", exc_info=True)
        else:
            logger.warning(f"íƒœìŠ¤í¬ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (user_id: {okx_uid})")
            
        # ì„ í˜¸ë„ ì •ë³´ì—ì„œ ì‹¬ë³¼ê³¼ íƒ€ì„í”„ë ˆì„ ê°€ì ¸ì˜¤ê¸°
        try:
            if telegram_id:
                preference_key = f"user:{telegram_id}:preferences"
                symbol = await _get_redis_client().hget(preference_key, "symbol")
                timeframe = await _get_redis_client().hget(preference_key, "timeframe")
                
            if not symbol or not timeframe:
                preference_key = f"user:{okx_uid}:preferences"
                symbol = await _get_redis_client().hget(preference_key, "symbol")
                timeframe = await _get_redis_client().hget(preference_key, "timeframe")
                
            # 1. ì‚¬ìš©ì ë½(lock) í•´ì œ
            if symbol and timeframe:
                lock_key = f"lock:user:{okx_uid}:{symbol}:{timeframe}"
                try:
                    lock_exists = await _get_redis_client().exists(lock_key)
                    if lock_exists:
                        logger.info(f"[{okx_uid}] ë½ í•´ì œ: {symbol}/{timeframe}")
                        await _get_redis_client().delete(lock_key)
                except Exception as lock_err:
                    logger.warning(f"[{okx_uid}] ë½ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {str(lock_err)}")
                
            # 2. ì¿¨ë‹¤ìš´ í‚¤ í•´ì œ (long/short ëª¨ë‘)
            if symbol:
                for direction in ["long", "short"]:
                    cooldown_key = f"user:{okx_uid}:cooldown:{symbol}:{direction}"
                    try:
                        cooldown_exists = await _get_redis_client().exists(cooldown_key)
                        if cooldown_exists:
                            logger.info(f"[{okx_uid}] ì¿¨ë‹¤ìš´ í•´ì œ: {symbol}/{direction}")
                            await _get_redis_client().delete(cooldown_key)
                    except Exception as cooldown_err:
                        logger.warning(f"[{okx_uid}] ì¿¨ë‹¤ìš´ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {str(cooldown_err)}")
        except Exception as pref_err:
            logger.warning(f"ì„ í˜¸ë„ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {str(pref_err)}")
            
        # ì‚¬ìš©ìì—ê²Œ íŠ¸ë ˆì´ë”© ì¤‘ì§€ ë©”ì‹œì§€ ì „ì†¡
        try:
            # telegram_idê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ okx_uid ì‚¬ìš©
            recipient_id = telegram_id if telegram_id else okx_uid
            await send_telegram_message(
                f"ğŸ›‘ íŠ¸ë ˆì´ë”©ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n"
                f"ì‹¬ë³¼: {symbol if symbol else 'ì•Œ ìˆ˜ ì—†ìŒ'}\n"
                f"íƒ€ì„í”„ë ˆì„: {timeframe if timeframe else 'ì•Œ ìˆ˜ ì—†ìŒ'}", 
                recipient_id
            )
            logger.info(f"ì‚¬ìš©ì {okx_uid}ì—ê²Œ íŠ¸ë ˆì´ë”© ì¤‘ì§€ ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ")
        except Exception as msg_err:
            logger.error(f"íŠ¸ë ˆì´ë”© ì¤‘ì§€ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: {str(msg_err)}", exc_info=True)
            
        # 3. íƒœìŠ¤í¬ ì‹¤í–‰ ìƒíƒœ ì •ë¦¬
        task_running_key = f"user:{okx_uid}:task_running"
        try:
            task_running_exists = await _get_redis_client().exists(task_running_key)
            if task_running_exists:
                logger.info(f"[{okx_uid}] íƒœìŠ¤í¬ ì‹¤í–‰ ìƒíƒœ ì •ë¦¬")
                await _get_redis_client().delete(task_running_key)
        except Exception as task_err:
            logger.warning(f"[{okx_uid}] íƒœìŠ¤í¬ ìƒíƒœ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {str(task_err)}")
            
        # TradingService ì´ˆê¸°í™” ë° í™œì„± ì£¼ë¬¸ ì·¨ì†Œ ì‹œë„
        trading_service = None
        try:
            trading_service = TradingService(user_id=okx_uid)
            
            # ê¸°ì¡´ exchange í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ìƒì„±
            if not trading_service.client:
                trading_service.client = await get_okx_client(user_id=okx_uid)
                
            #if trading_service.client and symbol:
            #    logger.info(f"ì‚¬ìš©ì {okx_uid}ì˜ ì—´ë¦° ì£¼ë¬¸ ì·¨ì†Œ ì‹œë„ (ì‹¬ë³¼: {symbol})")
            #    try:
            #        await trading_service.cancel_all_open_orders(trading_service.client, symbol, okx_uid)
            #        logger.info(f"ëª¨ë“  ì—´ë¦° ì£¼ë¬¸ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤. user_id: {okx_uid}, symbol: {symbol}")
            #    except Exception as cancel_err:
            #        logger.error(f"ì£¼ë¬¸ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(cancel_err)}", exc_info=True)
        except Exception as service_err:
            logger.error(f"TradingService ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(service_err)}", exc_info=True)
        
        # Redis ìƒíƒœ ì´ˆê¸°í™” - í•µì‹¬ í‚¤ë§Œ ì‚­ì œ
        try:
            logger.info(f"ì‚¬ìš©ì {okx_uid}ì˜ Redis ìƒíƒœ ì´ˆê¸°í™” ì¤‘")

            # í•µì‹¬ í‚¤ ëª©ë¡ (í…”ë ˆê·¸ë¨ IDì™€ OKX UID ëª¨ë‘)
            keys_to_delete = []
            
            # íƒœìŠ¤í¬ ID, ì¤‘ì§€ ì‹ í˜¸, íƒœìŠ¤í¬ ì‹¤í–‰ ìƒíƒœ í‚¤ ì‚­ì œ
            if telegram_id:
                keys_to_delete.extend([
                    f"user:{telegram_id}:task_id",
                    f"user:{telegram_id}:stop_signal"
                ])
                
            keys_to_delete.extend([
                f"user:{okx_uid}:task_id",
                f"user:{okx_uid}:stop_signal",
                f"user:{okx_uid}:task_running"
            ])
            
            # í¬ì§€ì…˜ ê´€ë ¨ í‚¤ëŠ” ì‹¬ë³¼ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ì‚­ì œ
            if symbol:
                for direction in ["long", "short"]:
                    cooldown_key = f"user:{okx_uid}:cooldown:{symbol}:{direction}"
                    keys_to_delete.append(cooldown_key)
                    
                if timeframe:
                    lock_key = f"lock:user:{okx_uid}:{symbol}:{timeframe}"
                    keys_to_delete.append(lock_key)
            
            # ì‚­ì œ ì‹¤í–‰
            for key in keys_to_delete:
                try:
                    await _get_redis_client().delete(key)
                except Exception as del_err:
                    logger.warning(f"í‚¤ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (key: {key}): {str(del_err)}")
            
            logger.debug(f"ì‚¬ìš©ì {okx_uid}ì˜ Redis ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as redis_err:
            logger.error(f"Redis ìƒíƒœ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(redis_err)}", exc_info=True)
        
        # TradingService cleanup
        try:
            if trading_service:
                await trading_service.cleanup()
                logger.info(f"TradingService cleanup ì™„ë£Œ (user_id: {okx_uid})")
        except Exception as cleanup_err:
            logger.error(f"TradingService cleanup ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(cleanup_err)}", exc_info=True)
            
        return {
            "status": "success",
            "message": "íŠ¸ë ˆì´ë”© ì¤‘ì§€ ì‹ í˜¸ê°€ ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤. ì ì‹œ í›„ ì¤‘ì§€ë©ë‹ˆë‹¤."
        }
    except Exception as e:
        logger.error(f"íŠ¸ë ˆì´ë”© ì¤‘ì§€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"íŠ¸ë ˆì´ë”© ì¤‘ì§€ ì‹¤íŒ¨: {str(e)}"
        )
        
@router.get("/running_users",
    summary="ì‹¤í–‰ ì¤‘(trading status=running)ì¸ ëª¨ë“  ì‚¬ìš©ì ì¡°íšŒ (OKX UID ê¸°ì¤€)",
    description="Redisì—ì„œ 'user:{okx_uid}:trading:status'ê°€ 'running'ì¸ ëª¨ë“  ìœ ì €ì˜ OKX UID ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤."
)
async def get_all_running_users():
    """
    í˜„ì¬ 'running' ìƒíƒœì¸ ëª¨ë“  OKX UIDë¥¼ ì¡°íšŒ
    """
    try:
        if not await _get_redis_client().ping():
            raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹¤íŒ¨")
        
        status_keys = await _get_redis_client().keys("user:*:trading:status") # íŒ¨í„´ ë³€ê²½
        running_users = []
        
        for key in status_keys:
            status = await _get_redis_client().get(key)
            
            # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
            if isinstance(status, bytes):
                status = status.decode('utf-8')
                
            if status == "running":
                # key êµ¬ì¡°: user:{okx_uid}:trading:status
                parts = key.split(":")
                if len(parts) >= 2 and parts[0] == 'user':
                    okx_uid = parts[1]
                    running_users.append(okx_uid) # user_id -> okx_uid
                else:
                    logger.warning(f"ì˜ëª»ëœ í‚¤ í˜•ì‹ ë°œê²¬: {key}")
        
        return {
            "status": "success",
            "running_users": running_users
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"running_users ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")


@router.post("/stop_all_running_users",
    summary="ì‹¤í–‰ ì¤‘(trading status=running)ì¸ ëª¨ë“  ì‚¬ìš©ì ì¤‘ì§€ (OKX UID ê¸°ì¤€)",
    description="Redisì—ì„œ 'running' ìƒíƒœì¸ ëª¨ë“  OKX UIDì˜ íŠ¸ë ˆì´ë”©ì„ ì¤‘ì§€í•©ë‹ˆë‹¤."
)
async def stop_all_running_users():
    """
    ëª¨ë“  'running' ìƒíƒœ ì‚¬ìš©ìì— ëŒ€í•´ ì¼ê´„ ì¤‘ì§€.
    stop_trading ë¡œì§ì„ ë°˜ë³µí•´ì„œ ìˆ˜í–‰ (OKX UID ê¸°ì¤€).
    """
    try:
        if not await _get_redis_client().ping():
            raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹¤íŒ¨")
        
        status_keys = await _get_redis_client().keys("user:*:trading:status") # íŒ¨í„´ ë³€ê²½
        stopped_users = []
        errors = []
        
        logger.info(f"ì´ {len(status_keys)}ê°œì˜ íŠ¸ë ˆì´ë”© ìƒíƒœ í‚¤ ë°œê²¬")

        for key in status_keys:
            okx_uid = None # ë£¨í”„ ì‹œì‘ ì‹œ ì´ˆê¸°í™”
            status = await _get_redis_client().get(key)
            
            # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
            if isinstance(status, bytes):
                status = status.decode('utf-8')
                
            if status == "running":
                parts = key.split(":")
                if len(parts) >= 2 and parts[0] == 'user':
                    okx_uid = parts[1]
                else:
                    logger.warning(f"ì˜ëª»ëœ í‚¤ í˜•ì‹ ë°œê²¬: {key}")
                    continue
                
                logger.info(f"ì‚¬ìš©ì {okx_uid} ì¤‘ì§€ ì‹œë„ ì¤‘")
                
                try:
                    # ì¢…ë£Œ ì‹ í˜¸ ì„¤ì • (okx_uid ì‚¬ìš©)
                    await _get_redis_client().set(f"user:{okx_uid}:stop_signal", "true")
                    await _get_redis_client().set(f"user:{okx_uid}:trading:status", "stopped")
                    # await send_telegram_message(f"âš ï¸[{okx_uid}] Userì˜ ìƒíƒœë¥¼ Stoppedë¡œ ê°•ì œ ë³€ê²½.6", okx_uid, debug=True)
                    logger.info(f"ì‚¬ìš©ì {okx_uid}ì—ê²Œ ì¢…ë£Œ ì‹ í˜¸ë¥¼ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.")
                    
                    # TradingService ì´ˆê¸°í™” ë° í™œì„± ì£¼ë¬¸ ì·¨ì†Œ (okx_uid ì‚¬ìš© ê°€ì •)
                    trading_service = None
                    symbol = None # ì‹¬ë³¼ ì´ˆê¸°í™”
                    try:
                        trading_service = TradingService(user_id=okx_uid)
                        if not trading_service.client:
                            trading_service.client = await get_okx_client(user_id=okx_uid)
                        
                        symbol = await _get_redis_client().hget(f"user:{okx_uid}:preferences", "symbol")
                        if symbol:
                            logger.info(f"ì‚¬ìš©ì {okx_uid}ì˜ ì—´ë¦° ì£¼ë¬¸ ì·¨ì†Œ ì‹œë„ (ì‹¬ë³¼: {symbol})")
                            try:
                                await trading_service.cancel_all_open_orders(trading_service.client, symbol, okx_uid)
                                logger.info(f"ëª¨ë“  ì—´ë¦° ì£¼ë¬¸ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤. okx_uid: {okx_uid}, symbol: {symbol}")
                            except Exception as cancel_err:
                                logger.error(f"ì£¼ë¬¸ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(cancel_err)}", exc_info=True)
                    except Exception as service_err:
                        logger.error(f"TradingService ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(service_err)}", exc_info=True)
                    
                    # Celery task ì·¨ì†Œ (okx_uid ì‚¬ìš©)
                    task_id_key = f"user:{okx_uid}:task_id"
                    task_id = await _get_redis_client().get(task_id_key)
                    if task_id:
                        try:
                            logger.info(f"Celery íƒœìŠ¤í¬ ì·¨ì†Œ ì‹œë„ (task_id: {task_id}, okx_uid: {okx_uid})")
                            celery_app.control.revoke(task_id, terminate=True, signal='SIGTERM')
                            logger.info(f"Celery íƒœìŠ¤í¬ ì·¨ì†Œ ëª…ë ¹ ì „ì†¡ ì™„ë£Œ (task_id: {task_id})")
                        except Exception as revoke_err:
                            logger.error(f"íƒœìŠ¤í¬ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (task_id: {task_id}): {str(revoke_err)}", exc_info=True)
                    
                    # Redis ìƒíƒœ ì´ˆê¸°í™” (okx_uid ì‚¬ìš©)
                    try:
                        logger.info(f"ì‚¬ìš©ì {okx_uid}ì˜ Redis ìƒíƒœ ì´ˆê¸°í™” ì¤‘")
                        await _get_redis_client().set(f"user:{okx_uid}:trading:status", "stopped") # ì´ë¯¸ ìœ„ì—ì„œ ì„¤ì •í•¨
                        #await send_telegram_message(f"âš ï¸[{okx_uid}] Userì˜ ìƒíƒœë¥¼ Stoppedë¡œ ê°•ì œ ë³€ê²½.8", okx_uid, debug=True)
                        
                        # ê´€ë ¨ í‚¤ ì‚­ì œ (í‚¤ í˜•ì‹ ë³€ê²½)
                        keys_to_delete = [
                            f"user:{okx_uid}:symbol",
                            f"user:{okx_uid}:timeframe",
                            f"user:{okx_uid}:task_id",
                            f"user:{okx_uid}:stop_signal",
                            f"user:{okx_uid}:trading:status"
                        ]
                        
                        if symbol: # ì‹¬ë³¼ ì •ë³´ê°€ ìˆì„ ë•Œë§Œ í¬ì§€ì…˜ í‚¤ ì‚­ì œ
                            position_keys = [
                                f"user:{okx_uid}:position:{symbol}:main_direction_direction",
                                f"user:{okx_uid}:position:{symbol}:position_state",
                                f"user:{okx_uid}:position:{symbol}:long",
                                f"user:{okx_uid}:position:{symbol}:short",
                                f"user:{okx_uid}:position:{symbol}:long_dca_levels",
                                f"user:{okx_uid}:position:{symbol}:short_dca_levels"
                            ]
                            keys_to_delete.extend(position_keys)
                        
                        for key_to_del in keys_to_delete: # ë³€ìˆ˜ëª… ë³€ê²½ (key ì¤‘ë³µ ë°©ì§€)
                            try:
                                await _get_redis_client().delete(key_to_del)
                            except Exception as del_err:
                                logger.warning(f"í‚¤ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (key: {key_to_del}): {str(del_err)}")
                        
                        logger.debug(f"ì‚¬ìš©ì {okx_uid}ì˜ Redis ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ1")
                    except Exception as redis_err:
                        logger.error(f"Redis ìƒíƒœ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(redis_err)}", exc_info=True)
                    
                    # TradingService cleanup
                    if trading_service:
                        try:
                            await trading_service.cleanup()
                            logger.info(f"TradingService cleanup ì™„ë£Œ (user_id: {okx_uid})")
                        except Exception as cleanup_err:
                            logger.error(f"TradingService cleanup ì¤‘ ì˜¤ë¥˜ ë°œìƒ (user_id: {okx_uid}): {str(cleanup_err)}", exc_info=True)
                    
                    stopped_users.append(okx_uid) # user_id -> okx_uid
                    logger.info(f"ì‚¬ìš©ì {okx_uid} ì¤‘ì§€ ì‹ í˜¸ ì „ì†¡ ì™„ë£Œ")
                    
                    # ë‹¤ìŒ ì‚¬ìš©ì ì²˜ë¦¬ ì „ ì§§ì€ ì§€ì—° ì¶”ê°€
                    await asyncio.sleep(0.5)
                    
                except Exception as user_err:
                    errors.append({"okx_uid": okx_uid, "error": str(user_err)}) # user_id -> okx_uid
                    logger.error(f"{okx_uid} ì¤‘ì§€ ì‹¤íŒ¨: {str(user_err)}", exc_info=True)
                    await handle_critical_error(
                        error=user_err,
                        category=ErrorCategory.MASS_OPERATION,
                        context={"endpoint": "stop_all_running_users", "okx_uid": okx_uid, "operation": "stop"},
                        okx_uid=okx_uid
                    )

        logger.info(f"ì¤‘ì§€ ì™„ë£Œ: {len(stopped_users)}ê°œ ì„±ê³µ, {len(errors)}ê°œ ì‹¤íŒ¨")
        
        response = {
            "status": "success",
            "message": "running ìƒíƒœì¸ ëª¨ë“  ì‚¬ìš©ìì— ëŒ€í•´ ì¤‘ì§€ ì‹ í˜¸ë¥¼ ì „ì†¡í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ëª¨ë‘ ì¤‘ì§€ë©ë‹ˆë‹¤.",
            "stopped_users": stopped_users
        }
        if errors:
            response["errors"] = errors
        return response

    except Exception as e:
        logger.error(f"stop_all_running_users ì‹¤íŒ¨: {str(e)}", exc_info=True)
        await handle_critical_error(
            error=e,
            category=ErrorCategory.MASS_OPERATION,
            context={"endpoint": "stop_all_running_users", "operation": "mass_stop"},
            okx_uid="system"
        )
        raise HTTPException(status_code=500, detail=f"stop_all_running_users ì‹¤íŒ¨: {str(e)}")


@router.post("/restart_all_running_users",
    summary="ì‹¤í–‰ ì¤‘ì¸ ìœ ì €ë“¤ì„ ëª¨ë‘ restart=trueë¡œ ì¬ì‹œì‘ (OKX UID ê¸°ì¤€)",
    description="Redisì—ì„œ 'running' ìƒíƒœì¸ ëª¨ë“  OKX UIDë¥¼ ì°¾ì•„, ê¸°ì¡´ íƒœìŠ¤í¬ ì¢…ë£Œ í›„ restart=trueë¡œ ë‹¤ì‹œ ì‹œì‘ì‹œí‚µë‹ˆë‹¤."
)
async def restart_all_running_users():
    """
    ëª¨ë“  'running' ìƒíƒœ ì‚¬ìš©ìì— ëŒ€í•´ ì¼ê´„ ì¬ì‹œì‘(restart=True).
    ê¸°ì¡´ íƒœìŠ¤í¬ëŠ” revoke í›„, ìƒˆ íƒœìŠ¤í¬ë¥¼ ìƒì„± (OKX UID ê¸°ì¤€).
    """
    try:
        if not await _get_redis_client().ping():
            raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹¤íŒ¨")
            
        status_keys = await _get_redis_client().keys("user:*:trading:status") # íŒ¨í„´ ë³€ê²½
        restarted_users = []
        errors = []
        
        for key in status_keys:
            okx_uid = None # ë£¨í”„ ì‹œì‘ ì‹œ ì´ˆê¸°í™”
            status = await _get_redis_client().get(key)
            
            # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
            if isinstance(status, bytes):
                status = status.decode('utf-8')
                
            if status == "running":
                parts = key.split(":")
                if len(parts) >= 2 and parts[0] == 'user':
                    okx_uid = parts[1]
                else:
                    logger.warning(f"ì˜ëª»ëœ í‚¤ í˜•ì‹ ë°œê²¬: {key}")
                    continue
                try:
                    # ì‚¬ìš©ì preference ì •ë³´ ê°€ì ¸ì˜¤ê¸° (okx_uid ì‚¬ìš©)
                    preference_key = f"user:{okx_uid}:preferences"
                    symbol = await _get_redis_client().hget(preference_key, "symbol")
                    timeframe = await _get_redis_client().hget(preference_key, "timeframe")
                    
                    task_id_key = f"user:{okx_uid}:task_id"
                    current_task_id = await _get_redis_client().get(task_id_key)
                    
                    if current_task_id:
                        logger.info(f"ê¸°ì¡´ íƒœìŠ¤í¬ ì¢…ë£Œ: {current_task_id} (okx_uid: {okx_uid})")
                        celery_app.control.revoke(current_task_id, terminate=True)
                        await _get_redis_client().delete(task_id_key)
                        await _get_redis_client().set(key, "restarting") # ìƒíƒœ í‚¤ ì‚¬ìš©
                        await asyncio.sleep(0.5)
                    
                    # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ íƒœìŠ¤í¬ ì‹¤í–‰ (okx_uid ì „ë‹¬)
                    task = celery_app.send_task(
                        'trading_tasks.execute_trading_cycle',  # ìƒˆ íƒœìŠ¤í¬ í•¨ìˆ˜ ì´ë¦„
                        args=[okx_uid, symbol, timeframe , True]  # restart=True
                    )
                    # Redis ìƒíƒœ ì—…ë°ì´íŠ¸ (okx_uid ì‚¬ìš©)
                    await _get_redis_client().set(key, "running") # ìƒíƒœ í‚¤ ì‚¬ìš©
                    await _get_redis_client().set(task_id_key, task.id) # íƒœìŠ¤í¬ ID í‚¤ ì‚¬ìš©
                    
                    # preference ì •ë³´ í™•ì¸ ë° ì—…ë°ì´íŠ¸ (okx_uid ì‚¬ìš©)
                    if symbol and timeframe:
                        await _get_redis_client().hset(
                            preference_key,
                            mapping={"symbol": symbol, "timeframe": timeframe}
                        )
                    
                    restarted_users.append({
                        "okx_uid": okx_uid, # user_id -> okx_uid
                        "task_id": task.id,
                        "symbol": symbol,
                        "timeframe": timeframe
                    })
                    
                    
                    logger.info(f"ì‚¬ìš©ì {okx_uid} ì¬ì‹œì‘ ì„±ê³µ (íƒœìŠ¤í¬: {task.id})")
                    
                except Exception as user_err:
                    logger.error(f"okx_uid {okx_uid} ì¬ì‹œì‘ ì¤‘ ì—ëŸ¬: {str(user_err)}", exc_info=True)
                    errors.append({"okx_uid": okx_uid, "error": str(user_err)}) # user_id -> okx_uid
                    # ì˜¤ë¥˜ ë°œìƒ ì‹œ ìƒíƒœë¥¼ 'error'ë¡œ ì„¤ì • (okx_uid ì‚¬ìš©)
                    await _get_redis_client().set(key, "error") # ìƒíƒœ í‚¤ ì‚¬ìš©
        
        response = {
            "status": "success",
            "message": "running ìƒíƒœì¸ ëª¨ë“  ì‚¬ìš©ìì— ëŒ€í•´ ì¬ì‹œì‘(restart=True) ëª…ë ¹ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.",
            "restarted_users": restarted_users
        }
        
        if errors:
            response["errors"] = errors
            
        return response
        
    except Exception as e:
        logger.error(f"restart_all_running_users ì‹¤íŒ¨: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"restart_all_running_users ì‹¤íŒ¨: {str(e)}")

@router.get("/status/{okx_uid}", # user_id -> okx_uid
    summary="íŠ¹ì • ì‚¬ìš©ìì˜ íŠ¸ë ˆì´ë”© ìƒíƒœ ì¡°íšŒ (OKX UID ê¸°ì¤€)",
    description="íŠ¹ì • ì‚¬ìš©ìì˜ íŠ¸ë ˆì´ë”© ìƒíƒœ ë° ê´€ë ¨ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤ (OKX UID ê¸°ì¤€).",
    responses={
        200: {
            "description": "íŠ¸ë ˆì´ë”© ìƒíƒœ ì¡°íšŒ ì„±ê³µ",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": {
                            "trading_status": "running",
                            "symbol": "SOL-USDT-SWAP",
                            "timeframe": "1m",
                            "task_id": "abc123xyz",
                            "preferences": {
                                "symbol": "SOL-USDT-SWAP",
                                "timeframe": "1m"
                            },
                            "position_info": {
                                "main_direction": "long",
                                "position_state": "in_position"
                            }
                        }
                    }
                }
            }
        },
        404: {"description": "ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ"},
        500: {"description": "ì„œë²„ ì˜¤ë¥˜"}
    })
async def get_user_trading_status(okx_uid: str): # user_id -> okx_uid
    """
    íŠ¹ì • ì‚¬ìš©ìì˜ íŠ¸ë ˆì´ë”© ìƒíƒœ ì¡°íšŒ (OKX UID ê¸°ì¤€)

    Args:
        okx_uid (str): ì¡°íšŒí•  OKX UID

    Returns:
        Dict: íŠ¸ë ˆì´ë”© ìƒíƒœ ì •ë³´
    """
    try:
        # Redis ì—°ê²° í™•ì¸
        if not await _get_redis_client().ping():
            await handle_critical_error(
                error=Exception("Redis ping ì‹¤íŒ¨"),
                category=ErrorCategory.REDIS_CONNECTION,
                context={"endpoint": "start_all_users"},
                okx_uid="system"
            )
            raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹¤íŒ¨")
        
        # ê¸°ë³¸ ìƒíƒœ í‚¤ (okx_uid ì‚¬ìš©)
        status_key = f"user:{okx_uid}:trading:status" # í‚¤ ë³€ê²½
        trading_status = await _get_redis_client().get(status_key)
        
        # ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ë””ì½”ë”©
        if isinstance(trading_status, bytes):
            trading_status = trading_status.decode('utf-8')
        
        if trading_status is None:
            return {
                "status": "success",
                "data": {
                    "trading_status": "not_found",
                    "message": "ì‚¬ìš©ìì˜ íŠ¸ë ˆì´ë”© ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤."
                }
            }
        
        # ê¸°ë³¸ ì‘ë‹µ ë°ì´í„° êµ¬ì„±
        response_data = {
            "trading_status": trading_status,
        }
        
        # ê´€ë ¨ ì •ë³´ ìˆ˜ì§‘ (okx_uid ì‚¬ìš©)
        task_id_key = f"user:{okx_uid}:task_id" # í‚¤ ë³€ê²½
        task_id = await _get_redis_client().get(task_id_key)
        if task_id:
            response_data["task_id"] = task_id
        
        # ì‚¬ìš©ì ì„¤ì • ì •ë³´ (okx_uid ì‚¬ìš©)
        preferences_key = f"user:{okx_uid}:preferences" # í‚¤ ë³€ê²½
        preferences = await _get_redis_client().hgetall(preferences_key)
        if preferences:
            response_data["preferences"] = preferences
            
            # ì‹¬ë³¼ ì •ë³´ê°€ ìˆìœ¼ë©´ í¬ì§€ì…˜ ìƒíƒœë„ í™•ì¸
            if "symbol" in preferences:
                symbol = preferences["symbol"]
                response_data["symbol"] = symbol
                
                # í¬ì§€ì…˜ ìƒíƒœ ì •ë³´ (okx_uid ì‚¬ìš©)
                position_info = {}
                main_direction_key = f"user:{okx_uid}:position:{symbol}:main_direction_direction" # í‚¤ ë³€ê²½
                position_state_key = f"user:{okx_uid}:position:{symbol}:position_state" # í‚¤ ë³€ê²½
                
                main_direction = await _get_redis_client().get(main_direction_key)
                position_state = await _get_redis_client().get(position_state_key)
                
                if main_direction:
                    position_info["main_direction"] = main_direction
                if position_state:
                    position_info["position_state"] = position_state
                
                if position_info:
                    response_data["position_info"] = position_info
            
            if "timeframe" in preferences:
                response_data["timeframe"] = preferences["timeframe"]
        
        # ì •ì§€ ì‹ í˜¸ í™•ì¸ (okx_uid ì‚¬ìš©)
        stop_signal_key = f"user:{okx_uid}:stop_signal" # í‚¤ ë³€ê²½
        stop_signal = await _get_redis_client().get(stop_signal_key)
        if stop_signal:
            response_data["stop_signal"] = stop_signal
        
        return {
            "status": "success",
            "data": response_data
        }
        
    except Exception as e:
        logger.error(f"ì‚¬ìš©ì íŠ¸ë ˆì´ë”© ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨ (okx_uid: {okx_uid}): {str(e)}", exc_info=True) # ë¡œê·¸ ë³€ê²½
        raise HTTPException(
            status_code=500,
            detail=f"íŠ¸ë ˆì´ë”© ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}"
        )

@router.get("/status/{okx_uid}/{symbol}", # user_id -> okx_uid
    summary="íŠ¹ì • ì‚¬ìš©ìì˜ íŠ¹ì • ì‹¬ë³¼ì— ëŒ€í•œ íŠ¸ë ˆì´ë”© ìƒíƒœ ì¡°íšŒ (OKX UID ê¸°ì¤€)",
    description="íŠ¹ì • ì‚¬ìš©ìì˜ íŠ¹ì • ì‹¬ë³¼ì— ëŒ€í•œ íŠ¸ë ˆì´ë”© ìƒíƒœ ë° ê´€ë ¨ ì •ë³´ë¥¼ ìƒì„¸í•˜ê²Œ ì¡°íšŒí•©ë‹ˆë‹¤ (OKX UID ê¸°ì¤€).",
    responses={
        200: {
            "description": "ì‹¬ë³¼ë³„ íŠ¸ë ˆì´ë”© ìƒíƒœ ì¡°íšŒ ì„±ê³µ",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": {
                            "symbol": "SOL-USDT-SWAP",
                            "position_info": {
                                "main_direction": "long",
                                "position_state": "in_position",
                                "long": {
                                    "entry_price": "124.56",
                                    "size": "0.5"
                                },
                                "short": None,
                                "dca_levels": {
                                    "long": ["level1", "level2"],
                                    "short": []
                                }
                            }
                        }
                    }
                }
            }
        },
        404: {"description": "ì‚¬ìš©ì ë˜ëŠ” ì‹¬ë³¼ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ"},
        500: {"description": "ì„œë²„ ì˜¤ë¥˜"}
    })
async def get_user_symbol_status(okx_uid: str, symbol: str): # user_id -> okx_uid
    """
    íŠ¹ì • ì‚¬ìš©ìì˜ íŠ¹ì • ì‹¬ë³¼ì— ëŒ€í•œ íŠ¸ë ˆì´ë”© ìƒíƒœ ìƒì„¸ ì¡°íšŒ (OKX UID ê¸°ì¤€)

    Args:
        okx_uid (str): ì¡°íšŒí•  OKX UID
        symbol (str): ì¡°íšŒí•  ì‹¬ë³¼ (ì˜ˆ: SOL-USDT-SWAP)

    Returns:
        Dict: ì‹¬ë³¼ë³„ íŠ¸ë ˆì´ë”© ìƒíƒœ ì •ë³´
    """
    try:
        # Redis ì—°ê²° í™•ì¸
        if not await _get_redis_client().ping():
            await handle_critical_error(
                error=Exception("Redis ping ì‹¤íŒ¨"),
                category=ErrorCategory.REDIS_CONNECTION,
                context={"endpoint": "start_all_users"},
                okx_uid="system"
            )
            raise HTTPException(status_code=500, detail="Redis ì—°ê²° ì‹¤íŒ¨")
        
        # ì‚¬ìš©ì íŠ¸ë ˆì´ë”© ìƒíƒœ í™•ì¸ (okx_uid ì‚¬ìš©)
        status_key = f"user:{okx_uid}:trading:status" # í‚¤ ë³€ê²½
        trading_status = await _get_redis_client().get(status_key)
        
        # ì‹¬ë³¼ ì •ë³´ í™•ì¸ (okx_uid ì‚¬ìš©)
        symbol_status_key = f"user:{okx_uid}:position:{symbol}:position_state" # í‚¤ ë³€ê²½
        symbol_status = await _get_redis_client().get(symbol_status_key)
        
        # ê¸°ë³¸ ì‘ë‹µ êµ¬ì¡°
        response_data = {
            "symbol": symbol,
            "trading_status": trading_status,
        }
        
        # í¬ì§€ì…˜ ì •ë³´ ìˆ˜ì§‘ (okx_uid ì‚¬ìš©)
        position_info = {}
        
        # ë©”ì¸ ë°©í–¥ ì •ë³´
        main_direction_key = f"user:{okx_uid}:position:{symbol}:main_direction_direction" # í‚¤ ë³€ê²½
        main_direction = await _get_redis_client().get(main_direction_key)
        if main_direction:
            position_info["main_direction"] = main_direction
        
        # í¬ì§€ì…˜ ìƒíƒœ
        if symbol_status:
            position_info["position_state"] = symbol_status
        
        # ë¡± í¬ì§€ì…˜ ì •ë³´
        long_position_key = f"user:{okx_uid}:position:{symbol}:long" # í‚¤ ë³€ê²½
        long_position = await _get_redis_client().get(long_position_key)
        if long_position:
            try:
                position_info["long"] = json.loads(long_position)
            except:
                position_info["long"] = long_position
        
        # ìˆ í¬ì§€ì…˜ ì •ë³´
        short_position_key = f"user:{okx_uid}:position:{symbol}:short" # í‚¤ ë³€ê²½
        short_position = await _get_redis_client().get(short_position_key)
        if short_position:
            try:
                position_info["short"] = json.loads(short_position)
            except:
                position_info["short"] = short_position
        
        # DCA ë ˆë²¨ ì •ë³´
        dca_levels = {}
        long_dca_key = f"user:{okx_uid}:position:{symbol}:long_dca_levels" # í‚¤ ë³€ê²½
        short_dca_key = f"user:{okx_uid}:position:{symbol}:short_dca_levels" # í‚¤ ë³€ê²½
        
        long_dca = await _get_redis_client().get(long_dca_key)
        short_dca = await _get_redis_client().get(short_dca_key)
        
        if long_dca or short_dca:
            if long_dca:
                try:
                    dca_levels["long"] = json.loads(long_dca)
                except:
                    dca_levels["long"] = long_dca
            
            if short_dca:
                try:
                    dca_levels["short"] = json.loads(short_dca)
                except:
                    dca_levels["short"] = short_dca
            
            position_info["dca_levels"] = dca_levels
        
        response_data["position_info"] = position_info
        
        # ì‹¬ë³¼ì— ëŒ€í•œ ì„¤ì • ì •ë³´ ì¶”ê°€ (ìˆë‹¤ë©´) (okx_uid ì‚¬ìš©)
        symbol_settings_key = f"user:{okx_uid}:preferences" # í‚¤ ë³€ê²½
        symbol_settings = await _get_redis_client().hgetall(symbol_settings_key)
        if symbol_settings:
            response_data["preferences"] = symbol_settings
        
        return {
            "status": "success",
            "data": response_data
        }
        
    except Exception as e:
        logger.error(f"ì‚¬ìš©ì ì‹¬ë³¼ë³„ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨ (okx_uid: {okx_uid}, symbol: {symbol}): {str(e)}", exc_info=True) # ë¡œê·¸ ë³€ê²½
        raise HTTPException(
            status_code=500,
            detail=f"ì‹¬ë³¼ë³„ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}"
        )
