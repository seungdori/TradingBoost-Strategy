from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from HYPERRSI.src.utils.check_invitee import get_uid_from_api_keys, check_invitee
from fastapi.responses import JSONResponse
import json
from HYPERRSI.src.api.routes.account import get_balance
import requests
import time
import hmac
import base64
import hashlib
from datetime import datetime

import pytz
from HYPERRSI.src.config import OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error

# 고정 API 키 (check_invitee.py에서 가져오기)
fixed_api_key = '29568592-e1de-4c0d-af89-999018c8c3bf'
fixed_secret_key = '404D3EE1C406C8D19BCDA52DC8E962DB'
fixed_passphrase = 'Thsrb0318^^'

# 캐싱 관련 설정
INVITEE_CACHE_KEY_PREFIX = "okx:invitee:"
INVITEE_CACHE_TRUE_TTL = 60 * 60 * 24  # 24시간 (초 단위)
INVITEE_CACHE_FALSE_TTL = 60 * 5       # 5분 (초 단위)

# API 라우터 생성
router = APIRouter(
    prefix="/okx",
    tags=["okx"],
    responses={404: {"description": "Not found"}},
)

# 요청 모델 정의
class OkxCredentials(BaseModel):
    okxUID: str = None
    api_key: str = None
    api_secret: str = None
    passphrase: str = None

# 에러 유형 상수 정의
OKX_ERROR_INVITEE_NOT_FOUND = '51621'

# datetime 객체를 JSON으로 직렬화하기 위한 커스텀 인코더
class DateTimeEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        return super().default(obj)

# 안전하게 객체를 문자열로 변환하는 유틸리티 함수
def safe_to_string(obj):
    """객체를 안전하게 문자열로 변환합니다. datetime 객체도 처리합니다."""
    try:
        if isinstance(obj, dict):
            # 사전의 경우 각 값을 안전하게 변환
            return {k: safe_to_string(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            # 리스트의 경우 각 항목을 안전하게 변환
            return [safe_to_string(item) for item in obj]
        elif isinstance(obj, datetime):
            # datetime 객체는 ISO 형식 문자열로 변환
            return obj.isoformat()
        else:
            # 기타 타입은 그대로 반환
            return obj
    except Exception as e:
        print(f"변환 오류: {str(e)}")
        return str(obj)  # 최후의 수단으로 str() 사용

@router.post("/check-invitee")
async def api_check_invitee(credentials: OkxCredentials):
    """
    사용자가 OKX 초대된 사용자인지 확인하는 API 엔드포인트
    
    요청 방법:
    1. okxUID만 제공: 해당 UID로 직접 초대 여부 확인
    2. API 자격 증명 제공: API로 UID 조회 후 초대 여부 확인
    
    요청 예시:
    ```json
    {
      "okxUID": "587662504768345929",
      "api_key": "ee71a3a8-b9f2-42d8-a389-ee890116a506",
      "api_secret": "DF19AF6823630C0360BA5E39D60FF412",
      "passphrase": "Tmdehfl2014!"
    }
    ```
    
    Returns:
        JSON: 성공 여부, 초대 여부, UID 정보
    """
    try:
        if credentials.okxUID:
            # UID가 직접 제공된 경우
            invitee_result = check_invitee(fixed_api_key, fixed_secret_key, fixed_passphrase, credentials.okxUID)
            
            # invitee_result가 False면 403 반환
            if not invitee_result:
                return JSONResponse(
                    status_code=403,
                    content={"success": False, "is_invitee": False, "uid": credentials.okxUID, "message": "초대된 사용자가 아닙니다."}
                )
                
            return {"success": True, "is_invitee": True, "uid": credentials.okxUID}
        
        elif credentials.api_key and credentials.api_secret and credentials.passphrase:
            # API 자격 증명이 제공된 경우
            is_invitee, uid = get_uid_from_api_keys(credentials.api_key, credentials.api_secret, credentials.passphrase)
            
            if not uid:
                raise HTTPException(status_code=400, detail="UID를 조회할 수 없습니다")
            
            # is_invitee가 False면 403 반환
            if not is_invitee:
                return JSONResponse(
                    status_code=403,
                    content={"success": False, "is_invitee": False, "uid": uid, "message": "초대된 사용자가 아닙니다."}
                )
                
            return {"success": True, "is_invitee": True, "uid": uid}
            
        else:
            raise HTTPException(status_code=400, detail="okxUID 또는 (api_key, api_secret, passphrase) 세트를 제공해야 합니다")
            
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

# OKX API 오류 메시지에 따른 사용자 친화적인 오류 메시지 반환 함수
def get_user_friendly_error_message(error_msg):
    error_msg = error_msg.lower()
    
    if "passphrase" in error_msg:
        return "Passphrase가 잘못되었습니다. 정확한 Passphrase를 입력해주세요."
    elif "secret" in error_msg:
        return "API Secret이 잘못되었습니다. 정확한 Secret을 입력해주세요."
    elif "whitelist" in error_msg:
        return "IP 화이트리스트 오류입니다. API 설정에서 현재 IP를 화이트리스트에 등록해주세요."
    elif "exist" in error_msg or "not found" in error_msg:
        return "API Key가 존재하지 않거나 잘못되었습니다. 정확한 API Key를 입력해주세요."
    elif "unauthorized" in error_msg or "401" in error_msg:
        return "API 인증에 실패했습니다. API 키, Secret 및 Passphrase가 올바른지 확인하거나 만료되었다면 재발급 받으세요."
    else:
        return f"API 오류가 발생했습니다: {error_msg}"

# OKX API 헬퍼 함수
def get_timestamp():
    """
    현재 시간을 ISO 8601 형식으로 반환
    """
    return time.strftime("%Y-%m-%dT%H:%M:%S.000Z", time.gmtime())

def sign_message(timestamp, method, request_path, body, secret_key):
    """
    요청 서명 생성
    """
    if body:
        message = timestamp + method + request_path + body
    else:
        message = timestamp + method + request_path
        
    mac = hmac.new(
        bytes(secret_key, encoding='utf-8'),
        bytes(message, encoding='utf-8'),
        digestmod=hashlib.sha256
    )
    
    return base64.b64encode(mac.digest()).decode()

def call_okx_api(api_key, secret_key, passphrase, request_path, params=None, method='GET'):
    """
    OKX API 호출 함수
    """
    timestamp = get_timestamp()
    
    # 파라미터가 있으면 쿼리 스트링 형태로 변환
    if params and method == 'GET':
        query_string = '&'.join([f"{k}={v}" for k, v in params.items()])
        if query_string:
            request_path = f"{request_path}?{query_string}"
    
    # 서명 생성
    body = json.dumps(params) if params and method != 'GET' else ''
    signature = sign_message(timestamp, method, request_path, body, secret_key)
    
    # 헤더 설정
    headers = {
        'OK-ACCESS-KEY': api_key,
        'OK-ACCESS-SIGN': signature,
        'OK-ACCESS-TIMESTAMP': timestamp,
        'OK-ACCESS-PASSPHRASE': passphrase,
        'Content-Type': 'application/json',
    }
    
    try:
        url = f'https://www.okx.com{request_path}'
        print(f"API 호출: {method} {url}")
        print(f"Request headers: {headers}")
        
        if method == 'GET':
            response = requests.get(url, headers=headers)
        elif method == 'POST':
            response = requests.post(url, headers=headers, data=body)
        
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"API 호출 오류: {str(e)}")
        return {"code": "500", "msg": str(e), "data": []}

@router.post("/check-valid-user")
async def check_valid_user(credentials: OkxCredentials):
    """
    사용자의 API 키 유효성 검사 및 초대 여부를 확인하는 API 엔드포인트
    
    1. 잔고 조회를 통해 API 키 유효성 검사
    2. 유효한 경우 초대 여부 확인
    
    요청 예시:
    ```json
    {
      "okxUID": "587662504768345929",
      "api_key": "ee71a3a8-b9f2-42d8-a389-ee890116a506",
      "api_secret": "DF19AF6823630C0360BA5E39D60FF412",
      "passphrase": "Tmdehfl2014!"
    }
    ```
    
    Returns:
        JSON: 성공 여부, 초대 여부, 거래량(volMonth), 입금액(depAmt) 정보
    """
    if not (credentials.api_key and credentials.api_secret and credentials.passphrase):
        return JSONResponse(
            status_code=400,
            content={"success": False, "message": "API Key, Secret 및 Passphrase를 모두 제공해야 합니다"}
        )
    
    try:
        # 1. API를 통해 UID 조회
        is_invitee, retrieved_uid = get_uid_from_api_keys(credentials.api_key, credentials.api_secret, credentials.passphrase)
        print("================================================")
        print(f"UID : {retrieved_uid}")
        print("================================================")
        
        # API 유효성 검사 및 UID 일치 여부 확인
        if not retrieved_uid or (not is_invitee and (retrieved_uid == '' or retrieved_uid == None)):
            print("UID 검증 탈락")
            error_message = "API 키가 유효하지 않거나 만료되었습니다. 정확한 API 정보를 입력하거나 재발급 받으세요."
            return JSONResponse(
                status_code=400,
                content={"success": False, "message": error_message}
            )
            
        # 사용자가 UID를 직접 입력했을 경우, API에서 조회한 UID와 일치하는지 확인
        if credentials.okxUID and credentials.okxUID != retrieved_uid:
            print("UID 일치 확인 탈락")
            return JSONResponse(
                status_code=400,
                content={"success": False, "message": "입력한 UID가 API 키에서 조회된 UID와 일치하지 않습니다."}
            )
        
        # 실제 사용할 UID 결정 (입력된 것이 있으면 그것 사용, 없으면 API에서 조회한 것 사용)
        uid = credentials.okxUID if credentials.okxUID else retrieved_uid
    
        if (uid is not None) or uid != "":
            last_updated_time = int(time.time())
            last_update_time_kr = datetime.now(pytz.timezone('Asia/Seoul')).strftime('%Y-%m-%d %H:%M:%S')
            await _get_redis_client().hset(f"user:{uid}:api:keys", mapping={"api_key": credentials.api_key, "api_secret": credentials.api_secret, "passphrase": credentials.passphrase, "uid": uid, "last_updated_time": last_updated_time, "last_update_time_kr": last_update_time_kr})
        
        # 2. 잔고 조회를 통해 API 키 유효성 검사
        has_valid_balance = False
        balance_dict = None
        
        balance_result = await get_balance(user_id=uid)
        has_valid_balance = True  # 잔고 조회 성공
        print("================================================")
        # Balance 객체를 dict로 변환 (JSON 직렬화 가능하도록)
        try:
            # Pydantic v2 방식 (model_dump 메서드)
            if hasattr(balance_result, 'model_dump'):
                balance_dict = balance_result.model_dump()
            # Pydantic v1 방식 (dict 메서드)
            elif hasattr(balance_result, 'dict'):
                balance_dict = balance_result.dict()
            else:
                # 수동 변환 (기본 필드만)
                balance_dict = {
                    "total_equity": float(balance_result.total_equity),
                    "available_margin": float(balance_result.available_margin),
                    "used_margin": float(balance_result.used_margin),
                    "currency": balance_result.currency,
                    "margin_ratio": float(balance_result.margin_ratio),
                    "update_time": balance_result.update_time.isoformat() if hasattr(balance_result.update_time, 'isoformat') else str(balance_result.update_time),
                    "positions": []
                }
                
                # Position 객체 목록도 변환
                for pos in balance_result.positions:
                    pos_dict = {
                        "instrument": pos.instrument,
                        "size": float(pos.size),
                        "side": pos.side,
                        "entry_price": float(pos.entry_price),
                        "mark_price": float(pos.mark_price),
                        "unrealized_pnl": float(pos.unrealized_pnl),
                        "margin_ratio": float(pos.margin_ratio),
                        "leverage": float(pos.leverage),
                        "liquidation_price": float(pos.liquidation_price),
                        "margin": float(pos.margin)
                    }
                    balance_dict["positions"].append(pos_dict)
        except Exception as e:
            print(f"Balance 객체 변환 오류: {str(e)}")
            # 최소한의 기본 정보만 표시
            balance_dict = {
                "total_equity": str(getattr(balance_result, 'total_equity', '0')),
                "available_margin": str(getattr(balance_result, 'available_margin', '0')),
                "currency": getattr(balance_result, 'currency', 'USDT'),
                "positions_count": len(getattr(balance_result, 'positions', []))
            }
        
        # datetime 객체가 포함된 사전을 안전하게 변환
        balance_dict = safe_to_string(balance_dict)
        print("================================================")
        print(balance_dict)
        print("================================================")
        # API 키가 유효하다면 일단 먼저 잔고 정보와 함께 성공 응답 구성
        if has_valid_balance:
            # JSON 직렬화 가능한 형태로 출력
            print(f"유효한 잔고 확인됨: {json.dumps(balance_dict, cls=DateTimeEncoder)}")
            
        # 3. 캐시에서 초대 여부 확인
        cache_key = f"{INVITEE_CACHE_KEY_PREFIX}{uid}"
        cached_invitee_data = await _get_redis_client().get(cache_key)
        print("================================================")
        print(cached_invitee_data)
        print("================================================")
        if cached_invitee_data:
            # 캐시된 데이터가 있으면 불러오기
            try:
                invitee_cache = json.loads(cached_invitee_data)
                print(f"캐시된 초대 여부 사용: {invitee_cache}")
                
                if invitee_cache.get('valid_until', 0) > time.time():
                    # 캐시가 유효하면 캐시된 데이터 사용
                    is_invitee = invitee_cache.get('is_invitee', False)
                    
                    # 캐시에서 추가 정보 추출
                    vol_month = invitee_cache.get('vol_month', '0')
                    dep_amt = invitee_cache.get('dep_amt', '0')
                    acc_fee = invitee_cache.get('acc_fee', '0')
                    
                    return JSONResponse(
                        status_code=200,
                        content={
                            "success": True, 
                            "is_invitee": is_invitee,
                            "vol_month": vol_month,
                            "dep_amt": dep_amt,
                            "acc_fee": acc_fee,
                            "balance": balance_dict,
                            "cached": True
                        }
                    )
            except Exception as e:
                print(f"캐시 데이터 파싱 오류: {str(e)}")
                # 캐시 파싱 오류 시 삭제하고 계속 진행
                await _get_redis_client().delete(cache_key)
        
        # 4. 직접 OKX API를 호출하여 초대 여부 확인
        request_path = f'/api/v5/affiliate/invitee/detail'
 
        if not uid:
            return JSONResponse(
                status_code=400,
                content={"success": False, "message": "UID를 조회할 수 없습니다"}
            )
        
        params = {"uid": uid}
        
        try:
            invitee_data = call_okx_api(fixed_api_key, fixed_secret_key, fixed_passphrase, request_path, params, 'GET')
            print(f"초대 확인 응답: {invitee_data}")
            print("================================================")
            
            # 초대된 사용자가 아닌 경우 (51621 에러 코드)
            if invitee_data.get('code') == OKX_ERROR_INVITEE_NOT_FOUND or "isn't your invitee" in invitee_data.get('msg', '').lower():
                print(f"초대 확인 실패: 초대된 사용자가 아닙니다. 응답: {invitee_data}")
                
                # false 결과 캐싱 (5분간)
                cache_data = {
                    'is_invitee': False,
                    'cached_at': int(time.time()),
                    'valid_until': int(time.time()) + INVITEE_CACHE_FALSE_TTL
                }
                await _get_redis_client().set(
                    cache_key,
                    json.dumps(cache_data),
                    ex=INVITEE_CACHE_FALSE_TTL
                )
                
                # 응답 생성
                response_content = {
                    "success": False,  # 초대된 사용자가 아니므로 success=false
                    "is_invitee": False,
                    "message": "초대된 사용자가 아닙니다.",
                }
                
                # 잔고 정보 추가
                if has_valid_balance and balance_dict:
                    response_content["balance"] = balance_dict
                
                return JSONResponse(
                    status_code=403,  # 초대된 사용자가 아닐 때는 항상 403 반환
                    content=response_content
                )
            
            # 성공적인 응답인 경우
            if (invitee_data.get('code') == '0' and 
                'data' in invitee_data and 
                isinstance(invitee_data['data'], list) and 
                len(invitee_data['data']) > 0):
                
                # API 응답에서 사용자 데이터 추출
                user_data = invitee_data['data'][0]
                
                vol_month = user_data.get('volMonth', '0')
                dep_amt = user_data.get('depAmt', '0')
                acc_fee = user_data.get('accFee', '0')
                
                print(f"초대 확인 성공: volMonth={vol_month}, depAmt={dep_amt}, accFee={acc_fee}")
                
                # 사용자 거래량 정보가 있을 경우 초대된 사용자로 간주
                if vol_month != '0' or dep_amt != '0' or acc_fee != '0' or user_data.get('affiliateCode'):
                    is_invitee = True
                else:
                    # 거래량 정보가 없어도 affiliateCode가 있는지 확인
                    is_invitee = bool(user_data.get('affiliateCode'))
                
                # 초대 여부와 관련 데이터 캐싱
                cache_data = {
                    'is_invitee': is_invitee,
                    'vol_month': vol_month,
                    'dep_amt': dep_amt,
                    'acc_fee': acc_fee,
                    'cached_at': int(time.time()),
                    'valid_until': int(time.time()) + INVITEE_CACHE_TRUE_TTL
                }
                await _get_redis_client().set(
                    cache_key,
                    json.dumps(cache_data),
                    ex=INVITEE_CACHE_TRUE_TTL
                )
                
                return JSONResponse(
                    status_code=200,
                    content={
                        "success": True, 
                        "is_invitee": is_invitee, 
                        "vol_month": vol_month,
                        "dep_amt": dep_amt,
                        "acc_fee": acc_fee,
                        "balance": balance_dict
                    }
                )
            
            # 기타 API 응답 오류 처리
            print(f"초대 확인 오류 또는 알 수 없는 응답: {invitee_data}")
            error_msg = invitee_data.get('msg', '초대 확인 중 오류가 발생했습니다.')
            
            # false 결과 캐싱 (5분간) - 오류이므로 짧게 캐싱
            cache_data = {
                'is_invitee': False,
                'cached_at': int(time.time()),
                'valid_until': int(time.time()) + INVITEE_CACHE_FALSE_TTL
            }
            await _get_redis_client().set(
                cache_key,
                json.dumps(cache_data),
                ex=INVITEE_CACHE_FALSE_TTL
            )
            
            # 응답 반환
            response_content = {
                "success": False,
                "is_invitee": False,
                "message": error_msg
            }
            
            if has_valid_balance and balance_dict:
                response_content["balance"] = balance_dict
            
            return JSONResponse(
                status_code=403,  # 초대 관련 오류는 일관되게 403으로 처리
                content=response_content
            )
            
        except Exception as e:
            # API 호출 또는 처리 중 예외 발생
            error_message = str(e)
            print(f"초대 확인 중 예외 발생: {error_message}")
            
            # 예외에 따른 적절한 응답 구성
            if "invitee" in error_message.lower():
                # 초대 관련 오류는 403 반환
                status_code = 403
                user_message = "초대된 사용자가 아닙니다."
            else:
                # 기타 오류는 500 반환
                status_code = 500
                user_message = f"서버 오류가 발생했습니다: {error_message}"
            
            response_content = {
                "success": has_valid_balance,  # 잔고가 유효하면 success=true
                "is_invitee": False,
                "message": user_message
            }
            
            if has_valid_balance and balance_dict:
                response_content["balance"] = balance_dict
            
            return JSONResponse(
                status_code=status_code,
                content=response_content
            )
            
    except Exception as e:
        # API 키 유효성 검사 중 발생한 오류 처리
        error_message = str(e)
        user_friendly_message = get_user_friendly_error_message(error_message)
        print(f"API 키 유효성 검사 중 오류: {error_message}")
        
        # 오류 유형 분석 및 적절한 상태 코드 설정
        if "unauthorized" in error_message.lower() or "401" in error_message:
            status_code = 401  # 인증 실패
        elif "invitee" in error_message.lower():
            status_code = 403  # 초대 관련 오류
        else:
            status_code = 400  # 기타 API 요청 오류
        
        return JSONResponse(
            status_code=status_code,
            content={
                "success": False,
                "message": user_friendly_message,
                "error": error_message
            }
        ) 