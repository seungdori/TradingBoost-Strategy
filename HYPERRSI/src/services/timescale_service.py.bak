"""TimescaleDB user and API information service.

Provides a unified API for accessing and mutating user rows stored in
the TimescaleDB instances that back the TradingBoost platform.
"""

from __future__ import annotations

import asyncio
import uuid
from contextlib import asynccontextmanager
from dataclasses import dataclass
from datetime import datetime
from typing import Any, AsyncGenerator, Dict, List, Optional

import asyncpg

from shared.config import settings
from shared.logging import get_logger

logger = get_logger(__name__)


class TimescalePool:
    """Lazily initialised asyncpg connection pool for TimescaleDB."""

    _pool: Optional[asyncpg.pool.Pool] = None
    _pool_lock: asyncio.Lock = asyncio.Lock()

    @classmethod
    async def get_pool(cls) -> asyncpg.pool.Pool:
        if cls._pool is None:
            async with cls._pool_lock:
                if cls._pool is None:
                    if not settings.TIMESCALE_HOST:
                        raise RuntimeError("TimescaleDB credentials are not configured")

                    logger.info(
                        "Initialising TimescaleDB connection pool",
                        extra={
                            "host": settings.TIMESCALE_HOST,
                            "port": settings.TIMESCALE_PORT,
                            "database": settings.TIMESCALE_DATABASE,
                        },
                    )

                    cls._pool = await asyncpg.create_pool(
                        host=settings.TIMESCALE_HOST,
                        port=settings.TIMESCALE_PORT,
                        database=settings.TIMESCALE_DATABASE,
                        user=settings.TIMESCALE_USER,
                        password=settings.TIMESCALE_PASSWORD,
                        min_size=1,
                        max_size=max(settings.DB_POOL_SIZE, 5),
                        command_timeout=15,
                    )

        return cls._pool

    @classmethod
    async def close_pool(cls) -> None:
        if cls._pool is not None:
            await cls._pool.close()
            cls._pool = None

    @classmethod
    @asynccontextmanager
    async def acquire(cls) -> AsyncGenerator[asyncpg.connection.Connection, None]:
        pool = await cls.get_pool()
        async with pool.acquire() as connection:
            yield connection


@dataclass
class TimescaleUserRecord:
    """Combined view of an app_users row and its okx_api_info entry."""

    user: Dict[str, Any]
    api: Optional[Dict[str, Any]]


def _normalise_value(value: Any) -> Any:
    if isinstance(value, uuid.UUID):
        return str(value)
    if isinstance(value, datetime):
        return value.isoformat()
    return value


def _record_to_dict(record: Optional[asyncpg.Record]) -> Optional[Dict[str, Any]]:
    if record is None:
        return None
    return {key: _normalise_value(value) for key, value in record.items()}


class TimescaleUserService:
    """High level helpers for Timescale user management."""

    USER_SELECT = """
        SELECT
            au.id AS user_id,
            au.email AS user_email,
            au.name AS user_name,
            au.okx_uid AS user_okx_uid,
            au.telegram_linked AS user_telegram_linked,
            au.telegram_id AS user_telegram_id,
            au.telegram_userid AS user_telegram_userid,
            au.telegram_username AS user_telegram_username,
            au.okx_api_connected AS user_okx_api_connected,
            au.okx_linked AS user_okx_linked,
            au.created_at AS user_created_at,
            au.updated_at AS user_updated_at,
            oi.id AS api_id,
            oi.user_id AS api_user_id,
            oi.api_key AS api_key,
            oi.api_secret AS api_secret,
            oi.passphrase AS api_passphrase,
            oi.telegram_id AS api_telegram_id,
            oi.telegram_linked AS api_telegram_linked,
            oi.okx_uid AS api_okx_uid,
            oi.exchange AS api_exchange,
            oi.created_at AS api_created_at,
            oi.updated_at AS api_updated_at
        FROM app_users AS au
        LEFT JOIN okx_api_info AS oi
            ON oi.user_id = au.id
           AND oi.deleted_at IS NULL
        WHERE au.deleted_at IS NULL
          AND (
                au.okx_uid = $1
            OR  oi.okx_uid = $1
            OR  oi.telegram_id = $1
            OR  au.telegram_id = $1
            OR  au.telegram_userid = $1
            OR  au.id::text = $1
            OR  oi.id::text = $1
          )
        ORDER BY oi.updated_at DESC NULLS LAST, au.updated_at DESC NULLS LAST
        LIMIT 1
    """

    @classmethod
    async def fetch_user(cls, identifier: str) -> Optional[TimescaleUserRecord]:
        if not identifier:
            return None

        async with TimescalePool.acquire() as conn:
            record = await conn.fetchrow(cls.USER_SELECT, str(identifier))

        if record is None:
            return None

        user_dict = {key[len("user_"):]: value for key, value in record.items() if key.startswith("user_")}

        api_dict: Dict[str, Any] = {}
        for key, value in record.items():
            if key.startswith("api_"):
                clean_key = key[len("api_"):]
                if clean_key in {"key", "secret"}:
                    clean_key = f"api_{clean_key}"
                elif clean_key == "passphrase":
                    clean_key = "passphrase"
                api_dict[clean_key] = value

        user_payload = {key: _normalise_value(value) for key, value in user_dict.items()}
        api_payload = {key: _normalise_value(value) for key, value in api_dict.items()} if any(api_dict.values()) else None

        return TimescaleUserRecord(user=user_payload, api=api_payload)

    @classmethod
    async def get_api_keys(cls, identifier: str) -> Optional[Dict[str, Any]]:
        record = await cls.fetch_user(identifier)
        if record is None or record.api is None:
            return None

        api_info = record.api
        if not api_info.get("api_key") or not api_info.get("api_secret") or not api_info.get("passphrase"):
            return None

        return {
            "api_key": api_info.get("api_key"),
            "api_secret": api_info.get("api_secret"),
            "passphrase": api_info.get("passphrase"),
        }

    @classmethod
    async def ensure_user_exists(
        cls,
        okx_uid: str,
        telegram_id: Optional[str] = None,
        display_name: Optional[str] = None,
        telegram_username: Optional[str] = None,
    ) -> Optional[TimescaleUserRecord]:
        """Ensure an app_users row exists for the given OKX UID."""

        # Attempt to locate the user by OKX UID first
        existing = await cls.fetch_user(okx_uid)
        if existing is not None:
            return existing

        # Try telegram identifier if provided
        if telegram_id:
            existing = await cls.fetch_user(telegram_id)
            if existing is not None:
                # Update the OKX UID if it was missing
                if not existing.user.get("okx_uid"):
                    await cls._update_app_user(
                        existing.user["id"],
                        {
                            "okx_uid": okx_uid,
                            "okx_linked": True,
                            "updated_at": "now()",
                        },
                    )
                return await cls.fetch_user(okx_uid)

        if not settings.TIMESCALE_HOST:
            logger.warning("TimescaleDB credentials missing; cannot create new user")
            return None

        generated_email = f"uid_{okx_uid}@autogen.tradingboost"
        display_name = display_name or f"User {okx_uid}"

        async with TimescalePool.acquire() as conn:
            async with conn.transaction():
                user_id = await conn.fetchval(
                    """
                        INSERT INTO app_users (
                            email,
                            name,
                            telegram_linked,
                            telegram_id,
                            telegram_userid,
                            telegram_username,
                            okx_uid,
                            okx_linked,
                            has_trading_access,
                            has_analytics_access,
                            has_realtime_access,
                            created_at,
                            updated_at
                        )
                        VALUES (
                            $1, $2, TRUE, $3, $3, $4, $5, TRUE, TRUE, TRUE, TRUE, now(), now()
                        )
                        RETURNING id
                    """,
                    generated_email,
                    display_name,
                    telegram_id,
                    telegram_username,
                    okx_uid,
                )

                await conn.execute(
                    """
                        INSERT INTO okx_api_info (
                            user_id,
                            okx_uid,
                            telegram_id,
                            telegram_linked,
                            okx_linked,
                            created_at,
                            updated_at
                        )
                        VALUES ($1, $2, $3, $4, TRUE, now(), now())
                    """,
                    user_id,
                    okx_uid,
                    telegram_id,
                    bool(telegram_id),
                )

        return await cls.fetch_user(okx_uid)

    @classmethod
    async def set_telegram_link(
        cls,
        okx_uid: str,
        telegram_id: str,
        display_name: Optional[str] = None,
        telegram_username: Optional[str] = None,
    ) -> Optional[TimescaleUserRecord]:
        record = await cls.ensure_user_exists(okx_uid, telegram_id, display_name, telegram_username)
        if record is None:
            return None

        user_id = record.user["id"]
        api_id = record.api.get("id") if record.api else None

        async with TimescalePool.acquire() as conn:
            async with conn.transaction():
                await conn.execute(
                    """
                        UPDATE app_users
                           SET telegram_linked = TRUE,
                               telegram_id = $2,
                               telegram_userid = $2,
                               telegram_username = COALESCE($3, telegram_username),
                               okx_uid = COALESCE(okx_uid, $4),
                               okx_linked = TRUE,
                               updated_at = now()
                         WHERE id = $1
                    """,
                    user_id,
                    telegram_id,
                    telegram_username,
                    okx_uid,
                )

                if api_id:
                    await conn.execute(
                        """
                            UPDATE okx_api_info
                               SET telegram_id = $2,
                                   telegram_linked = TRUE,
                                   okx_uid = COALESCE(okx_uid, $3),
                                   okx_linked = TRUE,
                                   updated_at = now()
                             WHERE id = $1
                        """,
                        api_id,
                        telegram_id,
                        okx_uid,
                    )
                else:
                    await conn.execute(
                        """
                            INSERT INTO okx_api_info (
                                user_id,
                                okx_uid,
                                telegram_id,
                                telegram_linked,
                                okx_linked,
                                created_at,
                                updated_at
                            )
                            VALUES ($1, $2, $3, TRUE, TRUE, now(), now())
                        """,
                        user_id,
                        okx_uid,
                        telegram_id,
                    )

        return await cls.fetch_user(okx_uid)

    @classmethod
    async def unlink_telegram(cls, okx_uid: str) -> bool:
        record = await cls.fetch_user(okx_uid)
        if record is None:
            return False

        user_id = record.user["id"]
        api_id = record.api.get("id") if record.api else None

        async with TimescalePool.acquire() as conn:
            async with conn.transaction():
                await conn.execute(
                    """
                        UPDATE app_users
                           SET telegram_linked = FALSE,
                               telegram_id = NULL,
                               telegram_userid = NULL,
                               telegram_username = NULL,
                               updated_at = now()
                         WHERE id = $1
                    """,
                    user_id,
                )

                if api_id:
                    await conn.execute(
                        """
                            UPDATE okx_api_info
                               SET telegram_id = NULL,
                                   telegram_linked = FALSE,
                                   updated_at = now()
                             WHERE id = $1
                        """,
                        api_id,
                    )

        return True

    @classmethod
    async def upsert_api_credentials(
        cls,
        identifier: str,
        api_key: Optional[str] = None,
        api_secret: Optional[str] = None,
        passphrase: Optional[str] = None,
    ) -> Optional[TimescaleUserRecord]:
        record = await cls.fetch_user(identifier)
        if record is None:
            return None

        user_id = record.user["id"]
        okx_uid = record.user.get("okx_uid") or record.api.get("okx_uid") if record.api else None

        async with TimescalePool.acquire() as conn:
            async with conn.transaction():
                api_id = record.api.get("id") if record.api else None

                if api_id:
                    await conn.execute(
                        """
                            UPDATE okx_api_info
                               SET api_key = COALESCE($2, api_key),
                                   api_secret = COALESCE($3, api_secret),
                                   passphrase = COALESCE($4, passphrase),
                                   okx_uid = COALESCE(okx_uid, $5),
                                   updated_at = now()
                             WHERE id = $1
                        """,
                        api_id,
                        api_key,
                        api_secret,
                        passphrase,
                        okx_uid,
                    )
                else:
                    await conn.execute(
                        """
                            INSERT INTO okx_api_info (
                                user_id,
                                okx_uid,
                                api_key,
                                api_secret,
                                passphrase,
                                created_at,
                                updated_at
                            )
                            VALUES ($1, $2, $3, $4, $5, now(), now())
                        """,
                        user_id,
                        okx_uid,
                        api_key,
                        api_secret,
                        passphrase,
                    )

        return await cls.fetch_user(identifier)

    @classmethod
    async def update_app_user(cls, user_id: str, fields: Dict[str, Any]) -> None:
        await cls._update_app_user(user_id, fields)

    @classmethod
    async def update_api_record(cls, api_id: str, fields: Dict[str, Any]) -> None:
        if not api_id or not fields:
            return

        assignments = []
        values: List[Any] = []
        idx = 1

        for column, value in fields.items():
            if value == "now()":
                assignments.append(f"{column} = now()")
            else:
                assignments.append(f"{column} = ${idx}")
                values.append(value)
                idx += 1

        query = f"""
            UPDATE okx_api_info
               SET {', '.join(assignments)}
             WHERE id = ${idx}
        """

        values.append(api_id)

        async with TimescalePool.acquire() as conn:
            await conn.execute(query, *values)

    @classmethod
    async def _update_app_user(cls, user_id: str, fields: Dict[str, Any]) -> None:
        if not fields:
            return

        assignments = []
        values = []
        idx = 1

        for column, value in fields.items():
            if value == "now()":
                assignments.append(f"{column} = now()")
            else:
                assignments.append(f"{column} = ${idx}")
                values.append(value)
                idx += 1

        query = f"""
            UPDATE app_users
               SET {', '.join(assignments)}
             WHERE id = ${idx}
        """

        values.append(user_id)

        async with TimescalePool.acquire() as conn:
            await conn.execute(query, *values)
