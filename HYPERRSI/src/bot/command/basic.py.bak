# src/bot/commands/basic.py

from aiogram import types, Router, F
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import any_state

from HYPERRSI.src.services.timescale_service import TimescaleUserService
import logging

from HYPERRSI.src.bot.states.states import RegisterStates  

router = Router()
logger = logging.getLogger(__name__)

# Dynamic redis_client access
def _get_redis_client():
    """Get redis_client dynamically to avoid import-time errors"""
    from HYPERRSI.src.core import database as db_module
    return db_module.redis_client

# redis_client = _get_redis_client()  # Removed - causes import-time error

def get_redis_keys(user_id):
    return {
        'status': f"user:{user_id}:trading:status",
        'api_keys': f"user:{user_id}:api:keys",
        'stats': f"user:{user_id}:stats",
    }


allowed_uid = ["518796558012178692", "549641376070615063", "587662504768345929", "510436564820701267"]

def is_allowed_user(user_id):
    """í—ˆìš©ëœ ì‚¬ìš©ìì¸ì§€ í™•ì¸"""
    return str(user_id) in allowed_uid

@router.message(Command("start"))
async def start_command(message: types.Message, state: FSMContext) -> None:
    """ì‹œì‘ ëª…ë ¹ì–´ ì²˜ë¦¬"""
    if not message.from_user:
        return
    user_id = message.from_user.id
    
    telegram_uid_key = f"user:{user_id}:okx_uid"
   
    # ì´ë¯¸ ë“±ë¡ëœ UIDê°€ ìˆëŠ”ì§€ í™•ì¸
    okx_uid = await _get_redis_client().get(telegram_uid_key)

    if okx_uid:
        if isinstance(okx_uid, bytes):
            okx_uid = okx_uid.decode()

        display_name = " ".join(filter(None, [message.from_user.first_name, message.from_user.last_name])).strip()
        username = message.from_user.username

        try:
            await TimescaleUserService.set_telegram_link(
                str(okx_uid),
                str(user_id),
                display_name=display_name or None,
                telegram_username=username,
            )
            logger.info(f"TimescaleDB link ensured for existing user {okx_uid} (telegram {user_id})")
        except Exception as exc:
            logger.error(f"TimescaleDB ë§í¬ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {exc}")

        await message.reply(
            f"ğŸ‘‹ ì•ˆë…•í•˜ì„¸ìš”! ì´ë¯¸ ì—°ë™ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\n\n"
            f"ì—°ë™ëœ UID: {okx_uid}\n"
            f"ì„¤ì •ì„ ì´ˆê¸°í™”í•˜ë ¤ë©´ /reset ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."
        )
        return

    # ë“±ë¡ë˜ì§€ ì•Šì€ ê²½ìš° UID ì…ë ¥ ìš”ì²­
    await message.reply(
        "ğŸ‘‹ ì•ˆë…•í•˜ì„¸ìš”! íŠ¸ë ˆì´ë”© ì•Œë¦¼ ë´‡ì…ë‹ˆë‹¤.\n\n"
        "ğŸ”‘ ì‹œìŠ¤í…œê³¼ ì—°ë™í•˜ê¸° ìœ„í•´ UIDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”:"
    )
   
    # UID ì…ë ¥ ìƒíƒœë¡œ ì „í™˜
    await state.set_state("waiting_for_uid")

# UID ì…ë ¥ ìƒíƒœì—ì„œì˜ ë©”ì‹œì§€ ì²˜ë¦¬
@router.message(StateFilter("waiting_for_uid"))
async def process_uid(message: types.Message, state: FSMContext) -> None:
    """UID ì…ë ¥ ì²˜ë¦¬"""
    if not message.from_user or not message.text:
        return
    user_id = message.from_user.id

    telegram_uid_key = f"user:{user_id}:okx_uid"

    # ì…ë ¥ëœ í…ìŠ¤íŠ¸ê°€ UID
    okx_uid = message.text.strip()
    
    try:
        # UIDë¥¼ ìˆ«ìë¡œ ë³€í™˜ ì‹œë„í•˜ì—¬ ìœ íš¨ì„± ê²€ì‚¬
        okx_uid_int = int(okx_uid)
        
        # Redisì— UID ì €ì¥
        await _get_redis_client().set(telegram_uid_key, okx_uid)
        
        display_name = " ".join(filter(None, [message.from_user.first_name, message.from_user.last_name])).strip()
        username = message.from_user.username

        timescale_status = "TimescaleDB ì—°ë™ ì™„ë£Œ"
        try:
            record = await TimescaleUserService.set_telegram_link(
                str(okx_uid),
                str(user_id),
                display_name=display_name or None,
                telegram_username=username,
            )
            if record is None:
                timescale_status = "âš ï¸ TimescaleDBì— ì‚¬ìš©ì ì •ë³´ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”."
                logger.warning(f"TimescaleDBì—ì„œ ì‚¬ìš©ì {user_id} / {okx_uid}ë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            else:
                logger.info(f"TimescaleDB link established for user {user_id} with OKX UID {okx_uid}")
        except Exception as exc:
            timescale_status = f"âš ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {exc}"
            logger.error(f"TimescaleDB ë“±ë¡ ì˜¤ë¥˜: {exc}")
        
        # ìƒíƒœ ì´ˆê¸°í™”
        await state.clear()
        
        # ê¸°ë³¸ ì„¤ì • ì´ˆê¸°í™”
        try:
            from shared.constants.default_settings import DEFAULT_PARAMS_SETTINGS, DEFAULT_DUAL_SIDE_ENTRY_SETTINGS
            from HYPERRSI.src.services.redis_service import RedisService
            redis_service = RedisService()
            
            # ì‚¬ìš©ì ì„¤ì • ì´ˆê¸°í™”
            default_settings = DEFAULT_PARAMS_SETTINGS.copy()
            await redis_service.set_user_settings(str(okx_uid), default_settings)
            
            # ì–‘ë°©í–¥ ë§¤ë§¤ ì„¤ì • ì´ˆê¸°í™”
            default_dual_settings = {k: v for k, v in DEFAULT_DUAL_SIDE_ENTRY_SETTINGS.items()}
            settings_key = f"user:{okx_uid}:dual_side"
            settings_to_save = {k: str(v).lower() if isinstance(v, bool) else str(v) for k, v in default_dual_settings.items()}
            await _get_redis_client().hset(settings_key, mapping=settings_to_save)
            
            await message.reply(
                f"âœ… UID ({okx_uid}) ë“±ë¡ ì™„ë£Œ!\n"
                "ì´ì œ íŠ¸ë ˆì´ë”© ì•Œë¦¼ì„ ë°›ìœ¼ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
            )

            if timescale_status.startswith("âš ï¸"):
                await message.reply(timescale_status)
        except Exception as e:
            await message.reply(
                f"âš ï¸ UIDëŠ” ë“±ë¡ë˜ì—ˆìœ¼ë‚˜ ì„¤ì • ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}\n"
                "ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”."
            )
            
    except ValueError:
        await message.reply(
            "âŒ ìœ íš¨í•˜ì§€ ì•Šì€ UID í˜•ì‹ì…ë‹ˆë‹¤. ìˆ«ìë§Œ ì…ë ¥í•´ì£¼ì„¸ìš”."
        )

@router.message(Command("reset"))
async def reset_command(message: types.Message) -> None:
    """UID ë¦¬ì…‹ ëª…ë ¹ì–´ ì²˜ë¦¬"""
    if not message.from_user:
        return
    user_id = message.from_user.id
    
    telegram_uid_key = f"user:{user_id}:okx_uid"
    
    # ë“±ë¡ëœ UID í™•ì¸
    okx_uid = await _get_redis_client().get(telegram_uid_key)
    
    if not okx_uid:
        await message.reply(
            "âŒ ë“±ë¡ëœ UIDê°€ ì—†ìŠµë‹ˆë‹¤.\n"
            "/start ëª…ë ¹ì–´ë¡œ ë¨¼ì € UIDë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”."
        )
        return
    
    # Redisì—ì„œ UID ì‚­ì œ
    await _get_redis_client().delete(telegram_uid_key)
    
    # TimescaleDBì—ì„œ ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸
    okx_uid_str = okx_uid.decode() if isinstance(okx_uid, bytes) else str(okx_uid)
    try:
        success = await TimescaleUserService.unlink_telegram(okx_uid_str)
        timescale_status = "âœ… í…”ë ˆê·¸ë¨ ì—°ê²° í•´ì œë¨" if success else "âš ï¸ TimescaleDBì—ì„œ ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
    except Exception as exc:
        logger.error(f"TimescaleDB ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {exc}")
        timescale_status = f"âŒ ì˜¤ë¥˜: {exc}"
    
    await message.reply(
        f"âœ… UID ({okx_uid}) ì—°ë™ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.\n"

        "ë‹¤ì‹œ ë“±ë¡í•˜ë ¤ë©´ /start ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."
    )
    if timescale_status and timescale_status != "âœ… í…”ë ˆê·¸ë¨ ì—°ê²° í•´ì œë¨":
        await message.reply(timescale_status)

#@router.message(Command("check"))
#async def check_command(message: types.Message):
#    """í˜„ì¬ UID í™•ì¸ ëª…ë ¹ì–´ ì²˜ë¦¬"""
#    user_id = message.from_user.id
    
#    # í—ˆìš©ëœ ì‚¬ìš©ìë§Œ ì‚¬ìš© ê°€ëŠ¥
#    if not is_allowed_user(user_id):
#        await message.reply("â›” ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.")
#        return
        
#    telegram_uid_key = f"user:{user_id}:okx_uid"
    
#    # ë“±ë¡ëœ UID í™•ì¸
#    okx_uid = await redis_client.get(telegram_uid_key)
    
#    if okx_uid:
#        await message.reply(
#            f"âœ… ì—°ë™ ìƒíƒœ: í™œì„±í™”\n\n"
#            f"ì—°ë™ëœ UID: {okx_uid}"
#        )
#    else:
#        await message.reply(
#            "âŒ ì—°ë™ ìƒíƒœ: ë¯¸ì—°ë™\n\n"
#            "UID ë“±ë¡ì´ í•„ìš”í•©ë‹ˆë‹¤.\n"
#            "/start ëª…ë ¹ì–´ë¥¼ í†µí•´ UIDë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”."
#        )

@router.message(Command("cancel"), StateFilter(any_state))
async def cancel_command(message: types.Message, state: FSMContext) -> None:
    """í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ìƒíƒœ/ëª…ë ¹ì–´ ì·¨ì†Œ"""
    if not message.from_user:
        return
    user_id = message.from_user.id
    

        
    current_state = await state.get_state()
    
    if current_state is None:
        await message.reply(
            "ì·¨ì†Œí•  ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤."
        )
        return
    
    # FSM ìƒíƒœ ì´ˆê¸°í™”
    await state.clear()
    
    # ì·¨ì†Œ í™•ì¸ ë©”ì‹œì§€
    if current_state == "waiting_for_uid":
        await message.reply(
            "âœ… UID ë“±ë¡ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.\n"
            "ë‹¤ì‹œ ì‹œì‘í•˜ì‹œë ¤ë©´ /start ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”."
        )
    else:
        await message.reply("âœ… ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")

@router.message(Command("help"))
async def help_command(message: types.Message) -> None:
   """ë„ì›€ë§ í‘œì‹œ"""
   if not message.from_user:
       return
   user_id = message.from_user.id
   
   okx_uid = await _get_redis_client().get(f"user:{user_id}:okx_uid")
   if not is_allowed_user(okx_uid):
       await message.reply("â›” ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.")
       return
   
   keys = get_redis_keys(user_id)
   api_keys = await _get_redis_client().hgetall(keys['api_keys'])
   is_registered = bool(api_keys)

   basic_commands = (
       "ğŸ¯ ëª…ë ¹ì–´\n"
       "â”œ ğŸš€ /trade - ë´‡ ì‹œì‘í•˜ê¸°\n"
       "â”œ ğŸ“Š /status - ì‹¤ì‹œê°„ í¬ì§€ì…˜ ë° ìˆ˜ìµ í˜„í™©\n"
       "â”œ ğŸ’° /balance - í¬ì§€ì…˜ + ê³„ì¢Œ ì”ê³  í™•ì¸\n"
       "â”œ ğŸ“œ /history - ê±°ë˜ ë‚´ì—­ ì¡°íšŒ\n"
       "â”œ ğŸ“Š /stats - íŠ¸ë ˆì´ë”© í†µê³„\n"
       "â”œ âš™ï¸ /settings - íŠ¸ë ˆì´ë”© ì„¤ì •\n"
       "â”œ ğŸ”„ /dual_settings - ì–‘ë°©í–¥ ë§¤ë§¤ ì„¤ì •\n" 
       "â”œ â“ /help - ë„ì›€ë§ ë³´ê¸°\n"
       "â”” â›” /stop - ë´‡ ì¢…ë£Œ\n"
   )

   if not is_registered:
       commands = (
           f"{basic_commands}\n"
           "ğŸ” ê³„ì • ì„¤ì •\n"
           "â”” ğŸ“ /register - ìƒˆ ì‚¬ìš©ì ë“±ë¡ (API í‚¤ ì„¤ì •)\n"
           "\nâš ï¸ íŠ¸ë ˆì´ë”©ì„ ì‹œì‘í•˜ë ¤ë©´ ë¨¼ì € ë“±ë¡ì´ í•„ìš”í•©ë‹ˆë‹¤."
       )
   else:
       trading_status = await _get_redis_client().get(keys['status'])
       is_trading = trading_status == "running"
       commands = (
           f"{basic_commands}"
       )

       status_text = "ğŸŸ¢ í™œì„±í™”" if is_trading else "ğŸ”´ ë¹„í™œì„±í™”"
       commands += f"\n\nğŸ“¡ í˜„ì¬ íŠ¸ë ˆì´ë”© ìƒíƒœ: {status_text}"

   await message.reply(commands)
